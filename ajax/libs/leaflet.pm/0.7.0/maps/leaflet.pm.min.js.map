{"version":3,"sources":["leaflet.pm.js","L.PM.js","L.PM.Draw.js","L.PM.Edit.js","L.Controls.js","Edit/L.PM.Edit.LayerGroup.js","Edit/L.PM.Edit.Poly.js","Draw/L.PM.Draw.Poly.js"],"names":["L","PM","initialize","initLayerGroup","this","pm","Edit","LayerGroup","addInitHook","initPolygon","Poly","Polygon","initMap","Draw","Map","Class","extend","map","_this","_map","shapes","forEach","shape","getShapes","enableDraw","join","disableDraw","enable","_this2","disable","addControls","_this3","addButton","Control","PMButton","options","position","_button","setButton","onAdd","container","DomUtil","create","_container","_makeButton","onRemove","button","className","iconUrl","onClick","afterClick","doToggle","toggleStatus","getText","text","getIconUrl","destroy","_update","toggle","e","toggled","onCreate","newButton","addClass","image","setAttribute","DomEvent","addListener","_clicked","disableClickPropagation","removeClass","childNodes","layerGroup","_layerGroup","_layers","getLayers","availableEvents","layer","event","on","_fireEvent","target","enabled","getOptions","fireEvent","type","toggleEdit","_options","find","dragging","poly","_poly","_enabled","arguments","length","undefined","_initMarkers","window","turf","preventOverlap","console","warn","draggable","_initDraggableLayer","_dragging","_markerGroup","clearLayers","off","el","_path","_tempDragCoord","onMouseUp","_applyPossibleCoordsChanges","setTimeout","fire","_fireEdit","onMouseMove","bringToFront","_onLayerDrag","latlng","deltaLatLng","lat","lng","coords","_latlngs","newLatLngs","currentLatLng","setLatLngs","redraw","_handleOverlap","addLayer","_markers","_createMarker","k","nextIndex","_createMiddleMarker","index","marker","Marker","icon","divIcon","_origLatLng","_index","_onMarkerDrag","_onMarkerDragEnd","_removeMarker","leftM","rightM","_calcMiddleLatLng","getLatLng","middleMarker","setIcon","_middleMarkerNext","_middleMarkerPrev","_addMarker","newM","splice","i","removeLayer","leftMarkerIndex","rightMarkerIndex","_tempPolygon","latlngs","getLatLngs","_drawTemporaryPolygon","geoJson","setStyle","opacity","fillOpacity","addTo","bringToBack","mainPoly","layers","changed","resultingGeoJson","toGeoJSON","filter","Object","is","intersect","difference","geometry","remove","nextMarkerIndex","prevMarkerIndex","_latlng","markerLatLng","prevMarkerLatLng","nextMarkerLatLng","middleMarkerNextLatLng","setLatLng","middleMarkerPrevLatLng","edited","latlng1","latlng2","p1","project","p2","unproject","_add","_divideBy","_shape","_polyline","polyline","color","_hintline","dashArray","style","cursor","_createPolygonPoint","_syncHintLine","self","drawPolyButton","_drawButton","polyPoints","lastPolygonPoint","first","addLatLng","_finishPolygon","polygonLayer","polygon"],"mappings":"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","file":"leaflet.pm.min.js","sourcesContent":["\"use strict\";\n\n/**\n*\n* A Leaflet Plugin For Editing Geometry Layers in Leaflet 1.0\n* by Sumit Kumar (@TweetsOfSumit)\n* Github Repo: https://github.com/codeofsumit/leaflet.pm\n*/\n\nL.PM = L.PM || {\n    initialize: function initialize() {\n\n        var initLayerGroup = function initLayerGroup() {\n            this.pm = new L.PM.Edit.LayerGroup(this);\n        };\n        L.LayerGroup.addInitHook(initLayerGroup);\n\n        var initPolygon = function initPolygon() {\n            this.pm = new L.PM.Edit.Poly(this);\n        };\n        L.Polygon.addInitHook(initPolygon);\n\n        var initMap = function initMap() {\n            this.pm = new L.PM.Draw(this);\n        };\n        L.Map.addInitHook(initMap);\n    }\n};\n\n// initialize leaflet.pm\nL.PM.initialize();\n'use strict';\n\nL.PM.Draw = L.Class.extend({\n\n    initialize: function initialize(map) {\n        var _this = this;\n\n        // save the map\n        this._map = map;\n\n        // define all possible shapes that can be drawn\n        this.shapes = ['Poly'];\n\n        // initiate drawing class for our shapes\n        this.shapes.forEach(function (shape) {\n            _this[shape] = new L.PM.Draw[shape](_this._map);\n        });\n    },\n    getShapes: function getShapes() {\n        // if somebody wants to know what shapes are available\n        return this.shapes;\n    },\n    enableDraw: function enableDraw(shape) {\n\n        if (!shape) {\n            throw 'Error: Please pass a shape as a parameter. Possible shapes are: ' + this.getShapes().join(',');\n        }\n\n        // disable drawing for all shapes\n        this.disableDraw();\n\n        // enable draw for a shape\n        this[shape].enable();\n    },\n    disableDraw: function disableDraw() {\n        var _this2 = this;\n\n        // there can only be one drawing mode active at a time on a map\n        // so it doesn't matter which one should be disabled.\n        // just disable all of them\n        this.shapes.forEach(function (shape) {\n            _this2[shape].disable();\n        });\n    },\n    addControls: function addControls() {\n        var _this3 = this;\n\n        // add control buttons for our shapes\n        this.shapes.forEach(function (shape) {\n            _this3[shape].addButton();\n        });\n    }\n});\n\"use strict\";\n\nL.PM.Edit = L.Class.extend({});\n'use strict';\n\nL.Control.PMButton = L.Control.extend({\n    options: {\n        position: 'topleft'\n    },\n    initialize: function initialize(options) {\n        this._button = {};\n        this.setButton(options);\n    },\n\n    onAdd: function onAdd(map) {\n\n        this._map = map;\n        var container = L.DomUtil.create('div', 'leaflet-control-button');\n\n        this._container = container;\n\n        this._makeButton(this._button);\n        return this._container;\n    },\n\n    onRemove: function onRemove(map) {},\n\n    setButton: function setButton(options) {\n        var button = {\n            'className': options.className,\n            'iconUrl': options.iconUrl,\n            'onClick': options.onClick,\n            'afterClick': options.afterClick,\n            'doToggle': options.doToggle,\n            'toggleStatus': options.toggleStatus\n        };\n\n        this._button = button;\n    },\n\n    getText: function getText() {\n        return this._button.text;\n    },\n\n    getIconUrl: function getIconUrl() {\n        return this._button.iconUrl;\n    },\n\n    destroy: function destroy() {\n        this._button = {};\n        this._update();\n    },\n\n    toggle: function toggle(e) {\n        if (typeof e === 'boolean') {\n            this._button.toggleStatus = e;\n        } else {\n            this._button.toggleStatus = !this._button.toggleStatus;\n        }\n    },\n    toggled: function toggled() {\n        return this._button.toggleStatus;\n    },\n    onCreate: function onCreate() {\n        this.toggle(false);\n    },\n    _makeButton: function _makeButton(button) {\n\n        var newButton = L.DomUtil.create('div', 'leaflet-buttons-control-button', this._container);\n        if (button.toggleStatus) L.DomUtil.addClass(newButton, 'active');\n\n        var image = L.DomUtil.create('img', 'control-icon', newButton);\n        if (button.iconUrl) {\n            image.setAttribute('src', button.iconUrl);\n        }\n        if (button.className) {\n            L.DomUtil.addClass(image, button.className);\n        }\n\n        L.DomEvent.addListener(newButton, 'click', button.onClick, this).addListener(newButton, 'click', this._clicked, this).addListener(newButton, 'click', button.afterClick, this);\n\n        L.DomEvent.disableClickPropagation(newButton);\n        return newButton;\n    },\n\n    _clicked: function _clicked() {\n\n        if (this._button.doToggle) {\n\n            if (this._button.toggleStatus) {\n                L.DomUtil.removeClass(this._container.childNodes[0], 'active');\n            } else {\n                L.DomUtil.addClass(this._container.childNodes[0], 'active');\n            }\n            this.toggle();\n        }\n        return;\n    }\n\n});\n'use strict';\n\n// LayerGroup doesn't inherit from L.PM.Edit because it's just calling L.PM.Edit.Poly\n// (which inherits from L.PM.Edit) for each layer,\n// so it's not really a parent class\nL.PM.Edit.LayerGroup = L.Class.extend({\n    initialize: function initialize(layerGroup) {\n        var _this = this;\n\n        this._layerGroup = layerGroup;\n        this._layers = layerGroup.getLayers();\n\n        var availableEvents = ['pm:edit', 'pm:dragstart', 'pm:drag', 'pm:dragend'];\n\n        this._layers.forEach(function (layer) {\n\n            // listen to the events of the layers in this group\n            availableEvents.forEach(function (event) {\n                layer.on(event, _this._fireEvent, _this);\n            });\n\n            // add reference for the group to each layer inside said group\n            layer.pm._layerGroup = _this._layerGroup;\n        });\n\n        // if a new layer is added to the group, reinitialize\n        // This only works for FeatureGroups, not LayerGroups\n        // https://github.com/Leaflet/Leaflet/issues/4861\n        this._layerGroup.on('layeradd', function (e) {\n\n            _this.initialize(layerGroup);\n\n            // if editing was already enabled for this group, enable it again\n            // so the new layers are enabled\n            if (e.target.pm.enabled()) {\n                _this.enable(_this.getOptions());\n            }\n        });\n    },\n    _fireEvent: function _fireEvent(e) {\n        this._layerGroup.fireEvent(e.type, e);\n    },\n    toggleEdit: function toggleEdit(options) {\n        this._options = options;\n        this._layers.forEach(function (layer) {\n            layer.pm.toggleEdit(options);\n        });\n    },\n    enable: function enable(options) {\n        this._options = options;\n        this._layers.forEach(function (layer) {\n            layer.pm.enable(options);\n        });\n    },\n    disable: function disable() {\n        this._layers.forEach(function (layer) {\n            layer.pm.disable();\n        });\n    },\n    enabled: function enabled() {\n        var enabled = this._layers.find(function (layer) {\n            return layer.pm.enabled();\n        });\n        return !!enabled;\n    },\n    dragging: function dragging() {\n        var dragging = this._layers.find(function (layer) {\n            return layer.pm.dragging();\n        });\n        return !!dragging;\n    },\n    getOptions: function getOptions() {\n        return this._options;\n    }\n});\n'use strict';\n\nL.PM.Edit.Poly = L.PM.Edit.extend({\n\n    initialize: function initialize(poly) {\n        this._poly = poly;\n        this._enabled = false;\n    },\n\n    toggleEdit: function toggleEdit(options) {\n        if (!this.enabled()) {\n            this.enable(options);\n        } else {\n            this.disable();\n        }\n    },\n\n    enable: function enable() {\n        var _this = this;\n\n        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n\n        this.options = options;\n\n        if (!this.enabled()) {\n            // change state\n            this._enabled = true;\n\n            // init markers\n            this._initMarkers();\n\n            // if polygon gets removed from map, disable edit mode\n            this._poly.on('remove', function (e) {\n                _this.disable(e.target);\n            });\n\n            // preventOverlap needs the turf library. If it's not included, deactivate it again\n            if (window.turf === undefined && this.options.preventOverlap) {\n                console.warn('TurfJS not found, preventOverlap is deactivated');\n                this.options.preventOverlap = false;\n            }\n\n            if (this.options.draggable) {\n                this._initDraggableLayer();\n            }\n        }\n    },\n\n    enabled: function enabled() {\n        return this._enabled;\n    },\n\n    disable: function disable() {\n        var poly = arguments.length <= 0 || arguments[0] === undefined ? this._poly : arguments[0];\n\n\n        // prevent disabling if polygon is being dragged\n        if (poly.pm._dragging) {\n            return false;\n        }\n        poly.pm._enabled = false;\n        poly.pm._markerGroup.clearLayers();\n\n        // clean up draggable\n        poly.off('mousedown');\n        poly.off('mouseup');\n\n        // remove draggable class\n        var el = poly._path;\n        L.DomUtil.removeClass(el, 'leaflet-pm-draggable');\n    },\n\n    dragging: function dragging() {\n        return this._dragging;\n    },\n\n    _initDraggableLayer: function _initDraggableLayer() {\n        var _this2 = this;\n\n        // temporary coord variable for delta calculation\n        this._tempDragCoord;\n\n        // add CSS class\n        var el = this._poly._path;\n        L.DomUtil.addClass(el, 'leaflet-pm-draggable');\n\n        var onMouseUp = function onMouseUp(e) {\n\n            // re-enable map drag\n            _this2._poly._map.dragging.enable();\n\n            // clear up mousemove event\n            _this2._poly._map.off('mousemove');\n\n            // clear up mouseup event\n            _this2._poly.off('mouseup');\n\n            // show markers again\n            _this2._initMarkers();\n\n            // set new coordinates, more details inside the function\n            _this2._applyPossibleCoordsChanges();\n\n            // timeout to prevent click event after drag :-/\n            // TODO: do it better as soon as leaflet has a way to do it better :-)\n            window.setTimeout(function () {\n                // set state\n                _this2._dragging = false;\n                L.DomUtil.removeClass(el, 'leaflet-pm-dragging');\n\n                // fire pm:dragend event\n                _this2._poly.fire('pm:dragend');\n\n                // fire edit\n                _this2._fireEdit();\n            }, 10);\n        };\n\n        var onMouseMove = function onMouseMove(e) {\n\n            if (!_this2._dragging) {\n\n                // set state\n                _this2._dragging = true;\n                L.DomUtil.addClass(el, 'leaflet-pm-dragging');\n\n                // bring it to front to prevent drag interception\n                _this2._poly.bringToFront();\n\n                // disbale map drag\n                _this2._poly._map.dragging.disable();\n\n                // hide markers\n                _this2._markerGroup.clearLayers();\n\n                // fire pm:dragstart event\n                _this2._poly.fire('pm:dragstart');\n            }\n\n            _this2._onLayerDrag(e);\n        };\n\n        this._poly.on('mousedown', function (e) {\n\n            // save for delta calculation\n            _this2._tempDragCoord = e.latlng;\n\n            _this2._poly.on('mouseup', onMouseUp);\n\n            // listen to mousemove on map (instead of polygon),\n            // otherwise fast mouse movements stop the drag\n            _this2._poly._map.on('mousemove', onMouseMove);\n        });\n    },\n\n    _onLayerDrag: function _onLayerDrag(e) {\n\n        // latLng of mouse event\n        var latlng = e.latlng;\n\n        // delta coords (how far was dragged)\n        var deltaLatLng = {\n            lat: latlng.lat - this._tempDragCoord.lat,\n            lng: latlng.lng - this._tempDragCoord.lng\n        };\n\n        // create the new coordinates array\n        var coords = this._poly._latlngs[0];\n        var newLatLngs = coords.map(function (currentLatLng) {\n            return {\n                lat: currentLatLng.lat + deltaLatLng.lat,\n                lng: currentLatLng.lng + deltaLatLng.lng\n            };\n        });\n\n        // set new coordinates and redraw\n        this._poly.setLatLngs(newLatLngs).redraw();\n\n        // save current latlng for next delta calculation\n        this._tempDragCoord = latlng;\n\n        // if the dragged polygon should be cutted when overlapping another polygon, go ahead\n        if (this.options.preventOverlap) {\n            this._handleOverlap();\n        }\n\n        // fire pm:dragstart event\n        this._poly.fire('pm:drag');\n    },\n\n    _initMarkers: function _initMarkers() {\n        var map = this._poly._map;\n\n        // cleanup old ones first\n        if (this._markerGroup) {\n            this._markerGroup.clearLayers();\n        }\n\n        // add markerGroup to map, markerGroup includes regular and middle markers\n        this._markerGroup = new L.LayerGroup();\n        map.addLayer(this._markerGroup);\n\n        // create marker for each coordinate\n        var coords = this._poly._latlngs[0];\n\n        // the marker array, it includes only the markers that're associated with the coordinates\n        this._markers = coords.map(this._createMarker, this);\n\n        // create small markers in the middle of the regular markers\n        for (var k = 0; k < coords.length; k++) {\n\n            var nextIndex = k + 1 >= coords.length ? 0 : k + 1;\n            this._createMiddleMarker(this._markers[k], this._markers[nextIndex]);\n        }\n    },\n\n    // creates initial markers for coordinates\n    _createMarker: function _createMarker(latlng, index) {\n\n        var marker = new L.Marker(latlng, {\n            draggable: true,\n            icon: L.divIcon({ className: 'marker-icon' })\n        });\n\n        marker._origLatLng = latlng;\n        marker._index = index;\n\n        marker.on('drag', this._onMarkerDrag, this);\n        marker.on('dragend', this._onMarkerDragEnd, this);\n        marker.on('contextmenu', this._removeMarker, this);\n\n        this._markerGroup.addLayer(marker);\n\n        return marker;\n    },\n\n    // creates the middle markes between coordinates\n    _createMiddleMarker: function _createMiddleMarker(leftM, rightM) {\n        var _this3 = this;\n\n        var latlng = this._calcMiddleLatLng(leftM.getLatLng(), rightM.getLatLng());\n\n        var middleMarker = this._createMarker(latlng);\n        var icon = L.divIcon({ className: 'marker-icon marker-icon-middle' });\n        middleMarker.setIcon(icon);\n\n        // save reference to this middle markers on the neighboor regular markers\n        leftM._middleMarkerNext = middleMarker;\n        rightM._middleMarkerPrev = middleMarker;\n\n        middleMarker.on('click', function () {\n\n            // TODO: move the next two lines inside _addMarker() as soon as\n            // https://github.com/Leaflet/Leaflet/issues/4484\n            // is fixed\n            var icon = L.divIcon({ className: 'marker-icon' });\n            middleMarker.setIcon(icon);\n\n            _this3._addMarker(middleMarker, leftM, rightM);\n        });\n        middleMarker.on('movestart', function () {\n\n            // TODO: This is a workaround. Remove the moveend listener and callback as soon as this is fixed:\n            // https://github.com/Leaflet/Leaflet/issues/4484\n            middleMarker.on('moveend', function () {\n                var icon = L.divIcon({ className: 'marker-icon' });\n                middleMarker.setIcon(icon);\n\n                middleMarker.off('moveend');\n            });\n\n            _this3._addMarker(middleMarker, leftM, rightM);\n        });\n    },\n\n    // adds a new marker from a middlemarker\n    _addMarker: function _addMarker(newM, leftM, rightM) {\n\n        // first, make this middlemarker a regular marker\n        newM.off('movestart');\n        newM.off('click');\n\n        // now, create the polygon coordinate point for that marker\n        var latlng = newM.getLatLng();\n        var coords = this._poly._latlngs[0];\n        var index = leftM._index + 1;\n\n        coords.splice(index, 0, latlng);\n\n        // associate polygon coordinate with marker coordinate\n        newM._origLatLng = coords[index];\n\n        // push into marker array & update the indexes for every marker\n        this._markers.splice(index, 0, newM);\n        this._markers.map(function (marker, i) {\n            return marker._index = i;\n        });\n\n        // create the new middlemarkers\n        this._createMiddleMarker(leftM, newM);\n        this._createMiddleMarker(newM, rightM);\n\n        // fire edit event\n        this._fireEdit();\n    },\n\n    _removeMarker: function _removeMarker(e) {\n        var marker = e.target;\n\n        // only continue if this is NOT a middle marker (those can't be deleted)\n        if (marker._index === undefined) {\n            return;\n        }\n\n        // remove polygon coordinate from this marker\n        var coords = this._poly._latlngs[0];\n        var index = marker._index;\n\n        coords.splice(index, 1);\n        this._poly.redraw();\n\n        // remove the marker and the middlemarkers next to it from the map\n        this._markerGroup.removeLayer(marker._middleMarkerPrev);\n        this._markerGroup.removeLayer(marker._middleMarkerNext);\n        this._markerGroup.removeLayer(marker);\n\n        // create the new middlemarker\n        var leftMarkerIndex = index - 1 < 0 ? this._markers.length - 1 : index - 1;\n        var rightMarkerIndex = index + 1 >= this._markers.length ? 0 : index + 1;\n\n        var leftM = this._markers[leftMarkerIndex];\n        var rightM = this._markers[rightMarkerIndex];\n        this._createMiddleMarker(leftM, rightM);\n\n        // remove the marker from the markers array & update indexes\n        this._markers.splice(index, 1);\n        this._markers.map(function (marker, i) {\n            return marker._index = i;\n        });\n\n        // if the polygon should be cutted when overlapping another polygon, do it now\n        if (this.options.preventOverlap) {\n            this._handleOverlap();\n            this._applyPossibleCoordsChanges();\n        }\n\n        // fire edit event\n        this._fireEdit();\n    },\n\n    _applyPossibleCoordsChanges: function _applyPossibleCoordsChanges() {\n\n        // after the polygon was dragged and changed it's shape because of unallowed intersecting\n        // with another polygon, this function takes the temporarily drawn polygon (during drag) and applies\n        // it's coordinates to our main polygon\n\n        if (this._tempPolygon) {\n\n            // get the new coordinates\n            var latlngs = this._tempPolygon.getLayers()[0].getLatLngs();\n\n            // reshape our main polygon\n            this._poly.setLatLngs(latlngs).redraw();\n\n            // initialize the markers again\n            this._initMarkers();\n        }\n    },\n\n    _drawTemporaryPolygon: function _drawTemporaryPolygon(geoJson) {\n\n        // hide our polygon\n        this._poly.setStyle({ opacity: 0, fillOpacity: 0 });\n\n        // draw a temporary polygon (happens during drag)\n        this._tempPolygon = L.geoJson(geoJson).addTo(this._poly._map).bringToBack();\n    },\n    _handleOverlap: function _handleOverlap() {\n\n        var mainPoly = this._poly;\n        var layers = this._layerGroup.getLayers();\n        var changed = false;\n        var resultingGeoJson = this._poly.toGeoJSON();\n\n        layers.filter(function (layer) {\n            return !Object.is(layer, mainPoly);\n        }).map(function (layer) {\n\n            var intersect = void 0;\n\n            // this needs to be in a try catch block because turf isn't reliable\n            // it throws self-intersection errors even if there are none\n            try {\n                intersect = turf.intersect(resultingGeoJson, layer.toGeoJSON());\n            } catch (e) {\n                console.warn('Turf Error.');\n            }\n\n            if (intersect) {\n                resultingGeoJson = turf.difference(resultingGeoJson, layer.toGeoJSON());\n\n                // if the resulting polygon is a MultiPolygon, don't handle it.\n                if (resultingGeoJson.geometry.type !== 'MultiPolygon') {\n                    changed = true;\n                }\n            }\n        });\n\n        if (this._tempPolygon) {\n            this._tempPolygon.remove();\n            delete this._tempPolygon;\n        }\n\n        if (changed) {\n            this._drawTemporaryPolygon(resultingGeoJson);\n        } else {\n            this._poly.setStyle({ opacity: 1, fillOpacity: 0.2 });\n        }\n    },\n\n    _onMarkerDrag: function _onMarkerDrag(e) {\n\n        // dragged marker\n        var marker = e.target;\n\n        // the dragged markers neighbors\n        var nextMarkerIndex = marker._index + 1 >= this._markers.length ? 0 : marker._index + 1;\n        var prevMarkerIndex = marker._index - 1 < 0 ? this._markers.length - 1 : marker._index - 1;\n\n        // update marker coordinates which will update polygon coordinates\n        L.extend(marker._origLatLng, marker._latlng);\n        this._poly.redraw();\n\n        // update middle markers on the left and right\n        // be aware that \"next\" and \"prev\" might be interchanged, depending on the geojson array\n        var markerLatLng = marker.getLatLng();\n        var prevMarkerLatLng = this._markers[prevMarkerIndex].getLatLng();\n        var nextMarkerLatLng = this._markers[nextMarkerIndex].getLatLng();\n\n        var middleMarkerNextLatLng = this._calcMiddleLatLng(markerLatLng, nextMarkerLatLng);\n        marker._middleMarkerNext.setLatLng(middleMarkerNextLatLng);\n\n        var middleMarkerPrevLatLng = this._calcMiddleLatLng(markerLatLng, prevMarkerLatLng);\n        marker._middleMarkerPrev.setLatLng(middleMarkerPrevLatLng);\n\n        // if the dragged polygon should be cutted when overlapping another polygon, go ahead\n        if (this.options.preventOverlap) {\n            this._handleOverlap();\n        }\n    },\n\n    _onMarkerDragEnd: function _onMarkerDragEnd(e) {\n\n        this._applyPossibleCoordsChanges();\n\n        // fire edit event\n        this._fireEdit();\n    },\n\n    _fireEdit: function _fireEdit() {\n        // fire edit event\n        this._poly.edited = true;\n        this._poly.fire('pm:edit');\n    },\n\n    _calcMiddleLatLng: function _calcMiddleLatLng(latlng1, latlng2) {\n        // calculate the middle coordinates between two markers\n        // TODO: put this into a utils.js or something\n\n        var map = this._poly._map,\n            p1 = map.project(latlng1),\n            p2 = map.project(latlng2);\n\n        var latlng = map.unproject(p1._add(p2)._divideBy(2));\n\n        return latlng;\n    }\n\n});\n'use strict';\n\nL.PM.Draw.Poly = L.PM.Draw.extend({\n\n    initialize: function initialize(map) {\n        this._map = map;\n        this._shape = 'Poly';\n    },\n    enable: function enable(options) {\n        // enable draw mode\n\n        this._enabled = true;\n\n        // create a new layergroup\n        this._layerGroup = new L.LayerGroup();\n        this._layerGroup.addTo(this._map);\n\n        // this is the polyLine that'll make up the polygon\n        this._polyline = L.polyline([], { color: 'red' });\n        this._layerGroup.addLayer(this._polyline);\n\n        // this is the hintline from the mouse cursor to the last marker\n        this._hintline = L.polyline([], {\n            color: 'red',\n            dashArray: [5, 5]\n        });\n        this._layerGroup.addLayer(this._hintline);\n\n        // change map cursor\n        this._map._container.style.cursor = 'crosshair';\n\n        // create a polygon-point on click\n        this._map.on('click', this._createPolygonPoint, this);\n\n        // sync the hintline on mousemove\n        this._map.on('mousemove', this._syncHintLine, this);\n\n        // fire drawstart event\n        this._map.fire('pm:drawstart', { shape: this._shape });\n    },\n    disable: function disable() {\n        // disable draw mode\n\n        // cancel, if drawing mode isn't even enabled\n        if (!this._enabled) {\n            return;\n        }\n\n        this._enabled = false;\n\n        // reset cursor\n        this._map._container.style.cursor = 'default';\n\n        // unbind listeners\n        this._map.off('click', this._createPolygonPoint);\n        this._map.off('mousemove', this._syncHintLine);\n\n        // remove layer\n        this._map.removeLayer(this._layerGroup);\n\n        // fire drawend event\n        this._map.fire('pm:drawend', { shape: this._shape });\n    },\n    enabled: function enabled() {\n        return this._enabled;\n    },\n    toggle: function toggle(options) {\n\n        if (this.enabled()) {\n            this.disable();\n        } else {\n            this.enable(options);\n        }\n    },\n    addButton: function addButton(map) {\n\n        var self = this;\n\n        var drawPolyButton = {\n            'className': 'icon-polygon',\n            'onClick': function onClick() {},\n            'afterClick': function afterClick(e) {\n                self.toggle();\n            },\n            'doToggle': true,\n            'toggleStatus': false\n        };\n\n        this._drawButton = new L.Control.PMButton(drawPolyButton).addTo(this._map);\n\n        this._map.on('pm:drawstart', function (e) {\n            if (e.shape === self._shape && !self._drawButton.toggled()) {\n                self._drawButton._clicked();\n            }\n        });\n\n        this._map.on('pm:drawend', function (e) {\n            if (e.shape === self._shape && self._drawButton.toggled()) {\n                self._drawButton._clicked();\n            }\n        });\n\n        return this._drawButton;\n    },\n    _syncHintLine: function _syncHintLine(e) {\n\n        var polyPoints = this._polyline.getLatLngs();\n\n        if (polyPoints.length > 0) {\n            var lastPolygonPoint = polyPoints[polyPoints.length - 1];\n            this._hintline.setLatLngs([lastPolygonPoint, e.latlng]);\n        }\n    },\n    _createPolygonPoint: function _createPolygonPoint(e) {\n\n        // is this the first point?\n        var first = this._polyline.getLatLngs().length === 0 ? true : false;\n\n        this._polyline.addLatLng(e.latlng);\n        this._createMarker(e.latlng, first);\n\n        this._hintline.setLatLngs([e.latlng, e.latlng]);\n    },\n    _finishPolygon: function _finishPolygon() {\n\n        var coords = this._polyline.getLatLngs();\n        var polygonLayer = L.polygon(coords).addTo(this._map);\n\n        polygonLayer.pm.toggleEdit();\n\n        this.disable();\n\n        this._map.fire('pm:create', {\n            shape: this._shape,\n            layer: polygonLayer\n        });\n    },\n    _createMarker: function _createMarker(latlng, first) {\n\n        var marker = new L.Marker(latlng, {\n            draggable: false,\n            icon: L.divIcon({ className: 'marker-icon' })\n        });\n\n        this._layerGroup.addLayer(marker);\n\n        if (first) {\n            marker.on('click', this._finishPolygon, this);\n        }\n\n        return marker;\n    }\n});","/**\n*\n* A Leaflet Plugin For Editing Geometry Layers in Leaflet 1.0\n* by Sumit Kumar (@TweetsOfSumit)\n* Github Repo: https://github.com/codeofsumit/leaflet.pm\n*/\n\nL.PM = L.PM || {\n    initialize: function() {\n\n        var initLayerGroup = function() {\n            this.pm = new L.PM.Edit.LayerGroup(this);\n        };\n        L.LayerGroup.addInitHook(initLayerGroup);\n\n\n        var initPolygon = function() {\n            this.pm = new L.PM.Edit.Poly(this);\n        };\n        L.Polygon.addInitHook(initPolygon);\n\n\n        var initMap = function() {\n            this.pm = new L.PM.Draw(this);\n        };\n        L.Map.addInitHook(initMap);\n\n    }\n};\n\n// initialize leaflet.pm\nL.PM.initialize();\n","L.PM.Draw = L.Class.extend({\n\n    initialize: function(map) {\n\n        // save the map\n        this._map = map;\n\n        // define all possible shapes that can be drawn\n        this.shapes = ['Poly'];\n\n        // initiate drawing class for our shapes\n        this.shapes.forEach((shape) => {\n            this[shape] = new L.PM.Draw[shape](this._map);\n        });\n\n    },\n    getShapes: function() {\n        // if somebody wants to know what shapes are available\n        return this.shapes;\n    },\n    enableDraw: function(shape) {\n\n        if(!shape) {\n            throw 'Error: Please pass a shape as a parameter. Possible shapes are: ' + this.getShapes().join(',');\n        }\n\n        // disable drawing for all shapes\n        this.disableDraw();\n\n        // enable draw for a shape\n        this[shape].enable();\n\n    },\n    disableDraw: function() {\n\n        // there can only be one drawing mode active at a time on a map\n        // so it doesn't matter which one should be disabled.\n        // just disable all of them\n        this.shapes.forEach((shape) => {\n            this[shape].disable();\n        });\n\n    },\n    addControls: function() {\n        // add control buttons for our shapes\n        this.shapes.forEach((shape) => {\n            this[shape].addButton();\n        });\n    }\n});\n","L.PM.Edit = L.Class.extend({\n\n});\n","L.Control.PMButton = L.Control.extend({\n    options: {\n        position: 'topleft'\n    },\n    initialize: function (options) {\n        this._button = {};\n        this.setButton(options);\n    },\n\n    onAdd: function (map) {\n\n        this._map = map;\n        var container = L.DomUtil.create('div', 'leaflet-control-button');\n\n        this._container = container;\n\n        this._makeButton(this._button);\n        return this._container;\n    },\n\n    onRemove: function (map) {\n    },\n\n    setButton: function (options) {\n        var button = {\n            'className': options.className,\n            'iconUrl': options.iconUrl,\n            'onClick': options.onClick,\n            'afterClick': options.afterClick,\n            'doToggle': options.doToggle,\n            'toggleStatus': options.toggleStatus\n        };\n\n        this._button = button;\n    },\n\n    getText: function () {\n        return this._button.text;\n    },\n\n    getIconUrl: function () {\n        return this._button.iconUrl;\n    },\n\n    destroy: function () {\n        this._button = {};\n        this._update();\n    },\n\n    toggle: function (e) {\n        if(typeof e === 'boolean'){\n            this._button.toggleStatus = e;\n        }\n        else{\n            this._button.toggleStatus = !this._button.toggleStatus;\n        }\n    },\n    toggled: function () {\n        return this._button.toggleStatus;\n    },\n    onCreate: function() {\n        this.toggle(false);\n    },\n    _makeButton: function(button) {\n\n        var newButton = L.DomUtil.create('div', 'leaflet-buttons-control-button', this._container);\n        if(button.toggleStatus)\n            L.DomUtil.addClass(newButton,'active');\n\n        var image = L.DomUtil.create('img', 'control-icon', newButton);\n        if (button.iconUrl) {\n            image.setAttribute('src', button.iconUrl);\n        }\n        if (button.className) {\n            L.DomUtil.addClass(image, button.className);\n        }\n\n        L.DomEvent\n            .addListener(newButton, 'click', button.onClick, this)\n            .addListener(newButton, 'click', this._clicked, this)\n            .addListener(newButton, 'click', button.afterClick, this);\n\n        L.DomEvent.disableClickPropagation(newButton);\n        return newButton;\n\n    },\n\n    _clicked: function () {\n\n        if(this._button.doToggle){\n\n            if(this._button.toggleStatus) {\n                L.DomUtil.removeClass(this._container.childNodes[0],'active');\n            }\n            else {\n                L.DomUtil.addClass(this._container.childNodes[0],'active');\n            }\n            this.toggle();\n        }\n        return;\n    }\n\n});\n","// LayerGroup doesn't inherit from L.PM.Edit because it's just calling L.PM.Edit.Poly\n// (which inherits from L.PM.Edit) for each layer,\n// so it's not really a parent class\nL.PM.Edit.LayerGroup = L.Class.extend({\n    initialize: function(layerGroup) {\n\n        this._layerGroup = layerGroup;\n        this._layers = layerGroup.getLayers();\n\n        let availableEvents = ['pm:edit', 'pm:dragstart', 'pm:drag', 'pm:dragend'];\n\n        this._layers.forEach((layer) => {\n\n            // listen to the events of the layers in this group\n            availableEvents.forEach((event) => {\n                layer.on(event, this._fireEvent, this);\n            });\n\n            // add reference for the group to each layer inside said group\n            layer.pm._layerGroup = this._layerGroup;\n        });\n\n\n        // if a new layer is added to the group, reinitialize\n        // This only works for FeatureGroups, not LayerGroups\n        // https://github.com/Leaflet/Leaflet/issues/4861\n        this._layerGroup.on('layeradd', (e) => {\n\n            this.initialize(layerGroup);\n\n            // if editing was already enabled for this group, enable it again\n            // so the new layers are enabled\n            if(e.target.pm.enabled()) {\n                this.enable(this.getOptions());\n            }\n        });\n    },\n    _fireEvent: function(e) {\n        this._layerGroup.fireEvent(e.type, e);\n    },\n    toggleEdit: function(options) {\n        this._options = options;\n        this._layers.forEach(layer => {\n            layer.pm.toggleEdit(options);\n        });\n    },\n    enable: function(options) {\n        this._options = options;\n        this._layers.forEach(layer => {\n            layer.pm.enable(options);\n        });\n    },\n    disable: function() {\n        this._layers.forEach(layer => {\n            layer.pm.disable();\n        });\n    },\n    enabled: function() {\n        let enabled = this._layers.find((layer) => layer.pm.enabled());\n        return !!enabled;\n    },\n    dragging: function() {\n        let dragging = this._layers.find((layer) => layer.pm.dragging());\n        return !!dragging;\n    },\n    getOptions: function() {\n        return this._options;\n    }\n});\n","L.PM.Edit.Poly = L.PM.Edit.extend({\n\n    initialize: function(poly) {\n        this._poly = poly;\n        this._enabled = false;\n    },\n\n    toggleEdit: function(options) {\n        if(!this.enabled()) {\n            this.enable(options);\n        } else {\n            this.disable();\n        }\n    },\n\n    enable: function(options = {}) {\n\n        this.options = options;\n\n        if(!this.enabled()) {\n            // change state\n            this._enabled = true;\n\n            // init markers\n            this._initMarkers();\n\n            // if polygon gets removed from map, disable edit mode\n            this._poly.on('remove', (e) => {\n                this.disable(e.target);\n            });\n\n            // preventOverlap needs the turf library. If it's not included, deactivate it again\n            if(window.turf === undefined && this.options.preventOverlap) {\n                console.warn('TurfJS not found, preventOverlap is deactivated');\n                this.options.preventOverlap = false;\n            }\n\n            if(this.options.draggable) {\n                this._initDraggableLayer();\n            }\n        }\n\n    },\n\n    enabled: function() {\n        return this._enabled;\n    },\n\n    disable: function(poly = this._poly) {\n\n        // prevent disabling if polygon is being dragged\n        if(poly.pm._dragging) {\n            return false;\n        }\n        poly.pm._enabled = false;\n        poly.pm._markerGroup.clearLayers();\n\n        // clean up draggable\n        poly.off('mousedown');\n        poly.off('mouseup');\n\n        // remove draggable class\n        var el = poly._path;\n        L.DomUtil.removeClass(el, 'leaflet-pm-draggable');\n    },\n\n    dragging: function() {\n        return this._dragging;\n    },\n\n    _initDraggableLayer: function() {\n\n        // temporary coord variable for delta calculation\n        this._tempDragCoord;\n\n        // add CSS class\n        var el = this._poly._path;\n        L.DomUtil.addClass(el, 'leaflet-pm-draggable');\n\n\n        var onMouseUp = (e) => {\n\n            // re-enable map drag\n            this._poly._map.dragging.enable();\n\n            // clear up mousemove event\n            this._poly._map.off('mousemove');\n\n            // clear up mouseup event\n            this._poly.off('mouseup');\n\n            // show markers again\n            this._initMarkers();\n\n            // set new coordinates, more details inside the function\n            this._applyPossibleCoordsChanges();\n\n            // timeout to prevent click event after drag :-/\n            // TODO: do it better as soon as leaflet has a way to do it better :-)\n            window.setTimeout(() => {\n                // set state\n                this._dragging = false;\n                L.DomUtil.removeClass(el, 'leaflet-pm-dragging');\n\n                // fire pm:dragend event\n                this._poly.fire('pm:dragend');\n\n                // fire edit\n                this._fireEdit();\n            }, 10);\n\n        }\n\n\n        var onMouseMove = (e) => {\n\n            if(!this._dragging) {\n\n                // set state\n                this._dragging = true;\n                L.DomUtil.addClass(el, 'leaflet-pm-dragging');\n\n                // bring it to front to prevent drag interception\n                this._poly.bringToFront();\n\n                // disbale map drag\n                this._poly._map.dragging.disable();\n\n                // hide markers\n                this._markerGroup.clearLayers();\n\n                // fire pm:dragstart event\n                this._poly.fire('pm:dragstart');\n\n\n            }\n\n            this._onLayerDrag(e);\n\n        }\n\n        this._poly.on('mousedown', (e) => {\n\n            // save for delta calculation\n            this._tempDragCoord = e.latlng;\n\n            this._poly.on('mouseup', onMouseUp);\n\n            // listen to mousemove on map (instead of polygon),\n            // otherwise fast mouse movements stop the drag\n            this._poly._map.on('mousemove', onMouseMove);\n\n        });\n\n\n\n    },\n\n    _onLayerDrag: function(e) {\n\n        // latLng of mouse event\n        let latlng = e.latlng;\n\n        // delta coords (how far was dragged)\n        let deltaLatLng = {\n            lat: latlng.lat - this._tempDragCoord.lat,\n            lng: latlng.lng - this._tempDragCoord.lng\n        };\n\n        // create the new coordinates array\n        let coords = this._poly._latlngs[0];\n        let newLatLngs = coords.map((currentLatLng) => {\n            return {\n                lat: currentLatLng.lat + deltaLatLng.lat,\n                lng: currentLatLng.lng + deltaLatLng.lng\n            }\n        });\n\n        // set new coordinates and redraw\n        this._poly.setLatLngs(newLatLngs).redraw();\n\n        // save current latlng for next delta calculation\n        this._tempDragCoord = latlng;\n\n        // if the dragged polygon should be cutted when overlapping another polygon, go ahead\n        if(this.options.preventOverlap) {\n            this._handleOverlap();\n        }\n\n        // fire pm:dragstart event\n        this._poly.fire('pm:drag');\n\n    },\n\n    _initMarkers: function() {\n        let map = this._poly._map;\n\n        // cleanup old ones first\n        if(this._markerGroup) {\n            this._markerGroup.clearLayers();\n        }\n\n        // add markerGroup to map, markerGroup includes regular and middle markers\n        this._markerGroup = new L.LayerGroup();\n        map.addLayer(this._markerGroup);\n\n        // create marker for each coordinate\n        let coords = this._poly._latlngs[0];\n\n        // the marker array, it includes only the markers that're associated with the coordinates\n        this._markers = coords.map(this._createMarker, this);\n\n        // create small markers in the middle of the regular markers\n        for(var k = 0; k < coords.length; k++) {\n\n            var nextIndex = k+1 >= coords.length ? 0 : k+1;\n            this._createMiddleMarker(\n                this._markers[k], this._markers[nextIndex]\n            );\n        }\n\n    },\n\n    // creates initial markers for coordinates\n    _createMarker: function(latlng, index) {\n\n        let marker = new L.Marker(latlng, {\n            draggable: true,\n            icon: L.divIcon({className: 'marker-icon'})\n        });\n\n        marker._origLatLng = latlng;\n        marker._index = index;\n\n        marker.on('drag', this._onMarkerDrag, this);\n        marker.on('dragend', this._onMarkerDragEnd, this);\n        marker.on('contextmenu', this._removeMarker, this);\n\n        this._markerGroup.addLayer(marker);\n\n        return marker;\n\n    },\n\n    // creates the middle markes between coordinates\n    _createMiddleMarker: function(leftM, rightM) {\n\n        let latlng = this._calcMiddleLatLng(leftM.getLatLng(), rightM.getLatLng());\n\n        let middleMarker = this._createMarker(latlng);\n        let icon = L.divIcon({className: 'marker-icon marker-icon-middle'})\n        middleMarker.setIcon(icon);\n\n        // save reference to this middle markers on the neighboor regular markers\n        leftM._middleMarkerNext = middleMarker;\n        rightM._middleMarkerPrev = middleMarker;\n\n        middleMarker.on('click', () => {\n\n            // TODO: move the next two lines inside _addMarker() as soon as\n            // https://github.com/Leaflet/Leaflet/issues/4484\n            // is fixed\n            var icon = L.divIcon({className: 'marker-icon'});\n            middleMarker.setIcon(icon);\n\n            this._addMarker(middleMarker, leftM, rightM);\n        });\n        middleMarker.on('movestart', () => {\n\n            // TODO: This is a workaround. Remove the moveend listener and callback as soon as this is fixed:\n            // https://github.com/Leaflet/Leaflet/issues/4484\n            middleMarker.on('moveend', function() {\n                var icon = L.divIcon({className: 'marker-icon'});\n                middleMarker.setIcon(icon);\n\n                middleMarker.off('moveend');\n            });\n\n            this._addMarker(middleMarker, leftM, rightM);\n        });\n\n\n    },\n\n    // adds a new marker from a middlemarker\n    _addMarker: function(newM, leftM, rightM) {\n\n        // first, make this middlemarker a regular marker\n        newM.off('movestart');\n        newM.off('click');\n\n        // now, create the polygon coordinate point for that marker\n        let latlng = newM.getLatLng();\n        let coords = this._poly._latlngs[0];\n        let index = leftM._index + 1;\n\n        coords.splice(index, 0, latlng);\n\n        // associate polygon coordinate with marker coordinate\n        newM._origLatLng = coords[index];\n\n        // push into marker array & update the indexes for every marker\n        this._markers.splice(index, 0, newM);\n        this._markers.map((marker, i) => marker._index = i);\n\n        // create the new middlemarkers\n        this._createMiddleMarker(leftM, newM);\n        this._createMiddleMarker(newM, rightM);\n\n        // fire edit event\n        this._fireEdit();\n\n\n    },\n\n    _removeMarker: function(e) {\n        let marker = e.target;\n\n        // only continue if this is NOT a middle marker (those can't be deleted)\n        if(marker._index === undefined) {\n            return;\n        }\n\n        // remove polygon coordinate from this marker\n        let coords = this._poly._latlngs[0];\n        let index = marker._index;\n\n        coords.splice(index, 1);\n        this._poly.redraw();\n\n        // remove the marker and the middlemarkers next to it from the map\n        this._markerGroup.removeLayer(marker._middleMarkerPrev);\n        this._markerGroup.removeLayer(marker._middleMarkerNext);\n        this._markerGroup.removeLayer(marker);\n\n\n        // create the new middlemarker\n        let leftMarkerIndex = index - 1 < 0 ? this._markers.length - 1 : index - 1;\n        let rightMarkerIndex = index + 1 >= this._markers.length ? 0 : index + 1;\n\n        let leftM = this._markers[leftMarkerIndex];\n        let rightM = this._markers[rightMarkerIndex];\n        this._createMiddleMarker(leftM, rightM);\n\n\n        // remove the marker from the markers array & update indexes\n        this._markers.splice(index, 1);\n        this._markers.map((marker, i) => marker._index = i);\n\n        // if the polygon should be cutted when overlapping another polygon, do it now\n        if(this.options.preventOverlap) {\n            this._handleOverlap();\n            this._applyPossibleCoordsChanges();\n        }\n\n        // fire edit event\n        this._fireEdit();\n\n\n    },\n\n    _applyPossibleCoordsChanges: function() {\n\n        // after the polygon was dragged and changed it's shape because of unallowed intersecting\n        // with another polygon, this function takes the temporarily drawn polygon (during drag) and applies\n        // it's coordinates to our main polygon\n\n        if(this._tempPolygon) {\n\n            // get the new coordinates\n            var latlngs = this._tempPolygon.getLayers()[0].getLatLngs();\n\n            // reshape our main polygon\n            this._poly.setLatLngs(latlngs).redraw();\n\n            // initialize the markers again\n            this._initMarkers();\n        }\n\n    },\n\n    _drawTemporaryPolygon: function(geoJson) {\n\n        // hide our polygon\n        this._poly.setStyle({opacity: 0, fillOpacity: 0});\n\n        // draw a temporary polygon (happens during drag)\n        this._tempPolygon = L.geoJson(geoJson).addTo(this._poly._map).bringToBack();\n\n    },\n    _handleOverlap: function() {\n\n        let mainPoly = this._poly;\n        let layers = this._layerGroup.getLayers();\n        let changed = false;\n        let resultingGeoJson = this._poly.toGeoJSON();\n\n        layers\n        .filter(layer => !Object.is(layer, mainPoly))\n        .map((layer) => {\n\n            let intersect;\n\n            // this needs to be in a try catch block because turf isn't reliable\n            // it throws self-intersection errors even if there are none\n            try {\n                intersect = turf.intersect(resultingGeoJson, layer.toGeoJSON());\n            } catch(e) {\n                console.warn('Turf Error.');\n            }\n\n            if(intersect) {\n                resultingGeoJson = turf.difference(resultingGeoJson, layer.toGeoJSON());\n\n                // if the resulting polygon is a MultiPolygon, don't handle it.\n                if(resultingGeoJson.geometry.type !== 'MultiPolygon') {\n                    changed = true;\n                }\n            }\n\n        });\n\n        if(this._tempPolygon) {\n            this._tempPolygon.remove();\n            delete this._tempPolygon;\n        }\n\n        if(changed) {\n            this._drawTemporaryPolygon(resultingGeoJson);\n        } else {\n            this._poly.setStyle({opacity: 1, fillOpacity: 0.2});\n        }\n\n\n\n    },\n\n    _onMarkerDrag: function(e) {\n\n        // dragged marker\n        let marker = e.target;\n\n        // the dragged markers neighbors\n        let nextMarkerIndex = marker._index + 1 >= this._markers.length ? 0 : marker._index + 1;\n        let prevMarkerIndex = marker._index - 1 < 0 ? this._markers.length - 1 : marker._index - 1;\n\n        // update marker coordinates which will update polygon coordinates\n        L.extend(marker._origLatLng, marker._latlng);\n        this._poly.redraw();\n\n        // update middle markers on the left and right\n        // be aware that \"next\" and \"prev\" might be interchanged, depending on the geojson array\n        let markerLatLng = marker.getLatLng();\n        let prevMarkerLatLng = this._markers[prevMarkerIndex].getLatLng();\n        let nextMarkerLatLng = this._markers[nextMarkerIndex].getLatLng();\n\n        let middleMarkerNextLatLng = this._calcMiddleLatLng(markerLatLng, nextMarkerLatLng);\n        marker._middleMarkerNext.setLatLng(middleMarkerNextLatLng);\n\n        let middleMarkerPrevLatLng = this._calcMiddleLatLng(markerLatLng, prevMarkerLatLng);\n        marker._middleMarkerPrev.setLatLng(middleMarkerPrevLatLng);\n\n\n        // if the dragged polygon should be cutted when overlapping another polygon, go ahead\n        if(this.options.preventOverlap) {\n            this._handleOverlap();\n        }\n\n    },\n\n    _onMarkerDragEnd: function(e) {\n\n        this._applyPossibleCoordsChanges();\n\n        // fire edit event\n        this._fireEdit();\n\n    },\n\n    _fireEdit: function () {\n        // fire edit event\n        this._poly.edited = true;\n        this._poly.fire('pm:edit');\n    },\n\n    _calcMiddleLatLng: function(latlng1, latlng2) {\n        // calculate the middle coordinates between two markers\n        // TODO: put this into a utils.js or something\n\n        var map = this._poly._map,\n            p1 = map.project(latlng1),\n            p2 = map.project(latlng2);\n\n        var latlng = map.unproject(p1._add(p2)._divideBy(2));\n\n        return latlng;\n    }\n\n});\n","L.PM.Draw.Poly = L.PM.Draw.extend({\n\n    initialize: function(map) {\n        this._map = map;\n        this._shape = 'Poly';\n    },\n    enable: function(options) {\n        // enable draw mode\n\n        this._enabled = true;\n\n        // create a new layergroup\n        this._layerGroup = new L.LayerGroup();\n        this._layerGroup.addTo(this._map);\n\n        // this is the polyLine that'll make up the polygon\n        this._polyline = L.polyline([], {color: 'red'});\n        this._layerGroup.addLayer(this._polyline);\n\n        // this is the hintline from the mouse cursor to the last marker\n        this._hintline = L.polyline([], {\n            color: 'red',\n            dashArray: [5, 5]\n        });\n        this._layerGroup.addLayer(this._hintline);\n\n\n        // change map cursor\n        this._map._container.style.cursor = 'crosshair';\n\n        // create a polygon-point on click\n        this._map.on('click', this._createPolygonPoint, this);\n\n        // sync the hintline on mousemove\n        this._map.on('mousemove', this._syncHintLine, this);\n\n        // fire drawstart event\n        this._map.fire('pm:drawstart', {shape: this._shape});\n\n    },\n    disable: function() {\n        // disable draw mode\n\n        // cancel, if drawing mode isn't even enabled\n        if(!this._enabled) {\n            return;\n        }\n\n        this._enabled = false;\n\n        // reset cursor\n        this._map._container.style.cursor = 'default';\n\n        // unbind listeners\n        this._map.off('click', this._createPolygonPoint);\n        this._map.off('mousemove', this._syncHintLine);\n\n        // remove layer\n        this._map.removeLayer(this._layerGroup);\n\n        // fire drawend event\n        this._map.fire('pm:drawend', {shape: this._shape});\n\n    },\n    enabled: function() {\n        return this._enabled;\n    },\n    toggle: function(options) {\n\n        if(this.enabled()) {\n            this.disable();\n        } else {\n            this.enable(options);\n        }\n\n    },\n    addButton: function(map) {\n\n        var self = this;\n\n        var drawPolyButton = {\n              'className': 'icon-polygon',\n              'onClick': function() {\n\n              },\n              'afterClick': function(e) {\n                  self.toggle();\n              },\n              'doToggle': true,\n              'toggleStatus': false\n        };\n\n        this._drawButton = new L.Control.PMButton(drawPolyButton).addTo(this._map);\n\n        this._map.on('pm:drawstart', function(e) {\n            if(e.shape === self._shape && !self._drawButton.toggled()) {\n                self._drawButton._clicked();\n            }\n        });\n\n        this._map.on('pm:drawend', function(e) {\n            if(e.shape === self._shape && self._drawButton.toggled()) {\n                self._drawButton._clicked();\n            }\n        });\n\n        return this._drawButton;\n\n    },\n    _syncHintLine: function(e) {\n\n        var polyPoints = this._polyline.getLatLngs();\n\n        if(polyPoints.length > 0) {\n            var lastPolygonPoint = polyPoints[polyPoints.length - 1];\n            this._hintline.setLatLngs([lastPolygonPoint, e.latlng]);\n        }\n\n\n\n    },\n    _createPolygonPoint: function(e) {\n\n        // is this the first point?\n        var first = this._polyline.getLatLngs().length === 0 ? true : false;\n\n        this._polyline.addLatLng(e.latlng);\n        this._createMarker(e.latlng, first);\n\n\n        this._hintline.setLatLngs([e.latlng, e.latlng]);\n\n    },\n    _finishPolygon: function() {\n\n        var coords = this._polyline.getLatLngs();\n        var polygonLayer = L.polygon(coords).addTo(this._map);\n\n        polygonLayer.pm.toggleEdit();\n\n        this.disable();\n\n        this._map.fire('pm:create', {\n            shape: this._shape,\n            layer: polygonLayer\n        });\n    },\n    _createMarker: function(latlng, first) {\n\n        var marker = new L.Marker(latlng, {\n            draggable: false,\n            icon: L.divIcon({className: 'marker-icon'})\n        });\n\n        this._layerGroup.addLayer(marker);\n\n        if(first) {\n            marker.on('click', this._finishPolygon, this);\n        }\n\n        return marker;\n\n    },\n});\n"],"sourceRoot":"/source/"}