{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/json-stable-stringify/index.js","node_modules/jsonify/index.js","node_modules/jsonify/lib/parse.js","node_modules/jsonify/lib/stringify.js","node_modules/vega-util/build/vega-util.js","package.json","src/aggregate.ts","src/axis.ts","src/bin.ts","src/channel.ts","src/compile/axis/encode.ts","src/compile/axis/parse.ts","src/compile/axis/rules.ts","src/compile/common.ts","src/compile/compile.ts","src/compile/config.ts","src/compile/data/bin.ts","src/compile/data/data.ts","src/compile/data/filter.ts","src/compile/data/formatparse.ts","src/compile/data/formula.ts","src/compile/data/nonpositivefilter.ts","src/compile/data/nullfilter.ts","src/compile/data/pathorder.ts","src/compile/data/source.ts","src/compile/data/stack.ts","src/compile/data/summary.ts","src/compile/data/timeunit.ts","src/compile/facet.ts","src/compile/layer.ts","src/compile/layout.ts","src/compile/legend/encode.ts","src/compile/legend/parse.ts","src/compile/legend/rules.ts","src/compile/mark/area.ts","src/compile/mark/bar.ts","src/compile/mark/common.ts","src/compile/mark/line.ts","src/compile/mark/mark.ts","src/compile/mark/point.ts","src/compile/mark/rect.ts","src/compile/mark/rule.ts","src/compile/mark/text.ts","src/compile/mark/tick.ts","src/compile/mark/valueref.ts","src/compile/model.ts","src/compile/scale/domain.ts","src/compile/scale/init.ts","src/compile/scale/parse.ts","src/compile/scale/range.ts","src/compile/scale/rules.ts","src/compile/scale/scale.ts","src/compile/scale/type.ts","src/compile/unit.ts","src/config.ts","src/data.ts","src/datetime.ts","src/encoding.ts","src/fielddef.ts","src/filter.ts","src/legend.ts","src/log.ts","src/mark.ts","src/scale.ts","src/sort.ts","src/spec.ts","src/stack.ts","src/timeunit.ts","src/type.ts","src/util.ts","src/validate.ts","src/vega.schema.ts","src/vl.ts"],"names":["f","exports","module","define","amd","g","window","global","self","this","vl","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","json","JSON","obj","opts","cmp","space","Array","join","cycles","replacer","key","value","node","b","aobj","bobj","seen","stringify","parent","level","indent","colonSeparator","toJSON","undefined","isArray","out","item","push","indexOf","TypeError","keys","objectKeys","sort","keyValue","splice","","x","toString","Object","has","prototype","hasOwnProperty","parse","at","ch","text","escapee","\"","\\","/","error","m","name","message","next","c","charAt","number","string","isFinite","hex","uffff","parseInt","String","fromCharCode","white","word","array","object","source","reviver","result","walk","holder","k","v","quote","escapable","lastIndex","test","replace","meta","charCodeAt","slice","str","partial","mind","gap","rep","apply","\b","\t","\n","\f","\r","factory","vega","accessorName","fn","fname","accessorFields","fields","path_trim","d","$","map","isObject","isString","log","method","input","args","concat","console","accessor","splitAccessPath","p","match","_","field","path","Function","empty","id","identity","zero","one","truthy","falsy","None","Warn","Info","Debug","logger","arguments","warn","info","debug","compare","orders","lt","gt","ord","isFunction","constant","extend","len","extentIndex","NULL","fastmap","size","get","set","delete","clear","clean","forEach","inherits","child","proto","create","constructor","isNumber","merge","array0","array1","output","n0","n1","merged","i0","i1","repeat","reps","pad","padchar","align","Math","ceil","peek","toSet","truncate","ellipsis","max","visitArray","filter","visitor","stringValue","defineProperty","author","version","collaborators","homepage","description","main","types","bin","vl2png","vl2svg","vl2vg","directories","scripts","build","postbuild","build:all","build:images","build:toc","build:test-gallery","data","deploy","deploy:gh","deploy:schema","lint","prestart","start","poststart","schema","presite","site","pretest","posttest","test:examples","test:noschema","codecov","test:debug","watch:build","watch:test","watch","x-compile","x-diff","repository","type","url","license","bugs","devDependencies","@types/chai","@types/d3","@types/json-stable-stringify","@types/mocha","@types/node","ajv","browser-sync","browserify","chai","cheerio","d3","exorcist","mocha","nodemon","nyc","source-map-support","tsify","tslint","typescript","typescript-json-schema","uglify-js","vega-datasets","watchify","yaml-front-matter","dependencies","json-stable-stringify","vega-util","yargs","AggregateOp","VALUES","COUNT","VALID","MISSING","DISTINCT","SUM","MEAN","AVERAGE","VARIANCE","VARIANCEP","STDEV","STDEVP","MEDIAN","Q1","Q3","MODESKEW","MIN","MAX","ARGMIN","ARGMAX","AGGREGATE_OPS","SUM_OPS","SHARED_DOMAIN_OPS","AxisOrient","TOP","RIGHT","LEFT","BOTTOM","defaultAxisConfig","labelMaxLength","defaultFacetAxisConfig","axisWidth","domain","grid","tick","autoMaxBins","channel","channel_1","ROW","COLUMN","SIZE","SHAPE","supportMark","mark","getSupportedMark","X","Y","COLOR","DETAIL","ORDER","OPACITY","point","rule","circle","square","bar","rect","line","area","X2","Y2","TEXT","getSupportedRole","measure","dimension","hasScale","util_1","contains","supportScaleType","scaleType","POSITION_SCALE_TYPE_INDEX","Channel","scale_1","CHANNELS","UNIT_CHANNELS","UNIT_SCALE_CHANNELS","SCALE_CHANNELS","NONSPATIAL_CHANNELS","NONSPATIAL_SCALE_CHANNELS","STACK_GROUP_CHANNELS","without","SCALE_TYPES","model","domainPropsSpec","axis","axisColor","stroke","strokeWidth","gridPropsSpec","gridColor","gridOpacity","strokeOpacity","gridWidth","gridDash","strokeDashOffset","labels","labelsSpec","def","fieldDef","config","type_1","NOMINAL","ORDINAL","signal","TEMPORAL","common_1","timeFormatExpression","timeUnit","format","shortTimeLabels","labelAngle","angle","labelAlign","orient","labelBaseline","baseline","tickLabelColor","fill","tickLabelFont","font","tickLabelFontSize","fontSize","ticks","ticksPropsSpec","tickColor","tickWidth","title","titlePropsSpec","titleColor","titleFont","titleFontSize","titleFontWeight","fontWeight","parseAxisComponent","axisChannels","reduce","vgAxes","parseMainAxis","isVisibleAxis","parseGridAxis","isFalseOrNull","some","AXIS_PARTS","part","hasAxisPart","axisPartFlag","parseAxis","isGridAxis","vgAxis","scale","scaleName","property","getSpecifiedOrDefaultValue","encodeSpec","encode","update","specifiedAxis","rules","gridScale","tickCount","values","zindex","numberFormat","gridShow","hasDiscreteScale","gridChannel","axis_1","INVALID_CHANNEL_FOR_AXIS","count","fieldTitle","fielddef_1","maxLength","titleMaxLength","vals","datetime_1","isDateTime","dt","timestamp","z","buildModel","spec","parentGivenName","spec_1","isSomeFacetSpec","facet_1","FacetModel","isLayerSpec","layer_1","LayerModel","isUnitSpec","unit_1","UnitModel","INVALID_SPEC","applyConfig","propsList","applyMarkConfig","QUANTITATIVE","aggregate","aggregate_1","_format","timeFormat","timeunit_1","formatExpression","sortParams","orderDef","orderChannelDef","binSuffix","order","compile","inputSpec","normalize","assemble","reset","$schema","topLevelBasicProperties","signals","assembleData","assembleLayout","marks","assembleRootGroup","padding","autosize","viewport","background","rootGroup","from","data_1","LAYOUT","width","height","assembleParentGroupProperties","cell","assembleGroup","initMarkConfig","encoding","stacked","markConfig","filled","mark_1","POINT","LINE","RULE","opacity","orientOverridden","initTextConfig","textConfig","encoding_1","channelHasField","TICK","CIRCLE","SQUARE","isAggregate","BAR","AREA","RECT","yIsRange","y","y2","xIsRange","x2","xScaleType","yScaleType","hasDiscreteDomain","isFieldDef","xIsMeasure","isMeasure","yIsMeasure","xDef","yDef","unclearOrientContinuous","unclearOrientDiscreteOrEmpty","numberFormatExpr","expr","binComponent","binTrans","as","transform","extent","extentSignal","maxbins","step","bin_1","hasDiscreteDomainOrHasLegend","legend","startField","datum","endField","hash","parseUnit","parseFacet","childDataComponent","component","parseLayer","children","flatten","parseUnitData","formatParse","formatparse_1","nullFilter","nullfilter_1","filter_1","nonPositiveFilter","nonpositivefilter_1","pathOrder","pathorder_1","source_1","calculate","formula_1","formula","summary","summary_1","stack","stack_1","parseFacetData","parseLayerData","dataComponent","sourceData","dataName","SOURCE","summaryData","nonPositiveFilterTransform","dataTable","stackData","pathOrderCollectTransform","expression","filterComponent","compatibleSource","calcFieldMap","fieldMap","parseComponent","val","isEqualFilter","equal","isRangeFilter","range","isOneOfFilter","oneOf","isCount","isUrlData","parse_1","differ","formulaComponent","channels","nonPositiveComponent","ScaleType","LOG","nonPositiveFilterComponent","filterInvalid","aggregator","DEFAULT_NULL_FILTERS","nominal","ordinal","quantitative","temporal","nullFilterComponent","filters","_filters","sort_1","dimensionChannel","sortField","isSortField","op","pathOrderComponent","stringifiedPathOrder","_i","_a","_b","_c","isInlineData","defaultExtension","exec","dataFormat","formatType","feature","mesh","renameData","childData","canMerge","getStackByFields","stackProperties","stackBy","by","_field","groupby","groupbyChannel","groupbyFieldDef","stackby","STACKED","SUMMARY","fieldChannel","offset","impute","stackComponent","newName","facetedField","orderby","addDimension","dims","meas","dimensions","measures","summaryComponents","summaryComponent","summaryNameWithoutPrefix","substr","mergeMeasures","parentMeasures","childMeasures","field_1","ops","summaries","childSummary","sourceName","fnDictSet","ops_1","timeUnitComponent","fieldExpr","hasSubPlotWithXy","hasDescendantWithFieldOnChannel","spacing","facetSpacing","getFacetGroupProperties","mergedCellConfig","facet","sizeName","assembleAxesGroupData","column","COLUMN_AXES_DATA_PREFIX","row","ROW_AXES_DATA_PREFIX","parseAxisGroups","axisGroup","getSharedAxisGroup","rules_1","isX","facetChannel","hasFacet","dataPrefix","axesGroup","group","axes","getRowGridGroups","facetGridConfig","rowGrid","color","getColumnGridGroups","columnGrid","config_1","layout_1","model_1","init_1","parse_2","_super","_this","_spacing","_config","_initConfig","_child","_facet","_initFacet","_scale","_initScaleAndSpacing","_axis","_initAxis","_legend","__extends","specConfig","mergeDeep","duplicate","defaultConfig","emptyFieldDef","isDimension","facetChannelShouldBeDiscrete","incompatibleChannel","default","axisSpec","modelAxis","yAxis","hasSummary","facetedTable","parseData","parseSelectionData","parseLayoutData","layout","parseFacetLayout","parseScale","scaleComponent","scaleNameWithoutPrefix","renameScale","parseMark","parseAxisGroup","xAxisGroup","yAxisGroup","parseGridGroup","gridGroup","parseLegend","layoutData","assembleMarks","mapping","isFacet","Model","data_2","domain_1","_width","_height","_children","layers","layer","parseLayerLayout","childScales","modelScales","unionDomains","binLegend","binLegendLabel","axisComponent","legendComponent","cellConfig","FILL_STROKE_CONFIG","isLayer","compatible","layoutComponent","distinctFields","distinct","parseUnitLayout","parseUnitSizeLayout","getDistinct","channelSizeName","unitSizeExpr","rangeStep","cardinality","cardinalityExpr","paddingOuter","paddingInner","parseFacetSizeLayout","childLayoutComponent","sizeType","childSizeComponent","facetSizeFormula","innerSize","parseLayerSizeLayout","sizeType_1","distinctField","prefix","symbols","symbolsSpec","shape","cfg","colorDef","isValueDef","symbolColor","symbolShape","symbolSize","hasContinuousDomain","symbolStrokeWidth","scale_2","BIN_LEGEND_LABEL_SUFFIX","labelColor","labelFont","labelFontSize","titleSpec","titles","parseLegendComponent","getLegendDefWithScale","suffix","BIN_LEGEND_SUFFIX","common_2","ref","markType","encodeEntry","stackable","stackable2","applyColorAndOpacity","sizeDef","xScaleName","xScale","binSpacing","BAND","fieldRef","band","xc","midPoint","midX","defaultSizeRef","yScaleName","yScale","yc","midY","discreteBandSize","continuousBandSize","BAR_WITH_POINT_SCALE_AND_RANGESTEP_NULL","FILL_CONFIG","STROKE_CONFIG","colorRef","opacityRef","util","_size","parsePathMark","parseNonPathMark","dataFrom","details","detailFields","pathMarks","markCompiler","FACETED_PATH_PREFIX","applyColorToBackground","text_1","NONSPATIAL_CHANNELS_EXCEPT_ORDER","area_1","bar_1","line_1","point_1","rect_1","rule_1","tick_1","fixedShape","markSpecificConfig","shapeDef","pointConfig","x2Def","scaleTypeNotWorkWithMark","y2Def","xDefault","textDef","textXRangeStep","textRef","scaleRangeStep","defaultSize","bandSize","thickness","channelDef","defaultRef","aFieldDef","a2fieldDef","side","opt","binMidSignal","baseX","baseY","baseOrMaxX","baseOrMaxY","TIME","UTC","NameMap","_nameMap","rename","oldName","_parent","_name","_dataNameMap","_scaleNameMap","_sizeNameMap","_data","_description","_padding","_transform","DEPRECATED_FILTER_NULL","assembleScales","scales","arr","assembleAxes","assembleLegends","legends","init","isUnit","delimiter","dataSourceType","renameSize","originalScaleName","StackOffset","NORMALIZE","useRawDomain","_useRawDomain","domainSort","noAggregate","isBoolean","SortOrder","ASCENDING","DESCENDING","normalizeDomain","vega_schema_1","isDataRefDomain","isFieldRefUnionDomain","isDataRefUnionedDomain","INVAID_DOMAIN","domain1","domain2","normalizedDomain1","normalizedDomain2","domains","unique","allData","topLevelSize","xyRangeSteps","specifiedScale","specifiedValue","supportedByScaleType","scaleTypeSupportProperty","channelIncompatability","channelScalePropertyIncompatability","scalePropertyNotWorkWithScaleType","getDefaultValue","range_1","scaleConfig","nice","round","parseScaleComponent","scaleComponentsIndex","scaleComponents","parseMainScale","parseBinLegend","parseBinLegendLabel","parseDomain","parseRange","reverse","scheme","isExtendedScheme","rangeMixins","specifiedRangeStepIsNull","stepSize","rangeStepDropped","rangeMin","sizeRangeMin","rangeMax","sizeRangeMax","defaultRange","minOpacity","maxOpacity","minBandSize","minStrokeWidth","minFontSize","minSize","maxBandSize","minXYRangeStep","maxStrokeWidth","maxFontSize","maxSize","pointStep","min","smallestUnit","pointPadding","bandPaddingInner","bandPaddingOuter","specifiedType","newScaleType","defaultType","scaleTypeNotWorkWithChannel","channelRangeType","discreteToContinuousType","discreteChannelCannotEncode","LINEAR","invalidFieldType","haveRangeStep","vlEncoding","config_2","mark_2","parse_3","providedWidth","providedHeight","_mark","_encoding","_initEncoding","_stack","_initScale","_initLegend","_initSize","channelDefs","hasFacetParent","topLevelWidth","topLevelHeight","legendSpec","toSpec","excludeConfig","excludeData","legend_1","defaultCellConfig","defaultFacetCellConfig","defaultFacetGridConfig","defaultFacetConfig","AreaOverlay","LINEPOINT","NONE","defaultOverlayConfig","pointStyle","lineStyle","countTitle","defaultMarkConfig","defaultAreaConfig","defaultBarConfig","defaultCircleConfig","defaultLineConfig","defaultPointConfig","defaultRectConfig","defaultRuleConfig","defaultSquareConfig","defaultTextConfig","defaultTickConfig","overlay","defaultScaleConfig","defaultLegendConfig","DataFormatType","CSV","TSV","TOPOJSON","year","quarter","month","date","day","hours","minutes","seconds","milliseconds","normalizeQuarter","q","invalidTimeUnit","normalizeMonth","lowerM","toLowerCase","monthIndex","MONTHS","shortM","shortMonthIndex","SHORT_MONTHS","normalizeDay","lowerD","dayIndex","DAYS","shortD","shortDayIndex","SHORT_DAYS","Date","droppedDay","setFullYear","SUNDAY_YEAR","setDate","setMonth","setHours","setMinutes","setSeconds","setMilliseconds","getTime","dateTimeExpr","units","isRanged","fieldDefs","thisArg","r1","nofn","_isFieldDimension","toUpperCase","canBeMeasure","fullType","getFullName","newType","emptyOrInvalidFieldType","in","valueExpr","lower","upper","isSingleTimeUnit","datetime","runLocalLogger","localLogger","current","LocalLogger","wrap","vega_util_1","warns","infos","debugs","markOrFacet","original","actual","cannotUseRangePropertyWithFacet","propName","cannotStackRangedMark","cannotStackNonLinearScale","cannotStackNonSummativeAggregate","unitName","dayReplacedWithDate","fullTimeUnit","CANNOT_USE_SCHEME_WITH_NON_COLOR","CANNOT_USE_RANGE_WITH_POSITION","CANNOT_USE_PADDING_WITH_FACET","Mark","ERRORBAR","PRIMITIVE_MARKS","defaultSymbolConfig","shapes","DISCRETE_DOMAIN_INDEX","CONTINUOUS_DOMAIN_INDEX","isContinuousToContinuous","CONTINUOUS_TO_CONTINUOUS_INDEX","POW","SQRT","SEQUENTIAL","QUANTILE","QUANTIZE","THRESHOLD","CONTINUOUS_TO_CONTINUOUS_SCALES","CONTINUOUS_DOMAIN_SCALES","DISCRETE_DOMAIN_SCALES","TIME_SCALE_TYPES","NiceTime","SECOND","MINUTE","HOUR","DAY","WEEK","MONTH","YEAR","SCALE_PROPERTIES","isExtendedUnitSpec","isSomeUnitSpec","hasRow","hasColumn","normalizeExtendedUnitSpec","normalizeUnitSpec","overlayConfig","overlayWithLine","overlayWithPoint","normalizeErrorBarUnitSpec","normalizeRangedUnitSpec","normalizeOverlay","hasX","hasY","hasX2","hasY2","normalizedSpec","layerSpec","ruleSpec","lowerTickSpec","upperTickSpec","outerProps","baseSpec","omit","baseConfig","pick","lineSpec","pointSpec","accumulate","dict","pureFieldDef","fieldDefIndex","isStacked","STACKABLE_MARKS","sc","hasXField","hasYField","xIsAggregate","yIsAggregate","fieldChannelAggregate","fieldChannelScale","STACK_BY_DEFAULT_MARKS","ZERO","CENTER","SINGLE_TIMEUNIT_INDEX","convert","unit","SINGLE_TIMEUNITS","singleUnit","containsTimeUnit","TimeUnit","getFullYear","QUARTER","floor","getMonth","DATE","getDate","HOURS","getHours","MINUTES","getMinutes","SECONDS","getSeconds","MILLISECONDS","getMilliseconds","isMultiTimeUnit","MULTI_TIMEUNIT_INDEX","fullTimeUnitStr","timeUnitStr","index","func","_d","tu","dateComponents","hasYear","timeComponents","dateTimeComponents","YEARMONTH","YEARMONTHDATE","YEARMONTHDATEHOURS","YEARMONTHDATEHOURSMINUTES","YEARMONTHDATEHOURSMINUTESSECONDS","MONTHDATE","HOURSMINUTES","HOURSMINUTESSECONDS","MINUTESSECONDS","SECONDSMILLISECONDS","YEARQUARTER","QUARTERMONTH","YEARQUARTERMONTH","MULTI_TIMEUNITS","TIMEUNITS","Type","props","copy","prop","vega_util_2","excludedItems","union","other","every","arrays","dest","src","src_1","deepMerge_","results","values_1","_vals","getEncodingMappingError","requiredChannelMap","supportedChannelMap","DEFAULT_REQUIRED_CHANNEL_MAP","DEFAULT_SUPPORTED_CHANNEL_TYPE","requiredChannels","supportedChannels","compile_1","validate"],"mappings":"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","sourceRoot":"","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var json = typeof JSON !== 'undefined' ? JSON : require('jsonify');\n\nmodule.exports = function (obj, opts) {\n    if (!opts) opts = {};\n    if (typeof opts === 'function') opts = { cmp: opts };\n    var space = opts.space || '';\n    if (typeof space === 'number') space = Array(space+1).join(' ');\n    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;\n    var replacer = opts.replacer || function(key, value) { return value; };\n\n    var cmp = opts.cmp && (function (f) {\n        return function (node) {\n            return function (a, b) {\n                var aobj = { key: a, value: node[a] };\n                var bobj = { key: b, value: node[b] };\n                return f(aobj, bobj);\n            };\n        };\n    })(opts.cmp);\n\n    var seen = [];\n    return (function stringify (parent, key, node, level) {\n        var indent = space ? ('\\n' + new Array(level + 1).join(space)) : '';\n        var colonSeparator = space ? ': ' : ':';\n\n        if (node && node.toJSON && typeof node.toJSON === 'function') {\n            node = node.toJSON();\n        }\n\n        node = replacer.call(parent, key, node);\n\n        if (node === undefined) {\n            return;\n        }\n        if (typeof node !== 'object' || node === null) {\n            return json.stringify(node);\n        }\n        if (isArray(node)) {\n            var out = [];\n            for (var i = 0; i < node.length; i++) {\n                var item = stringify(node, i, node[i], level+1) || json.stringify(null);\n                out.push(indent + space + item);\n            }\n            return '[' + out.join(',') + indent + ']';\n        }\n        else {\n            if (seen.indexOf(node) !== -1) {\n                if (cycles) return json.stringify('__cycle__');\n                throw new TypeError('Converting circular structure to JSON');\n            }\n            else seen.push(node);\n\n            var keys = objectKeys(node).sort(cmp && cmp(node));\n            var out = [];\n            for (var i = 0; i < keys.length; i++) {\n                var key = keys[i];\n                var value = stringify(node, key, node[key], level+1);\n\n                if(!value) continue;\n\n                var keyValue = json.stringify(key)\n                    + colonSeparator\n                    + value;\n                ;\n                out.push(indent + space + keyValue);\n            }\n            seen.splice(seen.indexOf(node), 1);\n            return '{' + out.join(',') + indent + '}';\n        }\n    })({ '': obj }, '', obj, 0);\n};\n\nvar isArray = Array.isArray || function (x) {\n    return {}.toString.call(x) === '[object Array]';\n};\n\nvar objectKeys = Object.keys || function (obj) {\n    var has = Object.prototype.hasOwnProperty || function () { return true };\n    var keys = [];\n    for (var key in obj) {\n        if (has.call(obj, key)) keys.push(key);\n    }\n    return keys;\n};\n","exports.parse = require('./lib/parse');\nexports.stringify = require('./lib/stringify');\n","var at, // The index of the current character\n    ch, // The current character\n    escapee = {\n        '\"':  '\"',\n        '\\\\': '\\\\',\n        '/':  '/',\n        b:    '\\b',\n        f:    '\\f',\n        n:    '\\n',\n        r:    '\\r',\n        t:    '\\t'\n    },\n    text,\n\n    error = function (m) {\n        // Call error when something is wrong.\n        throw {\n            name:    'SyntaxError',\n            message: m,\n            at:      at,\n            text:    text\n        };\n    },\n    \n    next = function (c) {\n        // If a c parameter is provided, verify that it matches the current character.\n        if (c && c !== ch) {\n            error(\"Expected '\" + c + \"' instead of '\" + ch + \"'\");\n        }\n        \n        // Get the next character. When there are no more characters,\n        // return the empty string.\n        \n        ch = text.charAt(at);\n        at += 1;\n        return ch;\n    },\n    \n    number = function () {\n        // Parse a number value.\n        var number,\n            string = '';\n        \n        if (ch === '-') {\n            string = '-';\n            next('-');\n        }\n        while (ch >= '0' && ch <= '9') {\n            string += ch;\n            next();\n        }\n        if (ch === '.') {\n            string += '.';\n            while (next() && ch >= '0' && ch <= '9') {\n                string += ch;\n            }\n        }\n        if (ch === 'e' || ch === 'E') {\n            string += ch;\n            next();\n            if (ch === '-' || ch === '+') {\n                string += ch;\n                next();\n            }\n            while (ch >= '0' && ch <= '9') {\n                string += ch;\n                next();\n            }\n        }\n        number = +string;\n        if (!isFinite(number)) {\n            error(\"Bad number\");\n        } else {\n            return number;\n        }\n    },\n    \n    string = function () {\n        // Parse a string value.\n        var hex,\n            i,\n            string = '',\n            uffff;\n        \n        // When parsing for string values, we must look for \" and \\ characters.\n        if (ch === '\"') {\n            while (next()) {\n                if (ch === '\"') {\n                    next();\n                    return string;\n                } else if (ch === '\\\\') {\n                    next();\n                    if (ch === 'u') {\n                        uffff = 0;\n                        for (i = 0; i < 4; i += 1) {\n                            hex = parseInt(next(), 16);\n                            if (!isFinite(hex)) {\n                                break;\n                            }\n                            uffff = uffff * 16 + hex;\n                        }\n                        string += String.fromCharCode(uffff);\n                    } else if (typeof escapee[ch] === 'string') {\n                        string += escapee[ch];\n                    } else {\n                        break;\n                    }\n                } else {\n                    string += ch;\n                }\n            }\n        }\n        error(\"Bad string\");\n    },\n\n    white = function () {\n\n// Skip whitespace.\n\n        while (ch && ch <= ' ') {\n            next();\n        }\n    },\n\n    word = function () {\n\n// true, false, or null.\n\n        switch (ch) {\n        case 't':\n            next('t');\n            next('r');\n            next('u');\n            next('e');\n            return true;\n        case 'f':\n            next('f');\n            next('a');\n            next('l');\n            next('s');\n            next('e');\n            return false;\n        case 'n':\n            next('n');\n            next('u');\n            next('l');\n            next('l');\n            return null;\n        }\n        error(\"Unexpected '\" + ch + \"'\");\n    },\n\n    value,  // Place holder for the value function.\n\n    array = function () {\n\n// Parse an array value.\n\n        var array = [];\n\n        if (ch === '[') {\n            next('[');\n            white();\n            if (ch === ']') {\n                next(']');\n                return array;   // empty array\n            }\n            while (ch) {\n                array.push(value());\n                white();\n                if (ch === ']') {\n                    next(']');\n                    return array;\n                }\n                next(',');\n                white();\n            }\n        }\n        error(\"Bad array\");\n    },\n\n    object = function () {\n\n// Parse an object value.\n\n        var key,\n            object = {};\n\n        if (ch === '{') {\n            next('{');\n            white();\n            if (ch === '}') {\n                next('}');\n                return object;   // empty object\n            }\n            while (ch) {\n                key = string();\n                white();\n                next(':');\n                if (Object.hasOwnProperty.call(object, key)) {\n                    error('Duplicate key \"' + key + '\"');\n                }\n                object[key] = value();\n                white();\n                if (ch === '}') {\n                    next('}');\n                    return object;\n                }\n                next(',');\n                white();\n            }\n        }\n        error(\"Bad object\");\n    };\n\nvalue = function () {\n\n// Parse a JSON value. It could be an object, an array, a string, a number,\n// or a word.\n\n    white();\n    switch (ch) {\n    case '{':\n        return object();\n    case '[':\n        return array();\n    case '\"':\n        return string();\n    case '-':\n        return number();\n    default:\n        return ch >= '0' && ch <= '9' ? number() : word();\n    }\n};\n\n// Return the json_parse function. It will have access to all of the above\n// functions and variables.\n\nmodule.exports = function (source, reviver) {\n    var result;\n    \n    text = source;\n    at = 0;\n    ch = ' ';\n    result = value();\n    white();\n    if (ch) {\n        error(\"Syntax error\");\n    }\n\n    // If there is a reviver function, we recursively walk the new structure,\n    // passing each name/value pair to the reviver function for possible\n    // transformation, starting with a temporary root object that holds the result\n    // in an empty key. If there is not a reviver function, we simply return the\n    // result.\n\n    return typeof reviver === 'function' ? (function walk(holder, key) {\n        var k, v, value = holder[key];\n        if (value && typeof value === 'object') {\n            for (k in value) {\n                if (Object.prototype.hasOwnProperty.call(value, k)) {\n                    v = walk(value, k);\n                    if (v !== undefined) {\n                        value[k] = v;\n                    } else {\n                        delete value[k];\n                    }\n                }\n            }\n        }\n        return reviver.call(holder, key, value);\n    }({'': result}, '')) : result;\n};\n","var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    gap,\n    indent,\n    meta = {    // table of character substitutions\n        '\\b': '\\\\b',\n        '\\t': '\\\\t',\n        '\\n': '\\\\n',\n        '\\f': '\\\\f',\n        '\\r': '\\\\r',\n        '\"' : '\\\\\"',\n        '\\\\': '\\\\\\\\'\n    },\n    rep;\n\nfunction quote(string) {\n    // If the string contains no control characters, no quote characters, and no\n    // backslash characters, then we can safely slap some quotes around it.\n    // Otherwise we must also replace the offending characters with safe escape\n    // sequences.\n    \n    escapable.lastIndex = 0;\n    return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n        var c = meta[a];\n        return typeof c === 'string' ? c :\n            '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n    }) + '\"' : '\"' + string + '\"';\n}\n\nfunction str(key, holder) {\n    // Produce a string from holder[key].\n    var i,          // The loop counter.\n        k,          // The member key.\n        v,          // The member value.\n        length,\n        mind = gap,\n        partial,\n        value = holder[key];\n    \n    // If the value has a toJSON method, call it to obtain a replacement value.\n    if (value && typeof value === 'object' &&\n            typeof value.toJSON === 'function') {\n        value = value.toJSON(key);\n    }\n    \n    // If we were called with a replacer function, then call the replacer to\n    // obtain a replacement value.\n    if (typeof rep === 'function') {\n        value = rep.call(holder, key, value);\n    }\n    \n    // What happens next depends on the value's type.\n    switch (typeof value) {\n        case 'string':\n            return quote(value);\n        \n        case 'number':\n            // JSON numbers must be finite. Encode non-finite numbers as null.\n            return isFinite(value) ? String(value) : 'null';\n        \n        case 'boolean':\n        case 'null':\n            // If the value is a boolean or null, convert it to a string. Note:\n            // typeof null does not produce 'null'. The case is included here in\n            // the remote chance that this gets fixed someday.\n            return String(value);\n            \n        case 'object':\n            if (!value) return 'null';\n            gap += indent;\n            partial = [];\n            \n            // Array.isArray\n            if (Object.prototype.toString.apply(value) === '[object Array]') {\n                length = value.length;\n                for (i = 0; i < length; i += 1) {\n                    partial[i] = str(i, value) || 'null';\n                }\n                \n                // Join all of the elements together, separated with commas, and\n                // wrap them in brackets.\n                v = partial.length === 0 ? '[]' : gap ?\n                    '[\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + ']' :\n                    '[' + partial.join(',') + ']';\n                gap = mind;\n                return v;\n            }\n            \n            // If the replacer is an array, use it to select the members to be\n            // stringified.\n            if (rep && typeof rep === 'object') {\n                length = rep.length;\n                for (i = 0; i < length; i += 1) {\n                    k = rep[i];\n                    if (typeof k === 'string') {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            }\n            else {\n                // Otherwise, iterate through all of the keys in the object.\n                for (k in value) {\n                    if (Object.prototype.hasOwnProperty.call(value, k)) {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            }\n            \n        // Join all of the member texts together, separated with commas,\n        // and wrap them in braces.\n\n        v = partial.length === 0 ? '{}' : gap ?\n            '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + '}' :\n            '{' + partial.join(',') + '}';\n        gap = mind;\n        return v;\n    }\n}\n\nmodule.exports = function (value, replacer, space) {\n    var i;\n    gap = '';\n    indent = '';\n    \n    // If the space parameter is a number, make an indent string containing that\n    // many spaces.\n    if (typeof space === 'number') {\n        for (i = 0; i < space; i += 1) {\n            indent += ' ';\n        }\n    }\n    // If the space parameter is a string, it will be used as the indent string.\n    else if (typeof space === 'string') {\n        indent = space;\n    }\n\n    // If there is a replacer, it must be a function or an array.\n    // Otherwise, throw an error.\n    rep = replacer;\n    if (replacer && typeof replacer !== 'function'\n    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {\n        throw new Error('JSON.stringify');\n    }\n    \n    // Make a fake root object containing our value under the key of ''.\n    // Return the result of stringifying the value.\n    return str('', {'': value});\n};\n","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.vega = global.vega || {})));\n}(this, (function (exports) { 'use strict';\n\nvar accessor = function(fn, fields, name) {\n  return (\n    fn.fields = fields || [],\n    fn.fname = name,\n    fn\n  );\n}\n\nfunction accessorName(fn) {\n  return fn == null ? null : fn.fname;\n}\n\nfunction accessorFields(fn) {\n  return fn == null ? null : fn.fields;\n}\n\nvar splitAccessPath = function(p) {\n  return String(p)\n    .match(/\\[(.*?)\\]|[^.\\[]+/g)\n    .map(path_trim);\n}\n\nfunction path_trim(d) {\n  return d[0] !== '[' ? d\n    : d[1] !== \"'\" && d[1] !== '\"' ? d.slice(1, -1)\n    : d.slice(2, -2).replace(/\\\\([\"'])/g, '$1');\n}\n\nvar isArray = Array.isArray;\n\nvar isObject = function(_) {\n  return _ === Object(_);\n}\n\nvar isString = function(_) {\n  return typeof _ === 'string';\n}\n\nfunction $(x) {\n  return isArray(x) ? '[' + x.map($) + ']'\n    : isObject(x) || isString(x) ?\n      // Output valid JSON and JS source strings.\n      // See http://timelessrepo.com/json-isnt-a-javascript-subset\n      JSON.stringify(x).replace('\\u2028','\\\\u2028').replace('\\u2029', '\\\\u2029')\n    : x;\n}\n\nvar field = function(field, name) {\n  var path = splitAccessPath(field).map($),\n      fn = Function('_', 'return _[' + path.join('][') + '];');\n  return accessor(fn, [field], name || field);\n}\n\nvar empty = [];\n\nvar id = field('id');\n\nvar identity = accessor(function(_) { return _; }, empty, 'identity');\n\nvar zero = accessor(function() { return 0; }, empty, 'zero');\n\nvar one = accessor(function() { return 1; }, empty, 'one');\n\nvar truthy = accessor(function() { return true; }, empty, 'true');\n\nvar falsy = accessor(function() { return false; }, empty, 'false');\n\nfunction log(method, level, input) {\n  var args = [level].concat([].slice.call(input));\n  console[method].apply(console, args); // eslint-disable-line no-console\n}\n\nvar None  = 0;\nvar Warn  = 1;\nvar Info  = 2;\nvar Debug = 3;\n\nvar logger = function(_) {\n  var level = _ || None;\n  return {\n    level: function(_) {\n      return arguments.length ? (level = +_, this) : level;\n    },\n    warn: function() {\n      if (level >= Warn) log('warn', 'WARN', arguments);\n      return this;\n    },\n    info: function() {\n      if (level >= Info) log('log', 'INFO', arguments);\n      return this;\n    },\n    debug: function() {\n      if (level >= Debug) log('log', 'DEBUG', arguments);\n      return this;\n    }\n  }\n}\n\nvar array = function(_) {\n  return _ != null ? (isArray(_) ? _ : [_]) : [];\n}\n\nvar compare = function(fields, orders) {\n  if (fields == null) return null;\n  fields = array(fields);\n\n  var cmp = fields.map(function(f) {\n        return splitAccessPath(f).map($).join('][');\n      }),\n      ord = array(orders),\n      n = cmp.length - 1,\n      code = 'var u,v;return ', i, f, u, v, d, lt, gt;\n\n  for (i=0; i<=n; ++i) {\n    f = cmp[i];\n    u = '(u=a['+f+'])';\n    v = '(v=b['+f+'])';\n    d = '((v=v instanceof Date?+v:v),(u=u instanceof Date?+u:u))';\n    lt = ord[i] !== 'descending' ? (gt=1, -1) : (gt=-1, 1);\n    code += '(' + u+'<'+v+'||u==null)&&v!=null?' + lt\n      + ':(u>v||v==null)&&u!=null?' + gt\n      + ':'+d+'!==u&&v===v?' + lt\n      + ':v!==v&&u===u?' + gt\n      + (i < n ? ':' : ':0');\n  }\n  return accessor(Function('a', 'b', code + ';'), fields);\n}\n\nvar isFunction = function(_) {\n  return typeof _ === 'function';\n}\n\nvar constant = function(_) {\n  return isFunction(_) ? _ : function() { return _; };\n}\n\nvar error = function(message) {\n  throw Error(message);\n}\n\nvar extend = function(_) {\n  for (var x, k, i=1, len=arguments.length; i<len; ++i) {\n    x = arguments[i];\n    for (k in x) { _[k] = x[k]; }\n  }\n  return _;\n}\n\nvar extentIndex = function(array, f) {\n  var i = -1,\n      n = array.length,\n      a, b, c, u, v;\n\n  if (f == null) {\n    while (++i < n) if ((b = array[i]) != null && b >= b) { a = c = b; break; }\n    u = v = i;\n    while (++i < n) if ((b = array[i]) != null) {\n      if (a > b) a = b, u = i;\n      if (c < b) c = b, v = i;\n    }\n  } else {\n    while (++i < n) if ((b = f(array[i], i, array)) != null && b >= b) { a = c = b; break; }\n    u = v = i;\n    while (++i < n) if ((b = f(array[i], i, array)) != null) {\n      if (a > b) a = b, u = i;\n      if (c < b) c = b, v = i;\n    }\n  }\n\n  return [u, v];\n}\n\nvar NULL = {};\n\nvar fastmap = function(input) {\n  var obj = {},\n      map,\n      test;\n\n  function has(key) {\n    return obj.hasOwnProperty(key) && obj[key] !== NULL;\n  }\n\n  map = {\n    size: 0,\n    empty: 0,\n    object: obj,\n    has: has,\n    get: function(key) {\n      return has(key) ? obj[key] : undefined;\n    },\n    set: function(key, value) {\n      if (!has(key)) {\n        ++map.size;\n        if (obj[key] === NULL) --map.empty;\n      }\n      obj[key] = value;\n      return this;\n    },\n    delete: function(key) {\n      if (has(key)) {\n        --map.size;\n        ++map.empty;\n        obj[key] = NULL;\n      }\n      return this;\n    },\n    clear: function() {\n      map.size = map.empty = 0;\n      map.object = obj = {};\n    },\n    test: function(_) {\n      return arguments.length ? (test = _, map) : test;\n    },\n    clean: function() {\n      var next = {},\n          size = 0,\n          key, value;\n      for (key in obj) {\n        value = obj[key];\n        if (value !== NULL && (!test || !test(value))) {\n          next[key] = value;\n          ++size;\n        }\n      }\n      map.size = size;\n      map.empty = 0;\n      map.object = (obj = next);\n    }\n  };\n\n  if (input) Object.keys(input).forEach(function(key) {\n    map.set(key, input[key]);\n  });\n\n  return map;\n}\n\nvar inherits = function(child, parent) {\n  var proto = (child.prototype = Object.create(parent.prototype));\n  proto.constructor = child;\n  return proto;\n}\n\nvar isNumber = function(_) {\n  return typeof _ === 'number';\n}\n\nvar key = function(fields) {\n  fields = fields ? array(fields) : fields;\n  var fn = !(fields && fields.length)\n    ? function() { return ''; }\n    : Function('_', 'return \\'\\'+' +\n        fields.map(function(f) {\n          return '_[' + splitAccessPath(f).map($).join('][') + ']';\n        }).join('+\\'|\\'+') + ';');\n  return accessor(fn, fields, 'key');\n}\n\nvar merge = function(compare, array0, array1, output) {\n  var n0 = array0.length,\n      n1 = array1.length;\n\n  if (!n1) return array0;\n  if (!n0) return array1;\n\n  var merged = output || new array0.constructor(n0 + n1),\n      i0 = 0, i1 = 0, i = 0;\n\n  for (; i0<n0 && i1<n1; ++i) {\n    merged[i] = compare(array0[i0], array1[i1]) > 0\n       ? array1[i1++]\n       : array0[i0++];\n  }\n\n  for (; i0<n0; ++i0, ++i) {\n    merged[i] = array0[i0];\n  }\n\n  for (; i1<n1; ++i1, ++i) {\n    merged[i] = array1[i1];\n  }\n\n  return merged;\n}\n\nvar repeat = function(str, reps) {\n  var s = '';\n  while (--reps >= 0) s += str;\n  return s;\n}\n\nvar pad = function(str, length, padchar, align) {\n  var c = padchar || ' ',\n      s = str + '',\n      n = length - s.length;\n\n  return n <= 0 ? s\n    : align === 'left' ? repeat(c, n) + s\n    : align === 'center' ? repeat(c, ~~(n/2)) + s + repeat(c, Math.ceil(n/2))\n    : s + repeat(c, n);\n}\n\nvar peek = function(array) {\n  return array[array.length - 1];\n}\n\nvar toSet = function(_) {\n  for (var s={}, i=0, n=_.length; i<n; ++i) s[_[i]] = 1;\n  return s;\n}\n\nvar truncate = function(str, length, align, ellipsis) {\n  var e = ellipsis != null ? ellipsis : '\\u2026',\n      s = str + '',\n      n = s.length,\n      l = Math.max(0, length - e.length);\n\n  return n <= length ? s\n    : align === 'left' ? e + s.slice(n - l)\n    : align === 'center' ? s.slice(0, Math.ceil(l/2)) + e + s.slice(n - ~~(l/2))\n    : s.slice(0, l) + e;\n}\n\nvar visitArray = function(array, filter, visitor) {\n  if (array) {\n    var i = 0, n = array.length, t;\n    if (filter) {\n      for (; i<n; ++i) {\n        if (t = filter(array[i])) visitor(t, i, array);\n      }\n    } else {\n      array.forEach(visitor);\n    }\n  }\n}\n\nexports.accessor = accessor;\nexports.accessorName = accessorName;\nexports.accessorFields = accessorFields;\nexports.id = id;\nexports.identity = identity;\nexports.zero = zero;\nexports.one = one;\nexports.truthy = truthy;\nexports.falsy = falsy;\nexports.logger = logger;\nexports.None = None;\nexports.Warn = Warn;\nexports.Info = Info;\nexports.Debug = Debug;\nexports.array = array;\nexports.compare = compare;\nexports.constant = constant;\nexports.error = error;\nexports.extend = extend;\nexports.extentIndex = extentIndex;\nexports.fastmap = fastmap;\nexports.field = field;\nexports.inherits = inherits;\nexports.isArray = isArray;\nexports.isFunction = isFunction;\nexports.isNumber = isNumber;\nexports.isObject = isObject;\nexports.isString = isString;\nexports.key = key;\nexports.merge = merge;\nexports.pad = pad;\nexports.peek = peek;\nexports.repeat = repeat;\nexports.splitAccessPath = splitAccessPath;\nexports.stringValue = $;\nexports.toSet = toSet;\nexports.truncate = truncate;\nexports.visitArray = visitArray;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n","module.exports={\n  \"name\": \"vega-lite\",\n  \"author\": \"Jeffrey Heer, Dominik Moritz, Kanit \\\"Ham\\\" Wongsuphasawat\",\n  \"version\": \"2.0.0-alpha.0\",\n  \"collaborators\": [\n    \"Kanit Wongsuphasawat <kanitw@gmail.com> (http://kanitw.yellowpigz.com)\",\n    \"Dominik Moritz <domoritz@cs.washington.edu> (http://www.domoritz.de)\",\n    \"Jeffrey Heer <jheer@uw.edu> (http://jheer.org)\"\n  ],\n  \"homepage\": \"https://vega.github.io/vega-lite/\",\n  \"description\": \"Vega-lite provides a higher-level grammar for visual analysis, comparable to ggplot or Tableau, that generates complete Vega specifications.\",\n  \"main\": \"src/vl.js\",\n  \"types\": \"src/vl.d.ts\",\n  \"bin\": {\n    \"vl2png\": \"./bin/vl2png\",\n    \"vl2svg\": \"./bin/vl2svg\",\n    \"vl2vg\": \"./bin/vl2vg\"\n  },\n  \"directories\": {\n    \"test\": \"test\"\n  },\n  \"scripts\": {\n    \"build\": \"browserify src/vl.ts -p tsify -d -s vl | exorcist vega-lite.js.map > vega-lite.js \",\n    \"postbuild\": \"uglifyjs vega-lite.js -cm --in-source-map vega-lite.js.map --source-map vega-lite.min.js.map > vega-lite.min.js && npm run schema\",\n    \"build:all\": \"npm run clean && npm run build && npm run test:noschema && npm run build:images\",\n    \"build:images\": \"npm run data && scripts/generate-images.sh\",\n    \"build:toc\": \"bundle exec jekyll build --incremental -q && scripts/generate-toc\",\n    \"build:test-gallery\": \"browserify test-gallery/main.ts -p [tsify -p test-gallery] -d > test-gallery/main.js\",\n    \"clean\": \"rm -f vega-lite.* & find -E src test site -regex '.*\\\\.(js|js.map|d.ts)' -delete & rm -rf examples/_diff examples/_original examples/_output examples/images && rm -rf data\",\n    \"data\": \"rsync -r node_modules/vega-datasets/data/* data\",\n    \"deploy\": \"scripts/deploy.sh\",\n    \"deploy:gh\": \"scripts/deploy-gh.sh\",\n    \"deploy:schema\": \"scripts/deploy-schema.sh\",\n    \"lint\": \"tslint -c tslint.json 'src/**/*.ts' 'test/**/*.ts' --exclude '**/*.d.ts'\",\n    \"prestart\": \"npm run data && scripts/index-examples\",\n    \"start\": \"nodemon -x 'npm run build:test-gallery' & browser-sync start --server --files 'test-gallery/main.js' --index 'test-gallery/index.html'\",\n    \"poststart\": \"rm examples/all-examples.json\",\n    \"schema\": \"typescript-json-schema --required true --noExtraProps true src/spec.ts ExtendedSpec > vega-lite-schema.json\",\n    \"presite\": \"tsc && npm run build && bower install && npm run data && npm run build:toc\",\n    \"site\": \"bundle exec jekyll serve --incremental\",\n    \"pretest\": \"tsc && npm run data\",\n    \"test\": \"nyc --reporter=html --reporter=text-summary mocha\",\n    \"posttest\": \"npm run lint && npm run test:examples\",\n    \"test:examples\": \"npm run schema && mocha examples\",\n    \"test:noschema\": \"npm run pretest && nyc --reporter=html --reporter=text-summary mocha && npm run lint && mocha examples\",\n    \"codecov\": \"nyc report --reporter=json && codecov -f coverage/*.json\",\n    \"test:debug\": \"npm run schema && mocha --debug-brk test examples\",\n    \"watch:build\": \"watchify src/vl.ts -p tsify -v -d -s vl -o 'exorcist vega-lite.js.map > vega-lite.js'\",\n    \"watch:test\": \"nodemon -x 'npm test'\",\n    \"watch\": \"nodemon -x 'npm run build && npm run test:noschema' # already run schema in build\",\n    \"x-compile\": \"./scripts/examples-compile.sh\",\n    \"x-diff\": \"./scripts/examples-diff.sh\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/vega/vega-lite.git\"\n  },\n  \"license\": \"BSD-3-Clause\",\n  \"bugs\": {\n    \"url\": \"https://github.com/vega/vega-lite/issues\"\n  },\n  \"homepage\": \"https://github.com/vega/vega-lite\",\n  \"devDependencies\": {\n    \"@types/chai\": \"^3.4.34\",\n    \"@types/d3\": \"^4.3.0\",\n    \"@types/json-stable-stringify\": \"^1.0.29\",\n    \"@types/mocha\": \"^2.2.33\",\n    \"@types/node\": \"^7.0.1\",\n    \"ajv\": \"5.0.1-beta.1\",\n    \"browser-sync\": \"~2.18.6\",\n    \"browserify\": \"~13.3.0\",\n    \"chai\": \"~3.5.0\",\n    \"cheerio\": \"~0.22.0\",\n    \"codecov\": \"~1.0.1\",\n    \"d3\": \"^4.4.0\",\n    \"exorcist\": \"~0.4.0\",\n    \"mocha\": \"~3.2.0\",\n    \"nodemon\": \"~1.11.0\",\n    \"nyc\": \"~10.1.2\",\n    \"source-map-support\": \"~0.4.6\",\n    \"tsify\": \"~3.0.0\",\n    \"tslint\": \"~4.3.1\",\n    \"typescript\": \"^2.1.5\",\n    \"typescript-json-schema\": \"^0.6.0\",\n    \"uglify-js\": \"~2.7.4\",\n    \"vega\": \"3.0.0-beta.16\",\n    \"vega-datasets\": \"vega/vega-datasets#gh-pages\",\n    \"watchify\": \"~3.8.0\",\n    \"yaml-front-matter\": \"~3.4.0\"\n  },\n  \"dependencies\": {\n    \"json-stable-stringify\": \"~1.0.1\",\n    \"vega-util\": \"~1.1.1\",\n    \"yargs\": \"~6.6.0\"\n  }\n}\n","\nexport namespace AggregateOp {\n    export const VALUES: 'values' = 'values';\n    export const COUNT: 'count' = 'count';\n    export const VALID: 'valid' = 'valid';\n    export const MISSING: 'missing' = 'missing';\n    export const DISTINCT: 'distinct' = 'distinct';\n    export const SUM: 'sum' = 'sum';\n    export const MEAN: 'mean' = 'mean';\n    export const AVERAGE: 'average' = 'average';\n    export const VARIANCE: 'variance' = 'variance';\n    export const VARIANCEP: 'variancep' = 'variancep';\n    export const STDEV: 'stdev' = 'stdev';\n    export const STDEVP: 'stdevp' = 'stdevp';\n    export const MEDIAN: 'median' = 'median';\n    export const Q1: 'q1' = 'q1';\n    export const Q3: 'q3' = 'q3';\n    export const MODESKEW: 'modeskew' = 'modeskew';\n    export const MIN: 'min' = 'min';\n    export const MAX: 'max' = 'max';\n    export const ARGMIN: 'argmin' = 'argmin';\n    export const ARGMAX: 'argmax' = 'argmax';;\n}\n\nexport type AggregateOp = typeof AggregateOp.ARGMAX | typeof AggregateOp.ARGMIN | typeof AggregateOp.AVERAGE\n  | typeof AggregateOp.COUNT | typeof AggregateOp.DISTINCT | typeof AggregateOp.MAX | typeof AggregateOp.MEAN\n  | typeof AggregateOp.MEDIAN | typeof AggregateOp.MIN | typeof AggregateOp.MISSING | typeof AggregateOp.MODESKEW\n  | typeof AggregateOp.Q1 | typeof AggregateOp.Q3 | typeof AggregateOp.STDEV | typeof AggregateOp.STDEVP\n  | typeof AggregateOp.SUM | typeof AggregateOp.VALID | typeof AggregateOp.VALUES | typeof AggregateOp.VARIANCE\n  | typeof AggregateOp.VARIANCEP;\n\nexport const AGGREGATE_OPS = [\n    AggregateOp.VALUES,\n    AggregateOp.COUNT,\n    AggregateOp.VALID,\n    AggregateOp.MISSING,\n    AggregateOp.DISTINCT,\n    AggregateOp.SUM,\n    AggregateOp.MEAN,\n    AggregateOp.AVERAGE,\n    AggregateOp.VARIANCE,\n    AggregateOp.VARIANCEP,\n    AggregateOp.STDEV,\n    AggregateOp.STDEVP,\n    AggregateOp.MEDIAN,\n    AggregateOp.Q1,\n    AggregateOp.Q3,\n    AggregateOp.MODESKEW,\n    AggregateOp.MIN,\n    AggregateOp.MAX,\n    AggregateOp.ARGMIN,\n    AggregateOp.ARGMAX,\n];\n\n/** Additive-based aggregation operations.  These can be applied to stack. */\nexport const SUM_OPS = [\n    AggregateOp.COUNT,\n    AggregateOp.SUM,\n    AggregateOp.DISTINCT,\n    AggregateOp.VALID,\n    AggregateOp.MISSING\n];\n\n/**\n * Aggregation operators that always produce values within the range [domainMin, domainMax].\n */\nexport const SHARED_DOMAIN_OPS = [\n    AggregateOp.MEAN,\n    AggregateOp.AVERAGE,\n    AggregateOp.MEDIAN,\n    AggregateOp.Q1,\n    AggregateOp.Q3,\n    AggregateOp.MIN,\n    AggregateOp.MAX,\n];\n","import {DateTime} from './datetime';\nimport {VgAxisEncode} from './vega.schema';\n\nexport namespace AxisOrient {\n    export const TOP: 'top' = 'top';\n    export const RIGHT: 'right' = 'right';\n    export const LEFT: 'left' = 'left';\n    export const BOTTOM: 'bottom' = 'bottom';\n}\nexport type AxisOrient = typeof AxisOrient.TOP | typeof AxisOrient.RIGHT | typeof AxisOrient.LEFT | typeof AxisOrient.BOTTOM;\n\nexport interface AxisConfig {\n  // ---------- General ----------\n  /**\n   * Width of the axis line\n   */\n  axisWidth?: number;\n  /**\n   * A non-positive integer indicating z-index of the axis.\n   * If zindex is 0, axes should be drawn behind all chart elements.\n   * To put them in front, use zindex = 1.\n   * @TJS-type integer\n   * @minimum 0\n   */\n  zindex?: number;\n  /**\n   * The offset, in pixels, by which to displace the axis from the edge of the enclosing group or data rectangle.\n   */\n  offset?: number;\n\n  // ---------- Axis ----------\n  /**\n   * Color of axis line.\n   */\n  axisColor?: string;\n\n  /**\n   * Whether to include the axis domain line.\n   */\n  domain?: boolean;\n\n  // ---------- Grid ----------\n  /**\n   * A flag indicate if gridlines should be created in addition to ticks. If `grid` is unspecified, the default value is `true` for ROW and COL. For X and Y, the default value is `true` for quantitative and time fields and `false` otherwise.\n   */\n  grid?: boolean;\n\n  /**\n   * Color of gridlines.\n   */\n  gridColor?: string;\n\n  /**\n   * The offset (in pixels) into which to begin drawing with the grid dash array.\n   * @minimum 0\n   */\n  gridDash?: number[];\n\n  /**\n   * The stroke opacity of grid (value between [0,1])\n   * @minimum 0\n   * @maximum 1\n   */\n  gridOpacity?: number;\n\n  /**\n   * The grid width, in pixels.\n   * @minimum 0\n   */\n  gridWidth?: number;\n\n  // ---------- Labels ----------\n  /**\n   * Enable or disable labels.\n   */\n  label?: boolean;\n  /**\n   * The rotation angle of the axis labels.\n   * @minimum 0\n   * @minimum 360\n   */\n  labelAngle?: number;\n  /**\n   * Text alignment for the Label.\n   */\n  labelAlign?: string;\n  /**\n   * Text baseline for the label.\n   */\n  labelBaseline?: string;\n  /**\n   * Truncate labels that are too long.\n   * @minimum 1\n   * @TJS-type integer\n   */\n  labelMaxLength?: number;\n  /**\n   * Whether month and day names should be abbreviated.\n   */\n  shortTimeLabels?: boolean;\n\n  // ---------- Ticks ----------\n  /**\n   * If provided, sets the number of minor ticks between major ticks (the value 9 results in decimal subdivision). Only applicable for axes visualizing quantitative scales.\n   * @minimum 0\n   * @TJS-type integer\n   */\n  subdivide?: number;\n\n  /**\n   * Whether the axis should include ticks.\n   */\n  tick?: boolean;\n\n  /**\n   * A desired number of ticks, for axes visualizing quantitative scales. The resulting number may be different so that values are \"nice\" (multiples of 2, 5, 10) and lie within the underlying scale's range.\n   * @minimum 0\n   * @TJS-type integer\n   */\n  tickCount?: number;\n\n  /**\n   * The color of the axis's tick.\n   */\n  tickColor?: string;\n\n  /**\n   * The color of the tick label, can be in hex color code or regular color name.\n   */\n  tickLabelColor?: string;\n\n  /**\n   * The font of the tick label.\n   */\n  tickLabelFont?: string;\n\n  /**\n   * The font size of label, in pixels.\n   * @minimum 0\n   */\n  tickLabelFontSize?: number;\n\n  /**\n   * The padding, in pixels, between ticks and text labels.\n   */\n  tickPadding?: number;\n  /**\n   * The size, in pixels, of major, minor and end ticks.\n   * @minimum 0\n   */\n  tickSize?: number;\n  /**\n   * The size, in pixels, of major ticks.\n   * @minimum 0\n   */\n  tickSizeMajor?: number;\n  /**\n   * The size, in pixels, of minor ticks.\n   * @minimum 0\n   */\n  tickSizeMinor?: number;\n  /**\n   * The size, in pixels, of end ticks.\n   * @minimum 0\n   */\n  tickSizeEnd?: number;\n\n  /**\n   * The width, in pixels, of ticks.\n   * @minimum 0\n   */\n  tickWidth?: number;\n\n  // ---------- Title ----------\n  /**\n   * Color of the title, can be in hex color code or regular color name.\n   */\n  titleColor?: string;\n\n  /**\n   * Font of the title.\n   */\n  titleFont?: string;\n\n  /**\n   * Size of the title.\n   * @minimum 0\n   */\n  titleFontSize?: number;\n\n  /**\n   * Weight of the title.\n   */\n  titleFontWeight?: string | number;\n\n  /**\n   * A title offset value for the axis.\n   */\n  titleOffset?: number;\n  /**\n   * Max length for axis title if the title is automatically generated from the field's description. By default, this is automatically based on cell size and characterWidth property.\n   * @minimum 0\n   * @TJS-type integer\n   */\n  titleMaxLength?: number;\n\n  // ---------- Other ----------\n  /**\n   * Optional mark definitions for custom axis encoding.\n   */\n  encode?: VgAxisEncode;\n}\n\n// TODO: add comment for properties that we rely on Vega's default to produce\n// more concise Vega output.\n\nexport const defaultAxisConfig: AxisConfig = {\n  labelMaxLength: 25,\n};\n\nexport const defaultFacetAxisConfig: AxisConfig = {\n  axisWidth: 0,\n  // TODO: remove these\n  domain: false,\n  grid: false,\n  tick: false\n};\n\nexport interface Axis extends AxisConfig {\n  /**\n   * The rotation angle of the axis labels.\n   * @minimum 0\n   * @maximum 360\n   */\n  labelAngle?: number;\n  /**\n   * The formatting pattern for axis labels.\n   */\n  format?: string; // default value determined by config.format anyway\n  /**\n   * The orientation of the axis. One of top, bottom, left or right. The orientation can be used to further specialize the axis type (e.g., a y axis oriented for the right edge of the chart).\n   */\n  orient?: AxisOrient;\n  /**\n   * A title for the axis. Shows field name and its function by default.\n   */\n  title?: string;\n  values?: number[] | DateTime[];\n}\n","import {Channel, ROW, COLUMN, SHAPE, SIZE} from './channel';\n\n/**\n * Binning properties or boolean flag for determining whether to bin data or not.\n */\nexport interface Bin {\n  /**\n   * A two-element (`[min, max]`) array indicating the range of desired bin values.\n   * @minItems 2\n   * @maxItems 2\n   */\n  extent?: number[];\n\n  /**\n   * The number base to use for automatic bin determination (default is base 10).\n   */\n  base?: number;\n  /**\n   * An exact step size to use between bins. If provided, options such as maxbins will be ignored.\n   */\n  step?: number;\n  /**\n   * An array of allowable step sizes to choose from.\n   * @minItems 1\n   */\n  steps?: number[];\n  /**\n   * A minimum allowable step size (particularly useful for integer values).\n   */\n  minstep?: number;\n  /**\n   * Scale factors indicating allowable subdivisions. The default value is [5, 2], which indicates that for base 10 numbers (the default base), the method may consider dividing bin sizes by 5 and/or 2. For example, for an initial step size of 10, the method can check if bin sizes of 2 (= 10/5), 5 (= 10/2), or 1 (= 10/(5*2)) might also satisfy the given constraints.\n   * @minItems 1\n   */\n  divide?: number[];\n  /**\n   * Maximum number of bins.\n   * @minimum 2\n   */\n  maxbins?: number;\n}\n\nexport function autoMaxBins(channel: Channel): number {\n  switch (channel) {\n    case ROW:\n    case COLUMN:\n    case SIZE:\n      // Facets and Size shouldn't have too many bins\n      // We choose 6 like shape to simplify the rule\n    case SHAPE:\n      return 6; // Vega's \"shape\" has 6 distinct values\n    default:\n      return 10;\n  }\n}\n","/*\n * Constants and utilities for encoding channels (Visual variables)\n * such as 'x', 'y', 'color'.\n */\n\nimport {Encoding} from './encoding';\nimport {Mark} from './mark';\nimport {ScaleType, SCALE_TYPES} from './scale';\nimport {contains, toSet, without} from './util';\n\nexport namespace Channel {\n  // Facet\n  export const ROW: 'row' = 'row';\n  export const COLUMN: 'column' = 'column';\n\n  // Position\n  export const X: 'x' = 'x';\n  export const Y: 'y' = 'y';\n  export const X2: 'x2' = 'x2';\n  export const Y2: 'y2' = 'y2';\n\n  // Mark property with scale\n  export const COLOR: 'color' = 'color';\n  export const SHAPE: 'shape' = 'shape';\n  export const SIZE: 'size' = 'size';\n  export const OPACITY: 'opacity' = 'opacity';\n\n  // Non-scale channel\n  export const TEXT: 'text' = 'text';\n  export const ORDER: 'order' = 'order';\n  export const DETAIL: 'detail' = 'detail';\n}\n\nexport type Channel = keyof Encoding;\n\nexport const X = Channel.X;\nexport const Y = Channel.Y;\nexport const X2 = Channel.X2;\nexport const Y2 = Channel.Y2;\nexport const ROW = Channel.ROW;\nexport const COLUMN = Channel.COLUMN;\nexport const SHAPE = Channel.SHAPE;\nexport const SIZE = Channel.SIZE;\nexport const COLOR = Channel.COLOR;\nexport const TEXT = Channel.TEXT;\nexport const DETAIL = Channel.DETAIL;\nexport const ORDER = Channel.ORDER;\nexport const OPACITY = Channel.OPACITY;\n\n\nexport const CHANNELS = [X, Y, X2, Y2, ROW, COLUMN, SIZE, SHAPE, COLOR, ORDER, OPACITY, TEXT, DETAIL];\n\n// CHANNELS without COLUMN, ROW\nexport const UNIT_CHANNELS = [X, Y, X2, Y2, SIZE, SHAPE, COLOR, ORDER, OPACITY, TEXT, DETAIL];\n\n// UNIT_CHANNELS without X2, Y2, ORDER, DETAIL, TEXT\nexport const UNIT_SCALE_CHANNELS = [X, Y, SIZE, SHAPE, COLOR, OPACITY];\n\n// UNIT_SCALE_CHANNELS with ROW, COLUMN\nexport const SCALE_CHANNELS = [X, Y, SIZE, SHAPE, COLOR, OPACITY, ROW, COLUMN];\n\n// UNIT_CHANNELS without X, Y, X2, Y2;\nexport const NONSPATIAL_CHANNELS = [SIZE, SHAPE, COLOR, ORDER, OPACITY, TEXT, DETAIL];\n\n// UNIT_SCALE_CHANNELS without X, Y;\nexport const NONSPATIAL_SCALE_CHANNELS = [SIZE, SHAPE, COLOR, OPACITY];\n\n/** Channels that can serve as groupings for stacked charts. */\nexport const STACK_GROUP_CHANNELS = [COLOR, DETAIL, ORDER, OPACITY, SIZE];\n\nexport interface SupportedMark {\n  point?: boolean;\n  tick?: boolean;\n  rule?: boolean;\n  circle?: boolean;\n  square?: boolean;\n  bar?: boolean;\n  rect?: boolean;\n  line?: boolean;\n  area?: boolean;\n  text?: boolean;\n};\n\n/**\n * Return whether a channel supports a particular mark type.\n * @param channel  channel name\n * @param mark the mark type\n * @return whether the mark supports the channel\n */\nexport function supportMark(channel: Channel, mark: Mark) {\n  return mark in getSupportedMark(channel);\n}\n\n/**\n * Return a dictionary showing whether a channel supports mark type.\n * @param channel\n * @return A dictionary mapping mark types to boolean values.\n */\nexport function getSupportedMark(channel: Channel): SupportedMark {\n  switch (channel) {\n    case X:\n    case Y:\n    case COLOR:\n    case DETAIL:\n    case ORDER:    // TODO: revise (order might not support rect, which is not stackable?)\n    case OPACITY:\n    case ROW:\n    case COLUMN:\n      return { // all marks\n        point: true, tick: true, rule: true, circle: true, square: true,\n        bar: true, rect: true, line: true, area: true, text: true\n      };\n    case X2:\n    case Y2:\n      return {\n        rule: true, bar: true, rect: true, area: true\n      };\n    case SIZE:\n      return {\n        point: true, tick: true, rule: true, circle: true, square: true,\n        bar: true, text: true\n      };\n    case SHAPE:\n      return {point: true};\n    case TEXT:\n      return {text: true};\n  }\n  return {};\n}\n\nexport interface SupportedRole {\n  measure: boolean;\n  dimension: boolean;\n};\n\n/**\n * Return whether a channel supports dimension / measure role\n * @param  channel\n * @return A dictionary mapping role to boolean values.\n */\nexport function getSupportedRole(channel: Channel): SupportedRole {\n  switch (channel) {\n    case X:\n    case Y:\n    case COLOR:\n    case OPACITY:\n    case ORDER:\n    case DETAIL:\n      return {\n        measure: true,\n        dimension: true\n      };\n    case ROW:\n    case COLUMN:\n    case SHAPE:\n      return {\n        measure: false,\n        dimension: true\n      };\n    case X2:\n    case Y2:\n    case SIZE:\n    case TEXT:\n      return {\n        measure: true,\n        dimension: false\n      };\n  }\n  throw new Error('Invalid encoding channel ' + channel);\n}\n\nexport function hasScale(channel: Channel) {\n  return !contains([DETAIL, TEXT, ORDER], channel);\n}\n\n// Position does not work with ordinal (lookup) scale and sequential (which is only for color)\nconst POSITION_SCALE_TYPE_INDEX = toSet(without(SCALE_TYPES, ['ordinal', 'sequential'] as ScaleType[]));\n\nexport function supportScaleType(channel: Channel, scaleType: ScaleType): boolean {\n  switch (channel) {\n    case 'row':\n    case 'column':\n      return scaleType === 'band'; // row / column currently supports band only\n    case 'x':\n    case 'y':\n    case 'size': // TODO: size and opacity can support ordinal with more modification\n    case 'opacity':\n      // Although it generally doesn't make sense to use band with size and opacity,\n      // it can also work since we use band: 0.5 to get midpoint.\n      return scaleType in POSITION_SCALE_TYPE_INDEX;\n    case 'color':\n      return scaleType !== 'band';    // band does not make sense with color\n    case 'shape':\n      return scaleType === 'ordinal'; // shape = lookup only\n  }\n  /* istanbul ignore next: it should never reach here */\n  return false;\n}\n","import {COLUMN, X, Channel} from '../../channel';\nimport {NOMINAL, ORDINAL, TEMPORAL} from '../../type';\nimport {contains, keys, extend} from '../../util';\nimport {VgAxis} from '../../vega.schema';\n\nimport {timeFormatExpression} from '../common';\nimport {Model} from '../model';\n\n// TODO: @yuhanlu -- please change method signature to require only what are really needed\nexport function domain(model: Model, channel: Channel, domainPropsSpec: any, _?: VgAxis) {\n  const axis = model.axis(channel);\n\n  return extend(\n    axis.axisColor !== undefined ?\n      { stroke: {value: axis.axisColor} } :\n      {},\n    axis.axisWidth !== undefined ?\n      { strokeWidth: {value: axis.axisWidth} } :\n      {},\n    domainPropsSpec || {}\n  );\n}\n\n// TODO: @yuhanlu -- please change method signature to require only what are really needed\nexport function grid(model: Model, channel: Channel, gridPropsSpec: any, _?: VgAxis) {\n  const axis = model.axis(channel);\n\n  return extend(\n    axis.gridColor !== undefined ? { stroke: {value: axis.gridColor}} : {},\n    axis.gridOpacity !== undefined ? {strokeOpacity: {value: axis.gridOpacity} } : {},\n    axis.gridWidth !== undefined ? {strokeWidth : {value: axis.gridWidth} } : {},\n    axis.gridDash !== undefined ? {strokeDashOffset : {value: axis.gridDash} } : {},\n    gridPropsSpec || {}\n  );\n}\n\n// TODO: @yuhanlu -- please change method signature to require only what are really needed\nexport function labels(model: Model, channel: Channel, labelsSpec: any, def: VgAxis) {\n  const fieldDef = model.fieldDef(channel);\n  const axis = model.axis(channel);\n  const config = model.config();\n\n  // Text\n  if (contains([NOMINAL, ORDINAL], fieldDef.type) && axis.labelMaxLength) {\n    // TODO replace this with Vega's labelMaxLength once it is introduced\n    labelsSpec = extend({\n      text: {\n        signal: `truncate(datum.value, ${axis.labelMaxLength})`\n      }\n    }, labelsSpec || {});\n  } else if (fieldDef.type === TEMPORAL) {\n    labelsSpec = extend({\n      text: {\n        signal: timeFormatExpression('datum.value', fieldDef.timeUnit, axis.format, axis.shortTimeLabels, config)\n      }\n    }, labelsSpec);\n  }\n\n  // Label Angle\n  if (axis.labelAngle !== undefined) {\n    labelsSpec.angle = {value: axis.labelAngle};\n  } else {\n    // auto rotate for X\n    if (channel === X && (contains([NOMINAL, ORDINAL], fieldDef.type) || !!fieldDef.bin || fieldDef.type === TEMPORAL)) {\n      labelsSpec.angle = {value: 270};\n    }\n  }\n\n  if (axis.labelAlign !== undefined) {\n    labelsSpec.align = {value: axis.labelAlign};\n  } else {\n    // Auto set align if rotated\n    // TODO: consider other value besides 270, 90\n    if (labelsSpec.angle) {\n      if (labelsSpec.angle.value === 270) {\n        labelsSpec.align = {\n          value: def.orient === 'top' ? 'left':\n                  (channel === X || channel === COLUMN) ? 'right' :\n                  'center'\n        };\n      } else if (labelsSpec.angle.value === 90) {\n        labelsSpec.align = {value: 'center'};\n      }\n    }\n  }\n\n  if (axis.labelBaseline !== undefined) {\n    labelsSpec.baseline = {value: axis.labelBaseline};\n  } else {\n    if (labelsSpec.angle) {\n      // Auto set baseline if rotated\n      // TODO: consider other value besides 270, 90\n      if (labelsSpec.angle.value === 270) {\n        labelsSpec.baseline = {value: (channel === X || channel === COLUMN) ? 'middle' : 'bottom'};\n      } else if (labelsSpec.angle.value === 90) {\n        labelsSpec.baseline = {value: 'bottom'};\n      }\n    }\n  }\n\n  if (axis.tickLabelColor !== undefined) {\n      labelsSpec.fill = {value: axis.tickLabelColor};\n  }\n\n  if (axis.tickLabelFont !== undefined) {\n      labelsSpec.font = {value: axis.tickLabelFont};\n  }\n\n  if (axis.tickLabelFontSize !== undefined) {\n      labelsSpec.fontSize = {value: axis.tickLabelFontSize};\n  }\n\n  return keys(labelsSpec).length === 0 ? undefined : labelsSpec;\n}\n\n// TODO: @yuhanlu -- please change method signature to require only what are really needed\nexport function ticks(model: Model, channel: Channel, ticksPropsSpec: any, _?: VgAxis) {\n  const axis = model.axis(channel);\n\n  return extend(\n    axis.tickColor !== undefined ? {stroke : {value: axis.tickColor} } : {},\n    axis.tickWidth !== undefined ? {strokeWidth: {value: axis.tickWidth} } : {},\n    ticksPropsSpec || {}\n  );\n}\n\n// TODO: @yuhanlu -- please change method signature to require only what are really needed\nexport function title(model: Model, channel: Channel, titlePropsSpec: any, _?: VgAxis) {\n  const axis = model.axis(channel);\n\n  return extend(\n    axis.titleColor !== undefined ? {fill : {value: axis.titleColor} } : {},\n    axis.titleFont !== undefined ? {font: {value: axis.titleFont}} : {},\n    axis.titleFontSize !== undefined ? {fontSize: {value: axis.titleFontSize}} : {},\n    axis.titleFontWeight !== undefined ? {fontWeight: {value: axis.titleFontWeight}} : {},\n\n    titlePropsSpec || {}\n  );\n}\n","import {Axis} from '../../axis';\nimport {Channel} from '../../channel';\nimport {VgAxis} from '../../vega.schema';\n\nimport * as encode from './encode';\nimport * as rules from './rules';\n\nimport {Model} from '../model';\nimport {Dict, keys, some} from '../../util';\n\ntype AxisPart = 'domain' | 'grid' | 'labels' | 'ticks' | 'title';\nconst AXIS_PARTS: AxisPart[] = ['domain', 'grid', 'labels', 'ticks', 'title'];\n\n/**\n * Mapping an axis part to its enable/disable flag.\n */\nconst axisPartFlag = {\n  domain: 'domain',\n  grid: 'grid',\n  labels: 'label',\n  ticks: 'tick',\n  title: 'title'\n};\n\nexport function parseAxisComponent(model: Model, axisChannels: Channel[]): Dict<VgAxis[]> {\n  return axisChannels.reduce(function(axis, channel) {\n    const vgAxes: VgAxis[] = [];\n    if (model.axis(channel)) {\n      const main = parseMainAxis(channel, model);\n      if (main && isVisibleAxis(main)) {\n        vgAxes.push(main);\n      }\n\n      const grid = parseGridAxis(channel, model);\n      if (grid && isVisibleAxis(grid)) {\n        vgAxes.push(grid);\n      }\n\n      if (vgAxes.length > 0) {\n        axis[channel] = vgAxes;\n      }\n    }\n    return axis;\n  }, {});\n}\n\nfunction isFalseOrNull(v: boolean | null) {\n  return v === false || v === null;\n}\n\n/**\n * Return if an axis is visible (shows at least one part of the axis).\n */\nfunction isVisibleAxis(axis: VgAxis) {\n  return some(AXIS_PARTS, (part) => hasAxisPart(axis, part));\n}\n\nfunction hasAxisPart(axis: VgAxis, part: AxisPart) {\n  // FIXME this method can be wrong if users use a Vega theme.\n  // (Not sure how to correctly handle that yet.).\n\n  if (part === 'grid' || part === 'title') {\n    return !!axis[part];\n  }\n  // Other parts are enabled by default, so they should not be false or null.\n  return !isFalseOrNull(axis[axisPartFlag[part]]);\n}\n\n/**\n * Make an inner axis for showing grid for shared axis.\n */\nexport function parseGridAxis(channel: Channel, model: Model): VgAxis {\n  // FIXME: support adding ticks for grid axis that are inner axes of faceted plots.\n  return parseAxis(channel, model, true);\n}\n\nexport function parseMainAxis(channel: Channel, model: Model) {\n  return parseAxis(channel, model, false);\n}\n\nfunction parseAxis(channel: Channel, model: Model, isGridAxis: boolean): VgAxis {\n  const axis = model.axis(channel);\n\n  let vgAxis: VgAxis = {\n    scale: model.scaleName(channel)\n  };\n\n  // 1.2. Add properties\n  [\n    // a) properties with special rules (so it has axis[property] methods) -- call rule functions\n    'domain', 'format', 'label', 'grid', 'gridScale', 'orient', 'tick', 'tickSize', 'tickCount',  'title', 'values', 'zindex',\n    // b) properties without rules, only produce default values in the schema, or explicit value if specified\n     'offset', 'subdivide', 'tickPadding', 'tickSize', 'tickSizeEnd', 'tickSizeMajor', 'tickSizeMinor', 'titleOffset'\n  ].forEach(function(property) {\n    const value = getSpecifiedOrDefaultValue(property, axis, channel, model, isGridAxis);\n    if (value !== undefined) {\n      vgAxis[property] = value;\n    }\n  });\n\n  // 2) Add guide encode definition groups\n\n  const encodeSpec = axis.encode || {};\n  AXIS_PARTS.forEach(function(part) {\n    if (!hasAxisPart(vgAxis, part)) {\n      // No need to create encode for a disabled part.\n      return;\n    }\n    // TODO(@yuhanlu): instead of calling encode[part], break this line based on part type\n    // as different require different parameters.\n    const value = encode[part](model, channel, encodeSpec.labels || {}, vgAxis);\n\n    if (value !== undefined && keys(value).length > 0) {\n      vgAxis.encode = vgAxis.encode || {};\n      vgAxis.encode[part] = {update: value};\n    }\n  });\n\n  return vgAxis;\n}\n\nfunction getSpecifiedOrDefaultValue(property: string, specifiedAxis: Axis, channel: Channel, model: Model, isGridAxis: boolean) {\n  const fieldDef = model.fieldDef(channel);\n  const config = model.config();\n\n  switch (property) {\n    case 'domain':\n    case 'label':\n    case 'tick':\n      return isGridAxis ? false : specifiedAxis[property];\n    case 'format':\n      return rules.format(specifiedAxis, channel, fieldDef, config);\n    case 'grid':\n      return rules.grid(model, channel, isGridAxis); // FIXME: refactor this\n    case 'gridScale':\n      return rules.gridScale(model, channel, isGridAxis);\n    case 'orient':\n      return rules.orient(specifiedAxis, channel);\n    case 'tickCount':\n      return rules.tickCount(specifiedAxis, channel, fieldDef); // TODO: scaleType\n    case 'title':\n      return rules.title(specifiedAxis, fieldDef, config, isGridAxis);\n    case 'values':\n      return rules.values(specifiedAxis);\n    case 'zindex':\n      return rules.zindex(specifiedAxis, isGridAxis);\n  }\n  // Otherwise, return specified property.\n  return specifiedAxis[property];\n}\n","import * as log from '../../log';\n\nimport {Axis, AxisOrient} from '../../axis';\nimport {COLUMN, ROW, X, Y, Channel} from '../../channel';\nimport {Config} from '../../config';\nimport {DateTime, isDateTime, timestamp} from '../../datetime';\nimport {title as fieldDefTitle, FieldDef} from '../../fielddef';\nimport {truncate} from '../../util';\n\nimport {numberFormat} from '../common';\nimport {Model} from '../model';\n\nexport function format(specifiedAxis: Axis, channel: Channel, fieldDef: FieldDef, config: Config) {\n  return numberFormat(fieldDef, specifiedAxis.format, config, channel);\n}\n\n// TODO: we need to refactor this method after we take care of config refactoring\n/**\n * Default rules for whether to show a grid should be shown for a channel.\n * If `grid` is unspecified, the default value is `true` for ordinal scales that are not binned\n */\nexport function gridShow(model: Model, channel: Channel) {\n  const grid = model.axis(channel).grid;\n  if (grid !== undefined) {\n    return grid;\n  }\n\n  return !model.hasDiscreteScale(channel) && !model.fieldDef(channel).bin;\n}\n\nexport function grid(model: Model, channel: Channel, isGridAxis: boolean) {\n  if (channel === ROW || channel === COLUMN) {\n    // never apply grid for ROW and COLUMN since we manually create rule-group for them\n    return undefined;\n  }\n\n  if (!isGridAxis) {\n    return undefined;\n  }\n\n  return gridShow(model, channel);\n}\n\nexport function gridScale(model: Model, channel: Channel, isGridAxis: boolean) {\n  if (isGridAxis) {\n    const gridChannel: Channel = channel === 'x' ? 'y' : 'x';\n    if (model.scale(gridChannel)) {\n      return model.scaleName(gridChannel);\n    }\n  }\n  return undefined;\n}\n\nexport function orient(specifiedAxis: Axis, channel: Channel) {\n  const orient = specifiedAxis.orient;\n  if (orient) {\n    return orient;\n  }\n\n  switch (channel) {\n    case COLUMN:\n      // FIXME test and decide\n      return AxisOrient.TOP;\n    case X:\n      return AxisOrient.BOTTOM;\n    case ROW:\n    case Y:\n      return AxisOrient.LEFT;\n  }\n  /* istanbul ignore next: This should never happen. */\n  throw new Error(log.message.INVALID_CHANNEL_FOR_AXIS);\n}\n\nexport function tickCount(specifiedAxis: Axis, channel: Channel, fieldDef: FieldDef) {\n  const count = specifiedAxis.tickCount;\n  if (count !== undefined) {\n    return count;\n  }\n\n  // FIXME depends on scale type too\n  if (channel === X && !fieldDef.bin) {\n    // Vega's default tickCount often lead to a lot of label occlusion on X without 90 degree rotation\n    return 5;\n  }\n\n  return undefined;\n}\n\nexport function title(specifiedAxis: Axis, fieldDef: FieldDef, config: Config, isGridAxis: boolean) {\n  if (isGridAxis) {\n    return undefined;\n  }\n  if (specifiedAxis.title !== undefined) {\n    return specifiedAxis.title;\n  }\n\n  // if not defined, automatically determine axis title from field def\n  const fieldTitle = fieldDefTitle(fieldDef, config);\n\n  let maxLength: number = specifiedAxis.titleMaxLength;\n  return maxLength ? truncate(fieldTitle, maxLength) : fieldTitle;\n}\n\nexport function values(specifiedAxis: Axis) {\n  const vals = specifiedAxis.values;\n  if (specifiedAxis.values && isDateTime(vals[0])) {\n    return (vals as DateTime[]).map((dt) => {\n      // normalize = true as end user won't put 0 = January\n      return timestamp(dt, true);\n    });\n  }\n  return vals;\n}\n\nexport function zindex(specifiedAxis: Axis, isGridAxis: boolean) {\n  const z = specifiedAxis.zindex;\n  if (z !== undefined) {\n    return z;\n  }\n  if (isGridAxis) {\n    // if grid is true, need to put layer on the back so that grid is behind marks\n    return 0;\n  }\n  return 1; // otherwise return undefined and use Vega's default.\n};\n","import * as log from '../log';\n\nimport {AggregateOp} from '../aggregate';\nimport {TEXT, Channel} from '../channel';\nimport {Config, CellConfig} from '../config';\nimport {FieldDef, OrderFieldDef, field} from '../fielddef';\nimport {MarkConfig, TextConfig} from '../mark';\nimport {TimeUnit} from '../timeunit';\nimport {QUANTITATIVE} from '../type';\nimport {isArray} from '../util';\n\nimport {FacetModel} from './facet';\nimport {LayerModel} from './layer';\nimport {Model} from './model';\nimport {formatExpression} from '../timeunit';\nimport {UnitModel} from './unit';\nimport {Spec, isUnitSpec, isSomeFacetSpec, isLayerSpec} from '../spec';\nimport {VgEncodeEntry, VgSort} from '../vega.schema';\n\nexport function buildModel(spec: Spec, parent: Model, parentGivenName: string): Model {\n  if (isSomeFacetSpec(spec)) {\n    return new FacetModel(spec, parent, parentGivenName);\n  }\n\n  if (isLayerSpec(spec)) {\n    return new LayerModel(spec, parent, parentGivenName);\n  }\n\n  if (isUnitSpec(spec)) {\n    return new UnitModel(spec, parent, parentGivenName);\n  }\n\n  throw new Error(log.message.INVALID_SPEC);\n}\n\nexport function applyConfig(e: VgEncodeEntry,\n    config: CellConfig | MarkConfig | TextConfig, // TODO(#1842): consolidate MarkConfig | TextConfig?\n    propsList: string[]) {\n  propsList.forEach(function(property) {\n    const value = config[property];\n    if (value !== undefined) {\n      e[property] = { value: value };\n    }\n  });\n  return e;\n}\n\nexport function applyMarkConfig(e: VgEncodeEntry, model: UnitModel, propsList: string[]) {\n  return applyConfig(e, model.config().mark, propsList);\n}\n\n/**\n * Returns number format for a fieldDef\n *\n * @param format explicitly specified format\n */\nexport function numberFormat(fieldDef: FieldDef, format: string, config: Config, channel: Channel) {\n  if (fieldDef.type === QUANTITATIVE && !fieldDef.bin) {\n    // add number format for quantitative type only\n\n    if (format) {\n      return format;\n    } else if (fieldDef.aggregate === AggregateOp.COUNT && channel === TEXT) {\n      // FIXME: need a more holistic way to deal with this.\n      return 'd';\n    }\n    // TODO: need to make this work correctly for numeric ordinal / nominal type\n    return config.numberFormat;\n  }\n  return undefined;\n}\n\n/**\n * Returns the time expression used for axis/legend labels or text mark for a temporal field\n */\nexport function timeFormatExpression(field: string, timeUnit: TimeUnit, format: string, shortTimeLabels: boolean, config: Config): string {\n  if (!timeUnit || format) {\n    // If there is not time unit, or if user explicitly specify format for axis/legend/text.\n    const _format = format || config.timeFormat; // only use config.timeFormat if there is no timeUnit.\n    return `timeFormat(${field}, '${_format}')`;\n  } else {\n    return formatExpression(timeUnit, field, shortTimeLabels);\n  }\n}\n\n/**\n * Return Vega sort parameters (tuple of field and order).\n */\nexport function sortParams(orderDef: OrderFieldDef | OrderFieldDef[]): VgSort {\n  return (isArray(orderDef) ? orderDef : [orderDef]).reduce((s, orderChannelDef) => {\n    s.field.push(field(orderChannelDef, {binSuffix: 'start'}));\n    s.order.push(orderChannelDef.sort || 'ascending');\n    return s;\n  }, {field:[], order: []});\n}\n","/**\n * Module for compiling Vega-lite spec into Vega spec.\n */\n\nimport {LAYOUT} from '../data';\nimport * as log from '../log';\nimport {Model} from './model';\nimport {normalize, ExtendedSpec} from '../spec';\nimport {extend} from '../util';\n\nimport {buildModel} from './common';\n\nexport function compile(inputSpec: ExtendedSpec, logger?: log.LoggerInterface) {\n  if (logger) {\n    // set the singleton logger to the provided logger\n    log.set(logger);\n  }\n\n  try {\n    // 1. Convert input spec into a normal form\n    // (Decompose all extended unit specs into composition of unit spec.)\n    const spec = normalize(inputSpec);\n\n    // 2. Instantiate the model with default properties\n    const model = buildModel(spec, null, '');\n\n    // 3. Parse each part of the model to produce components that will be assembled later\n    // We traverse the whole tree to parse once for each type of components\n    // (e.g., data, layout, mark, scale).\n    // Please see inside model.parse() for order for compilation.\n    model.parse();\n\n    // 4. Assemble a Vega Spec from the parsed components in 3.\n    return assemble(model);\n  } finally {\n    // Reset the singleton logger if a logger is provided\n    if (logger) {\n      log.reset();\n    }\n  }\n}\n\nfunction assemble(model: Model) {\n  // TODO: change type to become VgSpec\n  const output = extend(\n    {\n      $schema: 'http://vega.github.io/schema/vega/v3.0.json',\n    },\n    topLevelBasicProperties(model),\n    {\n      // Map calculated layout width and height to width and height signals.\n      signals: [\n        {\n          name: 'width',\n          update: \"data('layout')[0].width\"\n        },\n        {\n          name: 'height',\n          update: \"data('layout')[0].height\"\n        }\n      ] // TODO: concat.(model.assembleTopLevelSignals())\n    },{\n      data: [].concat(\n        model.assembleData([]),\n        model.assembleLayout([])\n        // TODO: model.assembleSelectionData\n      ),\n      marks: [assembleRootGroup(model)]\n    });\n\n  return {\n    spec: output\n    // TODO: add warning / errors here\n  };\n}\n\nexport function topLevelBasicProperties(model: Model) {\n  const config = model.config();\n  return extend(\n    // TODO: Add other top-level basic properties (#1778)\n    {padding: model.padding() || config.padding},\n    {autosize: 'pad'},\n    config.viewport ? { viewport: config.viewport } : {},\n    config.background ? { background: config.background } : {}\n  );\n}\n\nexport function assembleRootGroup(model: Model) {\n  let rootGroup:any = extend(\n    {\n      name: model.name('main'),\n      type: 'group',\n    },\n    model.description() ? {description: model.description()} : {},\n    {\n      from: {data: model.name(LAYOUT +'')},\n      encode: {\n        update: extend(\n          {\n            width: {field: model.name('width')},\n            height: {field: model.name('height')}\n          },\n          model.assembleParentGroupProperties(model.config().cell)\n        )\n      }\n    });\n\n  return extend(rootGroup, model.assembleGroup());\n}\n","import * as log from '../log';\n\nimport {X, COLOR, SIZE, DETAIL} from '../channel';\nimport {Config} from '../config';\nimport {Encoding, isAggregate, channelHasField} from '../encoding';\nimport {isMeasure, isFieldDef, FieldDef} from '../fielddef';\nimport {MarkConfig, TextConfig, Orient} from '../mark';\nimport {BAR, AREA, POINT, LINE, TICK, CIRCLE, SQUARE, RECT, RULE, TEXT, Mark} from '../mark';\nimport {Scale, hasDiscreteDomain} from '../scale';\nimport {StackProperties} from '../stack';\nimport {TEMPORAL} from '../type';\nimport {contains, extend, Dict} from '../util';\n/**\n * Augment config.mark with rule-based default values.\n */\nexport function initMarkConfig(mark: Mark, encoding: Encoding, scale: Dict<Scale>, stacked: StackProperties, config: Config) {\n  // override mark config with mark specific config\n  const markConfig = extend({}, config.mark, config[mark]);\n\n  if (markConfig.filled === undefined) {\n    markConfig.filled = mark !== POINT && mark !== LINE && mark !== RULE;\n  }\n\n  if (markConfig.opacity === undefined) {\n    const o = opacity(mark, encoding, stacked);\n    if (o) {\n      markConfig.opacity = o;\n    }\n  }\n\n  // For orient, users can only specify for ambiguous cases.\n  markConfig.orient = orient(mark, encoding, scale, config.mark);\n  if (config.mark.orient !== undefined && markConfig.orient !== config.mark.orient) {\n    log.warn(log.message.orientOverridden(config.mark.orient, markConfig.orient));\n  }\n\n  return markConfig;\n}\n\nexport function initTextConfig(encoding: Encoding, config: Config) {\n  const textConfig: TextConfig = extend({}, config.text);\n\n  if (textConfig.align === undefined) {\n    textConfig.align = channelHasField(encoding, X) ? 'center' : 'right';\n  }\n  return textConfig;\n}\n\nexport function opacity(mark: Mark, encoding: Encoding, stacked: StackProperties) {\n  if (contains([POINT, TICK, CIRCLE, SQUARE], mark)) {\n    // point-based marks\n    if (!isAggregate(encoding) || channelHasField(encoding, DETAIL)) {\n      return 0.7;\n    }\n  }\n  if (mark === BAR && !stacked) {\n    if (channelHasField(encoding, COLOR) || channelHasField(encoding, DETAIL) || channelHasField(encoding, SIZE)) {\n      return 0.7;\n    }\n  }\n  if (mark === AREA) {\n    return 0.7; // inspired by Tableau\n  }\n  return undefined;\n}\n\nexport function orient(mark: Mark, encoding: Encoding, scale: Dict<Scale>, markConfig: MarkConfig = {}): Orient {\n  switch (mark) {\n    case POINT:\n    case CIRCLE:\n    case SQUARE:\n    case TEXT:\n    case RECT:\n      // orient is meaningless for these marks.\n      return undefined;\n  }\n\n  const yIsRange = encoding.y && encoding.y2;\n  const xIsRange = encoding.x && encoding.x2;\n\n  switch (mark) {\n    case TICK:\n      const xScaleType = scale['x'] ? scale['x'].type : null;\n      const yScaleType = scale['y'] ? scale['y'].type : null;\n\n      // Tick is opposite to bar, line, area and never have ranged mark.\n      if (!hasDiscreteDomain(xScaleType) && (\n            !encoding.y ||\n            hasDiscreteDomain(yScaleType) ||\n            (isFieldDef(encoding.y) && encoding.y.bin)\n        )) {\n        return 'vertical';\n      }\n      // y:Q or Ambiguous case, return horizontal\n      return 'horizontal';\n\n    case RULE:\n    case BAR:\n    case AREA:\n      // If there are range for both x and y, y (vertical) has higher precedence.\n      if (yIsRange) {\n        return 'vertical';\n      } else if (xIsRange) {\n        return 'horizontal';\n      } else if (mark === RULE) {\n        if (encoding.x && !encoding.y) {\n          return 'vertical';\n        } else if (encoding.y && !encoding.x) {\n          return 'horizontal';\n        }\n      }\n\n      /* tslint:disable */\n    case LINE: // intentional fall through\n      /* tslint:enable */\n      const xIsMeasure = isMeasure(encoding.x) || isMeasure(encoding.x2);\n      const yIsMeasure = isMeasure(encoding.y) || isMeasure(encoding.y2);\n      if (xIsMeasure && !yIsMeasure) {\n        return 'horizontal';\n      } else if (!xIsMeasure && yIsMeasure) {\n        return 'vertical';\n      } else if (xIsMeasure && yIsMeasure) {\n        const xDef = encoding.x as FieldDef;\n        const yDef = encoding.y as FieldDef;\n        // temporal without timeUnit is considered continuous, but better serves as dimension\n        if (xDef.type === TEMPORAL) {\n          return 'vertical';\n        } else if (yDef.type === TEMPORAL) {\n          return 'horizontal';\n        }\n\n        if (markConfig.orient) {\n          // When ambiguous, use user specified one.\n          return markConfig.orient;\n        }\n\n        if (!(mark === LINE && encoding.order)) {\n          // Except for connected scatterplot, we should log warning for unclear orientation of QxQ plots.\n          log.warn(log.message.unclearOrientContinuous(mark));\n        }\n        return 'vertical';\n      } else {\n        // For Discrete x Discrete case, return undefined.\n        log.warn(log.message.unclearOrientDiscreteOrEmpty(mark));\n        return undefined;\n      }\n  }\n  return 'vertical';\n}\n","import {DataComponentCompiler} from './base';\n\nimport {autoMaxBins} from '../../bin';\nimport {Channel} from '../../channel';\nimport {field, FieldDef} from '../../fielddef';\nimport {extend, vals, flatten, hash, Dict} from '../../util';\nimport {VgTransform} from '../../vega.schema';\nimport {hasDiscreteDomain} from '../../scale';\n\nimport {FacetModel} from './../facet';\nimport {LayerModel} from './../layer';\nimport {Model} from './../model';\n\n\nfunction numberFormatExpr(expr: string, format: string) {\n  return `format(${expr}, '${format}')`;\n}\n\nfunction parse(model: Model): Dict<VgTransform[]> {\n  return model.reduce(function(binComponent: Dict<VgTransform[]>, fieldDef: FieldDef, channel: Channel) {\n    const bin = model.fieldDef(channel).bin;\n    if (bin) {\n\n      let binTrans: VgTransform = extend({\n        type: 'bin',\n        field: fieldDef.field,\n        as: [field(fieldDef, { binSuffix: 'start' }), field(fieldDef, { binSuffix: 'end'})]\n      },\n        // if bin is an object, load parameter here!\n        typeof bin === 'boolean' ? {} : bin\n      );\n\n      const transform: VgTransform[] = [];\n      if (!binTrans.extent) {\n        const extentSignal = model.name(fieldDef.field + '_extent');\n        transform.push({\n          type: 'extent',\n          field: fieldDef.field,\n          signal: extentSignal\n        });\n\n        binTrans.extent = {signal: extentSignal};\n      }\n\n      if (!binTrans.maxbins && !binTrans.step) {\n        // if both maxbins and step are not specified, need to automatically determine bin\n        binTrans.maxbins = autoMaxBins(channel);\n      }\n\n      transform.push(binTrans);\n\n      const hasDiscreteDomainOrHasLegend = hasDiscreteDomain(model.scale(channel).type) || model.legend(channel);\n      if (hasDiscreteDomainOrHasLegend) {\n        // read format from axis or legend, if there is no format then use config.numberFormat\n        const format = (model.axis(channel) || model.legend(channel) || {}).format ||\n          model.config().numberFormat;\n\n        const startField = field(fieldDef, { datum: true, binSuffix: 'start' });\n        const endField = field(fieldDef, { datum: true, binSuffix: 'end' });\n\n        transform.push({\n          type: 'formula',\n          as: field(fieldDef, { binSuffix: 'range' }),\n          expr: `${numberFormatExpr(startField, format)} + ' - ' + ${numberFormatExpr(endField, format)}`\n        });\n      }\n      // FIXME: current merging logic can produce redundant transforms when a field is binned for color and for non-color\n      const key = hash(bin) + '_' + fieldDef.field + 'oc:' + hasDiscreteDomainOrHasLegend;\n      binComponent[key] = transform;\n    }\n    return binComponent;\n  }, {});\n}\n\nexport const bin: DataComponentCompiler<Dict<VgTransform[]>> = {\n  parseUnit: parse,\n\n  parseFacet: function(model: FacetModel) {\n    let binComponent = parse(model);\n\n    const childDataComponent = model.child().component.data;\n\n    // If child doesn't have its own data source, then merge\n    if (!childDataComponent.source) {\n      // FIXME: current merging logic can produce redundant transforms when a field is binned for color and for non-color\n      extend(binComponent, childDataComponent.bin);\n      delete childDataComponent.bin;\n    }\n    return binComponent;\n  },\n\n  parseLayer: function (model: LayerModel) {\n    let binComponent = parse(model);\n\n    model.children().forEach((child) => {\n      const childDataComponent = child.component.data;\n\n      // If child doesn't have its own data source, then merge\n      if (!childDataComponent.source) {\n        extend(binComponent, childDataComponent.bin);\n        delete childDataComponent.bin;\n      }\n    });\n\n    return binComponent;\n  },\n\n  assemble: function (component: Dict<VgTransform[]>) {\n    return flatten(vals(component));\n  }\n};\n","import {SOURCE} from '../../data';\nimport {FieldDef} from '../../fielddef';\nimport {Formula} from '../../transform';\nimport {Dict, StringSet} from '../../util';\nimport {VgData, VgSort, VgTransform} from '../../vega.schema';\n\nimport {FacetModel} from './../facet';\nimport {LayerModel} from './../layer';\nimport {Model} from './../model';\nimport {UnitModel} from './../unit';\n\nimport {source} from './source';\nimport {formatParse} from './formatparse';\nimport {nullFilter} from './nullfilter';\nimport {filter} from './filter';\nimport {bin} from './bin';\nimport {formula} from './formula';\nimport {pathOrder} from './pathorder';\nimport {nonPositiveFilter} from './nonpositivefilter';\nimport {summary} from './summary';\nimport {stack, StackComponent} from './stack';\nimport {timeUnit} from './timeunit';\n\n/**\n * Composable component instance of a model's data.\n */\nexport interface DataComponent {\n  source: VgData;\n\n  /** Mapping from field name to primitive data type.  */\n  formatParse: Dict<string>;\n\n  /** String set of fields for null filtering */\n  nullFilter: Dict<FieldDef>;\n\n  /** Hashset of a formula object */\n  calculate: Dict<Formula>;\n\n  /** Filter test expression */\n  filter: string;\n\n  /** Dictionary mapping a bin parameter hash to transforms of the binned field */\n  bin: Dict<VgTransform[]>;\n\n  /** Dictionary mapping an output field name (hash) to the time unit transform  */\n  timeUnit: Dict<VgTransform>;\n\n  /** String set of fields to be filtered */\n  nonPositiveFilter: Dict<boolean>;\n\n  /** Sort order to apply at the end */\n  pathOrder: VgSort;\n\n  /**\n   * Stack transforms to be applied.\n   */\n  stack: StackComponent;\n\n  /** Array of summary component object for producing summary (aggregate) data source */\n  summary: SummaryComponent[];\n}\n\n/**\n * Composable component for a model's summary data\n */\nexport interface SummaryComponent {\n  /** Name of the summary data source */\n  name: string;\n\n  /** String set for all dimension fields  */\n  dimensions: StringSet;\n\n  /** dictionary mapping field name to string set of aggregate ops */\n  measures: Dict<StringSet>;\n}\n\n// TODO: split this file into multiple files and remove this linter flag\n/* tslint:disable:no-use-before-declare */\n\nexport function parseUnitData(model: UnitModel): DataComponent {\n  return {\n    formatParse: formatParse.parseUnit(model),\n    nullFilter: nullFilter.parseUnit(model),\n    filter: filter.parseUnit(model),\n    nonPositiveFilter: nonPositiveFilter.parseUnit(model),\n    pathOrder: pathOrder.parseUnit(model),\n\n    source: source.parseUnit(model),\n    bin: bin.parseUnit(model),\n    calculate: formula.parseUnit(model),\n    timeUnit: timeUnit.parseUnit(model),\n    summary: summary.parseUnit(model),\n    stack: stack.parseUnit(model)\n  };\n}\n\nexport function parseFacetData(model: FacetModel): DataComponent {\n  return {\n    formatParse: formatParse.parseFacet(model),\n    nullFilter: nullFilter.parseFacet(model),\n    filter: filter.parseFacet(model),\n    nonPositiveFilter: nonPositiveFilter.parseFacet(model),\n    pathOrder: pathOrder.parseFacet(model),\n\n    source: source.parseFacet(model),\n    bin: bin.parseFacet(model),\n    calculate: formula.parseFacet(model),\n    timeUnit: timeUnit.parseFacet(model),\n    summary: summary.parseFacet(model),\n    stack: stack.parseFacet(model)\n  };\n}\n\nexport function parseLayerData(model: LayerModel): DataComponent {\n  return {\n    // filter and formatParse could cause us to not be able to merge into parent\n    // so let's parse them first\n    filter: filter.parseLayer(model),\n    formatParse: formatParse.parseLayer(model),\n    nullFilter: nullFilter.parseLayer(model),\n    nonPositiveFilter: nonPositiveFilter.parseLayer(model),\n    pathOrder: pathOrder.parseLayer(model),\n\n    // everything after here does not affect whether we can merge child data into parent or not\n    source: source.parseLayer(model),\n    bin: bin.parseLayer(model),\n    calculate: formula.parseLayer(model),\n    timeUnit: timeUnit.parseLayer(model),\n    summary: summary.parseLayer(model),\n    stack: stack.parseLayer(model)\n  };\n}\n\n/* tslint:enable:no-use-before-declare */\n\n/**\n * Creates Vega Data array from a given compiled model and append all of them to the given array\n *\n * @param  model\n * @param  data array\n * @return modified data array\n */\nexport function assembleData(model: Model, data: VgData[]) {\n  const dataComponent = model.component.data;\n\n  const sourceData = source.assemble(dataComponent);\n  if (sourceData) {\n    data.push(sourceData);\n  }\n\n  summary.assemble(dataComponent.summary || [], model.dataName(SOURCE)).forEach(function(summaryData) {\n    data.push(summaryData);\n  });\n\n  // nonPositiveFilter\n  const nonPositiveFilterTransform = nonPositiveFilter.assemble(dataComponent.nonPositiveFilter);\n  if (nonPositiveFilterTransform.length > 0) {\n    if (data.length > 0) {\n      const dataTable = data[data.length - 1];\n      dataTable.transform = (dataTable.transform || []).concat(nonPositiveFilterTransform);\n    } else { /* istanbul ignore else: should never reach here */\n      throw new Error('Invalid nonPositiveFilter not merged');\n    }\n  }\n\n  // stack\n  const stackData = stack.assemble(dataComponent.stack);\n  if (stackData) {\n    data.push(stackData);\n  }\n\n  // Path Order\n  const pathOrderCollectTransform = pathOrder.assemble(dataComponent.pathOrder);\n  if (pathOrderCollectTransform) {\n    const dataTable = data[data.length - 1];\n    if (data.length > 0) {\n      dataTable.transform = (dataTable.transform || []).concat([pathOrderCollectTransform]);\n    } else { /* istanbul ignore else: should never reach here */\n      throw new Error('Invalid path order collect transform not added');\n    }\n  }\n\n  return data;\n}\n","import {DataComponentCompiler} from './base';\n\nimport {expression} from '../../filter';\nimport {isArray} from '../../util';\n\nimport {FacetModel} from '../facet';\nimport {LayerModel} from '../layer';\nimport {Model} from '../model';\n\n/**\n * @param v value to be converted into Vega Expression\n * @param timeUnit\n * @return Vega Expression of the value v. This could be one of:\n * - a timestamp value of datetime object\n * - a timestamp value of casted single time unit value\n * - stringified value\n */\n\nfunction parse(model: Model): string {\n  const filter = model.filter();\n  if (isArray(filter)) {\n    return '(' +\n      filter.map((f) => expression(f))\n        .filter((f) => f !==undefined)\n        .join(') && (') +\n      ')';\n  } else if (filter) {\n    return expression(filter);\n  }\n  return undefined;\n}\n\nexport const filter: DataComponentCompiler<string> = {\n  parseUnit: parse,\n\n  parseFacet: function(model: FacetModel) {\n    let filterComponent = parse(model);\n\n    const childDataComponent = model.child().component.data;\n\n    // If child doesn't have its own data source but has filter, then merge\n    if (!childDataComponent.source && childDataComponent.filter) {\n      // merge by adding &&\n      filterComponent =\n        (filterComponent ? filterComponent + ' && ' : '') +\n        childDataComponent.filter;\n      delete childDataComponent.filter;\n    }\n    return filterComponent;\n  },\n\n  parseLayer: function(model: LayerModel) {\n    // Note that this `filter.parseLayer` method is called before `source.parseLayer`\n    let filterComponent = parse(model);\n    model.children().forEach((child) => {\n      const childDataComponent = child.component.data;\n      if (model.compatibleSource(child) && childDataComponent.filter && childDataComponent.filter === filterComponent) {\n        // same filter in child so we can just delete it\n        delete childDataComponent.filter;\n      }\n    });\n    return filterComponent;\n  },\n\n  assemble: function(filterComponent: string) {\n    return filterComponent ? [{\n      type: 'filter',\n      expr: filterComponent\n    }] : [];\n  }\n};\n","import {DataComponentCompiler} from './base';\n\nimport {isDateTime, DateTime} from '../../datetime';\nimport {isUrlData} from '../../data';\nimport {FieldDef, isCount} from '../../fielddef';\nimport {isOneOfFilter, isEqualFilter, isRangeFilter} from '../../filter';\nimport {QUANTITATIVE, TEMPORAL} from '../../type';\nimport {extend, differ, keys, isArray, isNumber, isString, Dict} from '../../util';\n\nimport {FacetModel} from './../facet';\nimport {LayerModel} from './../layer';\nimport {Model} from './../model';\n\nfunction parse(model: Model): Dict<string> {\n  const calcFieldMap = (model.calculate() || []).reduce(function(fieldMap, formula) {\n    fieldMap[formula.as] = true;\n    return fieldMap;\n  }, {});\n\n  let parseComponent: Dict<string> = {};\n\n  // Parse filter fields\n  let filter = model.filter();\n  if (!isArray(filter)) {\n    filter = [filter];\n  }\n  filter.forEach(f => {\n    let val: string | number | boolean | DateTime = null;\n    // For EqualFilter, just use the equal property.\n    // For RangeFilter and OneOfFilter, all array members should have\n    // the same type, so we only use the first one.\n    if (isEqualFilter(f)) {\n      val = f.equal;\n    } else if (isRangeFilter(f)) {\n      val = f.range[0];\n    } else if (isOneOfFilter(f)) {\n      val = (f.oneOf || f['in'])[0];\n    } // else -- for filter expression, we can't infer anything\n\n    if (!!val) {\n      if (isDateTime(val)) {\n        parseComponent[f['field']] = 'date';\n      } else if (isNumber(val)) {\n        parseComponent[f['field']] = 'number';\n      } else if (isString(val)) {\n        parseComponent[f['field']] = 'string';\n      }\n    }\n  });\n\n  // Parse encoded fields\n  model.forEach(function(fieldDef: FieldDef) {\n    if (fieldDef.type === TEMPORAL) {\n      parseComponent[fieldDef.field] = 'date';\n    } else if (fieldDef.type === QUANTITATIVE) {\n      if (isCount(fieldDef) || calcFieldMap[fieldDef.field]) {\n        return;\n      }\n      parseComponent[fieldDef.field] = 'number';\n    }\n  });\n\n  // Custom parse should override inferred parse\n  const data = model.data();\n  if (data && isUrlData(data) && data.format && data.format.parse) {\n    const parse = data.format.parse;\n    keys(parse).forEach((field) => {\n      parseComponent[field] = parse[field];\n    });\n  }\n\n  return parseComponent;\n}\n\nexport const formatParse: DataComponentCompiler<Dict<string>> = {\n  parseUnit: parse,\n\n  parseFacet: function(model: FacetModel) {\n    let parseComponent = parse(model);\n\n    // If child doesn't have its own data source, but has its own parse, then merge\n    const childDataComponent = model.child().component.data;\n    if (!childDataComponent.source && childDataComponent.formatParse) {\n      extend(parseComponent, childDataComponent.formatParse);\n      delete childDataComponent.formatParse;\n    }\n    return parseComponent;\n  },\n\n  parseLayer: function(model: LayerModel) {\n    // note that we run this before source.parseLayer\n    let parseComponent = parse(model);\n    model.children().forEach((child) => {\n      const childDataComponent = child.component.data;\n      if (model.compatibleSource(child) && !differ(childDataComponent.formatParse, parseComponent)) {\n        // merge parse up if the child does not have an incompatible parse\n        extend(parseComponent, childDataComponent.formatParse);\n        delete childDataComponent.formatParse;\n      }\n    });\n    return parseComponent;\n  },\n\n  // identity function\n  assemble: function (x) {return x;}\n};\n","import {DataComponentCompiler} from './base';\n\nimport {Formula} from '../../transform';\nimport {extend, vals, hash, Dict} from '../../util';\n\nimport {FacetModel} from './../facet';\nimport {LayerModel} from './../layer';\nimport {Model} from './../model';\n\nfunction parse(model: Model): Dict<Formula> {\n  return (model.calculate() || []).reduce(function(formulaComponent, formula) {\n    formulaComponent[hash(formula)] = formula;\n    return formulaComponent;\n  }, {});\n}\n\nexport const formula: DataComponentCompiler<Dict<Formula>> = {\n  parseUnit: parse,\n\n  parseFacet: function(model: FacetModel): Dict<Formula> {\n    let formulaComponent = parse(model);\n\n    const childDataComponent = model.child().component.data;\n\n    // If child doesn't have its own data source, then merge\n    if (!childDataComponent.source) {\n      extend(formulaComponent, childDataComponent.calculate);\n      delete childDataComponent.calculate;\n    }\n    return formulaComponent;\n  },\n\n  parseLayer: function(model: LayerModel): Dict<Formula> {\n    let formulaComponent = parse(model);\n    model.children().forEach((child) => {\n      const childDataComponent = child.component.data;\n      if (!childDataComponent.source && childDataComponent.calculate) {\n        extend(formulaComponent || {}, childDataComponent.calculate);\n        delete childDataComponent.calculate;\n      }\n    });\n    return formulaComponent;\n  },\n\n  assemble: function(component: Dict<Formula>) {\n    return vals(component).reduce(function(transform: any, f: any) {\n      transform.push(extend({ type: 'formula' }, f));\n      return transform;\n    }, []);\n  }\n};\n","import {DataComponentCompiler} from './base';\n\nimport {ScaleType} from '../../scale';\nimport {extend, keys, differ, Dict} from '../../util';\n\nimport {FacetModel} from './../facet';\nimport {LayerModel} from './../layer';\nimport {Model} from './../model';\n\n\nexport const nonPositiveFilter: DataComponentCompiler<Dict<boolean>> = {\n  parseUnit: function(model: Model): Dict<boolean> {\n    return model.channels().reduce(function(nonPositiveComponent, channel) {\n      const scale = model.scale(channel);\n      if (!model.field(channel) || !scale) {\n        // don't set anything\n        return nonPositiveComponent;\n      }\n      nonPositiveComponent[model.field(channel)] = scale.type === ScaleType.LOG;\n      return nonPositiveComponent;\n    }, {});\n  },\n\n  parseFacet: function(model: FacetModel) {\n    const childDataComponent = model.child().component.data;\n\n    // If child doesn't have its own data source, then consider merging\n    if (!childDataComponent.source) {\n      // For now, let's assume it always has union scale\n      const nonPositiveFilterComponent = childDataComponent.nonPositiveFilter;\n      delete childDataComponent.nonPositiveFilter;\n      return nonPositiveFilterComponent;\n    }\n    return {};\n  },\n\n  parseLayer: function(model: LayerModel) {\n    // note that we run this before source.parseLayer\n    let nonPositiveFilterComponent = {};\n\n    model.children().forEach((child) => {\n      const childDataComponent = child.component.data;\n      if (model.compatibleSource(child) && !differ(childDataComponent.nonPositiveFilter, nonPositiveFilterComponent)) {\n        extend(nonPositiveFilterComponent, childDataComponent.nonPositiveFilter);\n        delete childDataComponent.nonPositiveFilter;\n      }\n    });\n\n    return nonPositiveFilterComponent;\n  },\n\n  assemble: function(nonPositiveFilterComponent: Dict<boolean>) {\n    if (nonPositiveFilterComponent) {\n      return keys(nonPositiveFilterComponent).filter((field) => {\n        // Only filter fields (keys) with value = true\n        return nonPositiveFilterComponent[field];\n      }).map(function(field) {\n        return {\n          type: 'filter',\n          expr: 'datum[\"' + field + '\"] > 0'\n        };\n      });\n    }\n    return [];\n  }\n};\n","import {DataComponentCompiler} from './base';\n\nimport {FieldDef} from '../../fielddef';\nimport {QUANTITATIVE, TEMPORAL} from '../../type';\nimport {contains, extend, keys, differ, Dict} from '../../util';\n\nimport {FacetModel} from './../facet';\nimport {LayerModel} from './../layer';\nimport {Model} from './../model';\n\nconst DEFAULT_NULL_FILTERS = {\n  nominal: false,\n  ordinal: false,\n  quantitative: true,\n  temporal: true\n};\n\n/** Return Hashset of fields for null filtering (key=field, value = true). */\nfunction parse(model: Model): Dict<FieldDef> {\n  const filterInvalid = model.filterInvalid();\n\n  return model.reduce(function(aggregator: Dict<FieldDef>, fieldDef: FieldDef) {\n    if (fieldDef.field !== '*') { // Ignore * for count(*) fields.\n      if (filterInvalid ||\n        (filterInvalid === undefined && fieldDef.field && DEFAULT_NULL_FILTERS[fieldDef.type])) {\n        aggregator[fieldDef.field] = fieldDef;\n      } else {\n        // define this so we know that we don't filter nulls for this field\n        // this makes it easier to merge into parents\n        aggregator[fieldDef.field] = null;\n      }\n    }\n    return aggregator;\n  }, {});\n}\n\nexport const nullFilter: DataComponentCompiler<Dict<FieldDef>> = {\n  parseUnit: parse,\n\n  parseFacet: function(model: FacetModel) {\n    let nullFilterComponent = parse(model);\n\n    const childDataComponent = model.child().component.data;\n\n    // If child doesn't have its own data source, then merge\n    if (!childDataComponent.source) {\n      extend(nullFilterComponent, childDataComponent.nullFilter);\n      delete childDataComponent.nullFilter;\n    }\n    return nullFilterComponent;\n  },\n\n  parseLayer: function(model: LayerModel) {\n    // note that we run this before source.parseLayer\n\n    // FIXME: null filters are not properly propagated right now\n    let nullFilterComponent = parse(model);\n\n    model.children().forEach((child) => {\n      const childDataComponent = child.component.data;\n      if (model.compatibleSource(child) && !differ<FieldDef>(childDataComponent.nullFilter, nullFilterComponent)) {\n        extend(nullFilterComponent, childDataComponent.nullFilter);\n        delete childDataComponent.nullFilter;\n      }\n    });\n\n    return nullFilterComponent;\n  },\n\n  assemble: function(component: Dict<FieldDef>) {\n    const filters = keys(component).reduce((_filters, field) => {\n      const fieldDef = component[field];\n      if (fieldDef !== null) {\n        _filters.push('datum[\"' + fieldDef.field + '\"] !== null');\n        if (contains([QUANTITATIVE, TEMPORAL], fieldDef.type)) {\n          // TODO(https://github.com/vega/vega-lite/issues/1436):\n          // We can be even smarter and add NaN filter for N,O that are numbers\n          // based on the `parse` property once we have it.\n          _filters.push('!isNaN(datum[\"'+ fieldDef.field + '\"])');\n        }\n      }\n      return _filters;\n    }, []);\n\n    return filters.length > 0 ?\n      [{\n        type: 'filter',\n        expr: filters.join(' && ')\n      }] : [];\n  }\n};\n","import * as stringify from 'json-stable-stringify';\n\nimport {DataComponentCompiler} from './base';\n\nimport {isAggregate} from '../../encoding';\nimport {field} from '../../fielddef';\nimport {isSortField} from '../../sort';\nimport {VgSort} from '../../vega.schema';\nimport {contains} from '../../util';\n\nimport {sortParams} from '../common';\nimport {FacetModel} from '../facet';\nimport {LayerModel} from '../layer';\nimport {UnitModel} from '../unit';\n\nexport const pathOrder: DataComponentCompiler<VgSort> = {\n  parseUnit: function(model: UnitModel): VgSort {\n    if (contains(['line', 'area'], model.mark())) {\n      if (model.mark() === 'line' && model.channelHasField('order')) {\n        // For only line, sort by the order field if it is specified.\n        return sortParams(model.encoding().order);\n      } else {\n        // For both line and area, we sort values based on dimension by default\n        const dimensionChannel: 'x' | 'y' = model.config().mark.orient === 'horizontal' ? 'y' : 'x';\n        const sort = model.sort(dimensionChannel);\n        const sortField = isSortField(sort) ?\n          field({\n            // FIXME: this op might not already exist?\n            // FIXME: what if dimensionChannel (x or y) contains custom domain?\n            aggregate: isAggregate(model.encoding()) ? sort.op : undefined,\n            field: sort.field\n          }) :\n          model.field(dimensionChannel, {binSuffix: 'start'});\n\n        return {\n          field: sortField,\n          order: 'descending'\n        };\n      }\n\n    }\n    return null;\n  },\n\n  parseFacet: function(model: FacetModel) {\n    const childDataComponent = model.child().component.data;\n\n    // If child doesn't have its own data source, then consider merging\n    if (!childDataComponent.source) {\n      // For now, let's assume it always has union scale\n      const pathOrderComponent = childDataComponent.pathOrder;\n      delete childDataComponent.pathOrder;\n      return pathOrderComponent;\n    }\n    return null;\n  },\n\n  parseLayer: function(model: LayerModel) {\n    // note that we run this before source.parseLayer\n    let pathOrderComponent: VgSort = null;\n    let stringifiedPathOrder: string = null;\n\n    for (let child of model.children()) {\n      const childDataComponent = child.component.data;\n      if (model.compatibleSource(child) && childDataComponent.pathOrder !== null) {\n        if (pathOrderComponent === null) {\n          pathOrderComponent = childDataComponent.pathOrder;\n          stringifiedPathOrder = stringify(pathOrderComponent);\n        } else if (stringifiedPathOrder !== stringify(childDataComponent.pathOrder)) {\n          pathOrderComponent = null;\n          break;\n        }\n      }\n    }\n\n    if (pathOrderComponent !== null) {\n      // If we merge pathOrderComponent, remove them from children.\n      for (let child of model.children()) {\n        delete child.component.data.pathOrder;\n      }\n    }\n\n    return pathOrderComponent;\n  },\n\n  assemble: function(pathOrderComponent: VgSort) {\n    if (pathOrderComponent) {\n      return {\n        type: 'collect',\n        sort: pathOrderComponent\n      };\n    }\n    return null;\n  }\n};\n","import {DataFormat, SOURCE, isInlineData, isUrlData} from '../../data';\nimport {contains, extend} from '../../util';\nimport {VgData} from '../../vega.schema';\n\nimport {FacetModel} from '../facet';\nimport {LayerModel} from '../layer';\nimport {Model} from './../model';\n\nimport {DataComponent} from './data';\nimport {nullFilter} from './nullfilter';\nimport {filter} from './filter';\nimport {bin} from './bin';\nimport {formula} from './formula';\nimport {timeUnit} from './timeunit';\n\nexport namespace source {\n  function parse(model: Model): VgData {\n    let data = model.data();\n\n    if (data) {\n      // If data is explicitly provided\n\n      let sourceData: VgData = { name: model.dataName(SOURCE) };\n      if (isInlineData(data)) {\n        sourceData.values = data.values;\n        sourceData.format = { type: 'json' };\n      } else if (isUrlData(data)) {\n        sourceData.url = data.url;\n\n        // Extract extension from URL using snippet from\n        // http://stackoverflow.com/questions/680929/how-to-extract-extension-from-filename-string-in-javascript\n        let defaultExtension = /(?:\\.([^.]+))?$/.exec(sourceData.url)[1];\n        if (!contains(['json', 'csv', 'tsv', 'topojson'], defaultExtension)) {\n          defaultExtension = 'json';\n        }\n        const dataFormat: DataFormat = data.format || {};\n\n        // For backward compatibility for former `data.formatType` property\n        const formatType: DataFormat = dataFormat.type || data['formatType'];\n        sourceData.format =\n          extend(\n            { type: formatType ? formatType : defaultExtension },\n            dataFormat.property ? { property: dataFormat.property } : {},\n            // Feature and mesh are two mutually exclusive properties\n            dataFormat.feature ?\n              { feature : dataFormat.feature } :\n            dataFormat.mesh ?\n              { mesh : dataFormat.mesh } :\n              {}\n          );\n      }\n\n      return sourceData;\n    } else if (!model.parent()) {\n      // If data is not explicitly provided but the model is a root,\n      // need to produce a source as well\n      return { name: model.dataName(SOURCE) };\n    }\n    return undefined;\n  }\n\n  export const parseUnit: (model: Model) => VgData = parse;\n\n  export function parseFacet(model: FacetModel) {\n    let sourceData = parse(model);\n    if (!model.child().component.data.source) {\n      // If the child does not have its own source, have to rename its source.\n      model.child().renameData(model.child().dataName(SOURCE), model.dataName(SOURCE));\n    }\n\n    return sourceData;\n  }\n\n  export function parseLayer(model: LayerModel) {\n    let sourceData = parse(model);\n    model.children().forEach((child) => {\n      const childData = child.component.data;\n\n      if (model.compatibleSource(child)) {\n        // we cannot merge if the child has filters defined even after we tried to move them up\n        const canMerge = !childData.filter && !childData.formatParse && !childData.nullFilter;\n        if (canMerge) {\n          // rename source because we can just remove it\n          child.renameData(child.dataName(SOURCE), model.dataName(SOURCE));\n          delete childData.source;\n        } else {\n          // child does not have data defined or the same source so just use the parents source\n          childData.source = {\n            name: child.dataName(SOURCE),\n            source: model.dataName(SOURCE)\n          };\n        }\n      }\n    });\n    return sourceData;\n  }\n\n  export function assemble(component: DataComponent) {\n    if (component.source) {\n      let sourceData: VgData = component.source;\n\n      if (component.formatParse) {\n        component.source.format = component.source.format || {};\n        component.source.format.parse = component.formatParse;\n      }\n\n      sourceData.transform = [].concat(\n        formula.assemble(component.calculate),\n        nullFilter.assemble(component.nullFilter),\n        filter.assemble(component.filter),\n        bin.assemble(component.bin),\n        timeUnit.assemble(component.timeUnit)\n      );\n\n      return sourceData;\n    }\n    return null;\n  }\n}\n","import {DataComponentCompiler} from './base';\n\nimport {FacetModel} from './../facet';\nimport {LayerModel} from './../layer';\nimport {UnitModel} from './../unit';\n\nimport {sortParams} from '../common';\nimport {STACKED, SUMMARY} from '../../data';\nimport {FieldDef, field} from '../../fielddef';\nimport {hasDiscreteDomain} from '../../scale';\nimport {StackOffset} from '../../stack';\nimport {contains} from '../../util';\nimport {VgData, VgSort, VgStackTransform, VgImputeTransform} from '../../vega.schema';\n\nexport interface StackComponent {\n  /**\n   * Name of the output stacked data source\n   */\n  name: string;\n\n  /**\n   * Name of the input source data for stacked data source\n   */\n  source: string;\n\n  /**\n   * Grouping fields for stacked charts.  This includes one of x- or 'y-field and may include faceted field.\n   */\n  groupby: string[];\n\n  /**\n   * Stack measure's field\n   */\n  field: string;\n\n  /**\n   * Level of detail fields for each level in the stacked charts such as color or detail.\n   */\n  stackby: string[];\n\n  /**\n   * Field that determines order of levels in the stacked charts.\n   */\n  sort: VgSort;\n\n  /** Mode for stacking marks. */\n  offset: StackOffset;\n\n  /**\n   * Whether to impute the data before stacking.\n   */\n  impute: boolean;\n}\n\n\nfunction getStackByFields(model: UnitModel) {\n  const stackProperties = model.stack();\n\n  return stackProperties.stackBy.reduce((fields, by) => {\n    const channel = by.channel;\n    const fieldDef = by.fieldDef;\n\n    const scale = model.scale(channel);\n    const _field = field(fieldDef, {\n      binSuffix: scale && hasDiscreteDomain(scale.type) ? 'range' : 'start'\n    });\n    if (!!_field) {\n      fields.push(_field);\n    }\n    return fields;\n  }, [] as string[]);\n}\n\n/**\n * Stack data compiler\n */\nexport const stack: DataComponentCompiler<StackComponent> = {\n\n  parseUnit: function(model: UnitModel): StackComponent {\n    const stackProperties = model.stack();\n    if (!stackProperties) {\n      return undefined;\n    }\n\n    const groupby = [];\n    if (stackProperties.groupbyChannel) {\n      const groupbyFieldDef = model.fieldDef(stackProperties.groupbyChannel);\n      if (groupbyFieldDef.bin) {\n        // For Bin, we need to add both start and end to ensure that both get imputed\n        // and included in the stack output (https://github.com/vega/vega-lite/issues/1805).\n        groupby.push(model.field(stackProperties.groupbyChannel, {binSuffix: 'start'}));\n        groupby.push(model.field(stackProperties.groupbyChannel, {binSuffix: 'end'}));\n      } else {\n        groupby.push(model.field(stackProperties.groupbyChannel));\n      }\n    }\n\n    const stackby = getStackByFields(model);\n    const orderDef = model.encoding().order;\n\n    let sort: VgSort;\n    if (orderDef) {\n      sort = sortParams(orderDef);\n    } else {\n      // default = descending by stackFields\n      // FIXME is the default here correct for binned fields?\n      sort = stackby.reduce((s, field) => {\n        s.field.push(field);\n        s.order.push('descending');\n        return s;\n      }, {field:[], order: []});\n    }\n\n    return {\n      name: model.dataName(STACKED),\n      source: model.dataName(SUMMARY),\n      groupby: groupby,\n      field: model.field(stackProperties.fieldChannel),\n      stackby: stackby,\n      sort: sort,\n      offset: stackProperties.offset,\n      impute: contains(['area', 'line'], model.mark())\n    };\n  },\n\n  parseLayer: function(_: LayerModel): StackComponent {\n    // FIXME: merge if identical\n    // FIXME: Correctly support facet of layer of stack.\n    return undefined;\n  },\n\n  parseFacet: function(model: FacetModel): StackComponent {\n    const child = model.child();\n    const childDataComponent = child.component.data;\n    // FIXME: Correctly support facet of layer of stack.\n    if (childDataComponent.stack) {\n      let stackComponent = childDataComponent.stack;\n\n      const newName = model.dataName(STACKED);\n      child.renameData(stackComponent.name, newName);\n      stackComponent.name = newName;\n\n      // Refer to facet's summary instead (always summary because stacked only works with aggregation)\n      stackComponent.source = model.dataName(SUMMARY);\n\n      // Add faceted field to groupby\n      stackComponent.groupby = model.reduce((groupby: string[], fieldDef: FieldDef) => {\n        const facetedField = field(fieldDef, {binSuffix: 'start'});\n        if (!contains(groupby, facetedField)) {\n          groupby.push(facetedField);\n        }\n        return groupby;\n      }, stackComponent.groupby);\n\n      delete childDataComponent.stack;\n      return stackComponent;\n    }\n    return undefined;\n  },\n  assemble: (stackComponent: StackComponent): VgData => {\n    if (!stackComponent) {\n      return undefined;\n    }\n\n    let transform: (VgStackTransform|VgImputeTransform)[] = [];\n    // Impute\n    if (stackComponent.impute) {\n      transform.push({\n        type: 'impute',\n        field: stackComponent.field,\n        groupby: stackComponent.stackby,\n        orderby: stackComponent.groupby,\n        method: 'value',\n        value: 0\n      });\n    }\n\n    // Stack\n    transform.push({\n      type: 'stack',\n      groupby: stackComponent.groupby,\n      field: stackComponent.field,\n      sort: stackComponent.sort,\n      as: [\n        stackComponent.field + '_start',\n        stackComponent.field + '_end'\n      ],\n      offset: stackComponent.offset\n    });\n\n    return {\n      name: stackComponent.name,\n      source: stackComponent.source,\n      transform: transform\n    };\n  }\n};\n","import {AggregateOp} from '../../aggregate';\nimport {SUMMARY} from '../../data';\nimport {field, FieldDef} from '../../fielddef';\nimport {keys, vals, reduce, hash, Dict, StringSet} from '../../util';\nimport {VgData} from '../../vega.schema';\n\nimport {FacetModel} from './../facet';\nimport {LayerModel} from './../layer';\nimport {Model} from './../model';\n\nimport {SummaryComponent} from './data';\n\n\nexport namespace summary {\n  function addDimension(dims: { [field: string]: boolean }, fieldDef: FieldDef) {\n    if (fieldDef.bin) {\n      dims[field(fieldDef, { binSuffix: 'start' })] = true;\n      dims[field(fieldDef, { binSuffix: 'end' })] = true;\n\n      // const scale = model.scale(channel);\n      // if (scaleType(scale, fieldDef, channel, model.mark()) === ScaleType.ORDINAL) {\n      // also produce bin_range if the binned field use ordinal scale\n      dims[field(fieldDef, { binSuffix: 'range' })] = true;\n      // }\n    } else {\n      dims[field(fieldDef)] = true;\n    }\n    return dims;\n  }\n\n  export function parseUnit(model: Model): SummaryComponent[] {\n    /* string set for dimensions */\n    let dims: StringSet = {};\n\n    /* dictionary mapping field name => dict set of aggregation functions */\n    let meas: Dict<StringSet> = {};\n\n    model.forEach(function(fieldDef: FieldDef) {\n      if (fieldDef.aggregate) {\n        if (fieldDef.aggregate === AggregateOp.COUNT) {\n          meas['*'] = meas['*'] || {};\n          /* tslint:disable:no-string-literal */\n          meas['*']['count'] = true;\n          /* tslint:enable:no-string-literal */\n        } else {\n          meas[fieldDef.field] = meas[fieldDef.field] || {};\n          meas[fieldDef.field][fieldDef.aggregate] = true;\n        }\n      } else {\n        addDimension(dims, fieldDef);\n      }\n    });\n\n    return [{\n      name: model.dataName(SUMMARY),\n      dimensions: dims,\n      measures: meas\n    }];\n  }\n\n  export function parseFacet(model: FacetModel): SummaryComponent[] {\n    const childDataComponent = model.child().component.data;\n\n    // FIXME: this could be incorrect for faceted layer charts.\n\n    // If child doesn't have its own data source but has a summary data source, merge\n    if (!childDataComponent.source && childDataComponent.summary) {\n      let summaryComponents = childDataComponent.summary.map(function(summaryComponent) {\n        // add facet fields as dimensions\n        summaryComponent.dimensions = model.reduce(addDimension, summaryComponent.dimensions);\n\n        const summaryNameWithoutPrefix = summaryComponent.name.substr(model.child().name('').length);\n        model.child().renameData(summaryComponent.name, summaryNameWithoutPrefix);\n        summaryComponent.name = summaryNameWithoutPrefix;\n        return summaryComponent;\n      });\n\n      delete childDataComponent.summary;\n      return summaryComponents;\n    }\n    return [];\n  }\n\n  function mergeMeasures(parentMeasures: Dict<Dict<boolean>>, childMeasures: Dict<Dict<boolean>>) {\n    for (const field in childMeasures) {\n      if (childMeasures.hasOwnProperty(field)) {\n        // when we merge a measure, we either have to add an aggregation operator or even a new field\n        const ops = childMeasures[field];\n        for (const op in ops) {\n          if (ops.hasOwnProperty(op)) {\n            if (field in parentMeasures) {\n              // add operator to existing measure field\n              parentMeasures[field][op] = true;\n            } else {\n              parentMeasures[field] = { op: true };\n            }\n          }\n        }\n      }\n    }\n  }\n\n  export function parseLayer(model: LayerModel): SummaryComponent[] {\n    // Index by the fields we are grouping by\n    let summaries = {};\n\n    // Combine summaries for children that don't have a distinct source\n    // (either having its own data source, or its own tranformation of the same data source).\n    model.children().forEach((child) => {\n      const childDataComponent = child.component.data;\n      if (!childDataComponent.source && childDataComponent.summary) {\n        // Merge the summaries if we can\n        childDataComponent.summary.forEach((childSummary) => {\n          // The key is a hash based on the dimensions;\n          // we use it to find out whether we have a summary that uses the same group by fields.\n          const key = hash(childSummary.dimensions);\n          if (key in summaries) {\n            // yes, there is a summary hat we need to merge into\n            // we know that the dimensions are the same so we only need to merge the measures\n            mergeMeasures(summaries[key].measures, childSummary.measures);\n          } else {\n            // give the summary a new name\n            childSummary.name = model.dataName(SUMMARY) + '_' + keys(summaries).length;\n            summaries[key] = childSummary;\n          }\n\n          // remove summary from child\n          child.renameData(child.dataName(SUMMARY), summaries[key].name);\n          delete childDataComponent.summary;\n        });\n      }\n    });\n\n    return vals(summaries);\n  }\n\n  /**\n   * Assemble the summary. Needs a rename function because we cannot guarantee that the\n   * parent data before the children data.\n   */\n  export function assemble(component: SummaryComponent[], sourceName: string): VgData[] {\n    return component.reduce(function(summaryData, summaryComponent) {\n      const dims = summaryComponent.dimensions;\n      const meas = summaryComponent.measures;\n\n      if (keys(meas).length > 0) { // has aggregate\n        const groupby = keys(dims);\n        const transform = reduce(meas, function(t, fnDictSet, field) {\n          const ops = keys(fnDictSet);\n          for (const op of ops) {\n            t.fields.push(field);\n            t.ops.push(op);\n          }\n          return t;\n        }, {\n          type: 'aggregate',\n          groupby: groupby,\n          fields: [],\n          ops: []\n        });\n\n        summaryData.push({\n          name: summaryComponent.name,\n          source: sourceName,\n          transform: [transform]\n        });\n      }\n      return summaryData;\n    }, []);\n  }\n}\n","import {DataComponentCompiler} from './base';\n\nimport {field, FieldDef} from '../../fielddef';\nimport {fieldExpr} from '../../timeunit';\nimport {TEMPORAL} from '../../type';\nimport {extend, vals, Dict} from '../../util';\nimport {VgFormulaTransform} from '../../vega.schema';\n\nimport {FacetModel} from '../facet';\nimport {LayerModel} from '../layer';\nimport {Model} from '../model';\n\nfunction parse(model: Model): Dict<VgFormulaTransform> {\n  return model.reduce(function(timeUnitComponent: Dict<VgFormulaTransform>, fieldDef: FieldDef) {\n    if (fieldDef.type === TEMPORAL && fieldDef.timeUnit) {\n\n      const hash = field(fieldDef);\n\n      timeUnitComponent[hash] = {\n        type: 'formula',\n        as: field(fieldDef),\n        expr: fieldExpr(fieldDef.timeUnit, fieldDef.field)\n      };\n    }\n    return timeUnitComponent;\n  }, {});\n}\n\nexport const timeUnit: DataComponentCompiler<Dict<VgFormulaTransform>> = {\n  parseUnit: parse,\n\n  parseFacet: function (model: FacetModel) {\n    let timeUnitComponent = parse(model);\n\n    const childDataComponent = model.child().component.data;\n\n    // If child doesn't have its own data source, then merge\n    if (!childDataComponent.source) {\n      extend(timeUnitComponent, childDataComponent.timeUnit);\n      delete childDataComponent.timeUnit;\n    }\n    return timeUnitComponent;\n  },\n\n  parseLayer: function(model: LayerModel) {\n    let timeUnitComponent = parse(model);\n    model.children().forEach((child) => {\n      const childDataComponent = child.component.data;\n      if (!childDataComponent.source) {\n        extend(timeUnitComponent, childDataComponent.timeUnit);\n        delete childDataComponent.timeUnit;\n      }\n    });\n    return timeUnitComponent;\n  },\n  assemble: function(component: Dict<VgFormulaTransform>) {\n    // just join the values, which are already transforms\n    return vals(component);\n  }\n};\n","import * as log from '../log';\n\nimport {AxisOrient, Axis} from '../axis';\nimport {COLUMN, ROW, X, Y, Channel} from '../channel';\nimport {defaultConfig, Config} from '../config';\nimport {Facet} from '../facet';\nimport {forEach} from '../encoding';\nimport {FieldDef, isDimension, normalize} from '../fielddef';\nimport {Scale} from '../scale';\nimport {FacetSpec} from '../spec';\nimport {contains, extend, keys, vals, flatten, duplicate, mergeDeep, Dict} from '../util';\nimport {VgData, VgEncodeEntry} from '../vega.schema';\nimport {StackProperties} from '../stack';\n\nimport {parseMainAxis, parseGridAxis, parseAxisComponent} from './axis/parse';\nimport {gridShow} from './axis/rules';\nimport {buildModel} from './common';\nimport {assembleData, parseFacetData} from './data/data';\nimport {assembleLayout, parseFacetLayout} from './layout';\nimport {Model} from './model';\n\nimport initScale from './scale/init';\nimport parseScaleComponent from './scale/parse';\n\n/**\n * Prefix for special data sources for driving column's axis group.\n */\n\nexport const COLUMN_AXES_DATA_PREFIX = 'column-';\n\n/**\n * Prefix for special data sources for driving row's axis group.\n */\nexport const ROW_AXES_DATA_PREFIX = 'row-';\n\nexport class FacetModel extends Model {\n  private readonly _facet: Facet;\n\n  private readonly _child: Model;\n\n  private readonly _spacing: {\n    row?: number;\n    column?: number;\n  } = {};\n\n  constructor(spec: FacetSpec, parent: Model, parentGivenName: string) {\n    super(spec, parent, parentGivenName);\n\n    // Config must be initialized before child as it gets cascaded to the child\n    const config = this._config = this._initConfig(spec.config, parent);\n\n    const child  = this._child = buildModel(spec.spec, this, this.name('child'));\n\n    const facet  = this._facet = this._initFacet(spec.facet);\n    this._scale  = this._initScaleAndSpacing(facet, config);\n    this._axis   = this._initAxis(facet, config, child);\n    this._legend = {};\n  }\n\n  private _initConfig(specConfig: Config, parent: Model) {\n    return mergeDeep(duplicate(defaultConfig), parent ? parent.config() : {}, specConfig);\n  }\n\n  private _initFacet(facet: Facet) {\n    // clone to prevent side effect to the original spec\n    facet = duplicate(facet);\n\n    forEach(facet, function(fieldDef: FieldDef, channel: Channel) {\n      if (!contains([ROW, COLUMN], channel)) {\n        // Drop unsupported channel\n        log.warn(log.message.incompatibleChannel(channel, 'facet'));\n        delete facet[channel];\n        return;\n      }\n\n      // TODO: array of row / column ?\n      if (fieldDef.field === undefined) { // TODO: datum\n        log.warn(log.message.emptyFieldDef(fieldDef, channel));\n        delete facet[channel];\n        return;\n      }\n\n      // Convert type to full, lowercase type, or augment the fieldDef with a default type if missing.\n      normalize(fieldDef, channel);\n\n      // TODO: move this warning into normalize\n      if (!isDimension(fieldDef)) {\n        log.warn(log.message.facetChannelShouldBeDiscrete(channel));\n      }\n    });\n    return facet;\n  }\n\n  private _initScaleAndSpacing(facet: Facet, config: Config): Dict<Scale> {\n    const model = this;\n    return [ROW, COLUMN].reduce(function(_scale, channel) {\n      if (facet[channel]) {\n        _scale[channel] = initScale(\n          channel, facet[channel], config,\n          undefined, // Facet doesn't have one single mark\n          undefined, // TODO(#1647): support width / height here\n          [] // There is no xyRangeSteps here and there is no need to input\n        );\n\n        model._spacing[channel] = spacing(facet[channel].scale || {}, model, config);\n      }\n      return _scale;\n    }, {});\n  }\n\n  private _initAxis(facet: Facet, config: Config, child: Model): Dict<Axis> {\n    const model = this;\n    return [ROW, COLUMN].reduce(function(_axis, channel) {\n      if (facet[channel]) {\n        const axisSpec = facet[channel].axis;\n        if (axisSpec !== false) {\n          const modelAxis = _axis[channel] = extend({},\n            config.facet.axis,\n            axisSpec === true ? {} : axisSpec || {}\n          );\n\n          if (channel === ROW) {\n            const yAxis: any = child.axis(Y);\n            if (yAxis && yAxis.orient !== AxisOrient.RIGHT && !modelAxis.orient) {\n              modelAxis.orient = AxisOrient.RIGHT;\n            }\n            if (model.hasDescendantWithFieldOnChannel(X) && !modelAxis.labelAngle) {\n              modelAxis.labelAngle = modelAxis.orient === AxisOrient.RIGHT ? 90 : 270;\n            }\n          }\n        }\n      }\n      return _axis;\n    }, {});\n  }\n\n  public facet() {\n    return this._facet;\n  }\n\n  public channelHasField(channel: Channel): boolean {\n    return !!this._facet[channel];\n  }\n\n  public child() {\n    return this._child;\n  }\n\n  public children(): Model[] {\n    return [this._child];\n  }\n\n  private hasSummary() {\n    const summary = this.component.data.summary;\n    for (const s of summary) {\n      if (keys(s.measures).length > 0) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  public facetedTable(): string {\n    // FIXME: revise if the suffix should be 'data'\n    return 'faceted-' + this.name('data');\n  }\n\n  public dataTable(): string {\n    // FIXME: shouldn't we apply data renaming here?\n    if (this.component.data.stack) {\n      return 'stacked';\n    }\n    if (this.hasSummary()) {\n      return 'summary';\n    }\n    return 'source';\n  }\n\n  public fieldDef(channel: Channel): FieldDef {\n    return this.facet()[channel];\n  }\n\n  public stack(): StackProperties {\n    return null; // this is only a property for UnitModel\n  }\n\n  public parseData() {\n    this.child().parseData();\n    this.component.data = parseFacetData(this);\n  }\n\n  public parseSelectionData() {\n    // TODO: @arvind can write this\n    // We might need to split this into compileSelectionData and compileSelectionSignals?\n  }\n\n  public parseLayoutData() {\n    this.child().parseLayoutData();\n    this.component.layout = parseFacetLayout(this);\n  }\n\n  public parseScale() {\n    const child = this.child();\n    const model = this;\n\n    child.parseScale();\n\n    // TODO: support scales for field reference of parent data (e.g., for SPLOM)\n\n    // First, add scale for row and column.\n    let scaleComponent = this.component.scale = parseScaleComponent(this);\n\n    // Then, move shared/union from its child spec.\n    keys(child.component.scale).forEach(function(channel) {\n      // TODO: correctly implement independent scale\n      if (true) { // if shared/union scale\n        scaleComponent[channel] = child.component.scale[channel];\n\n        // for each scale, need to rename\n        vals(scaleComponent[channel]).forEach(function(scale: any) {\n          const scaleNameWithoutPrefix = scale.name.substr(child.name('').length);\n          const newName = model.scaleName(scaleNameWithoutPrefix, true);\n          child.renameScale(scale.name, newName);\n          scale.name = newName;\n        });\n\n        // Once put in parent, just remove the child's scale.\n        delete child.component.scale[channel];\n      }\n    });\n  }\n\n  public parseMark() {\n    this.child().parseMark();\n\n    this.component.mark = extend(\n      {\n        name: this.name('cell'),\n        type: 'group',\n        from: extend(\n          {\n            facet: {\n              name: this.facetedTable(),\n              data: this.dataTable(),\n              groupby: [].concat(\n                this.channelHasField(ROW) ? [this.field(ROW)] : [],\n                this.channelHasField(COLUMN) ? [this.field(COLUMN)] : []\n              )\n            }\n          }\n        ),\n        encode: {\n          update: getFacetGroupProperties(this)\n        }\n      },\n      // FIXME: move this call to assembleMarks()\n      // Call child's assembleGroup to add marks, scales, axes, and legends.\n      // Note that we can call child's assembleGroup() here because parseMark()\n      // is the last method in compile() and thus the child is completely compiled\n      // at this point.\n      this.child().assembleGroup()\n    );\n  }\n\n  public parseAxis() {\n    this.child().parseAxis();\n    this.component.axis = parseAxisComponent(this, [ROW, COLUMN]);\n  }\n\n  public parseAxisGroup() {\n    // TODO: with nesting, we might need to consider calling child\n    // this.child().parseAxisGroup();\n\n    const xAxisGroup = parseAxisGroups(this, X);\n    const yAxisGroup = parseAxisGroups(this, Y);\n\n    this.component.axisGroup = extend(\n      xAxisGroup ? {x: xAxisGroup} : {},\n      yAxisGroup ? {y: yAxisGroup} : {}\n    );\n  }\n\n  public parseGridGroup() {\n    // TODO: with nesting, we might need to consider calling child\n    // this.child().parseGridGroup();\n\n    const child = this.child();\n\n    this.component.gridGroup = extend(\n      !child.channelHasField(X) && this.channelHasField(COLUMN) ? { column: getColumnGridGroups(this) } : {},\n      !child.channelHasField(Y) && this.channelHasField(ROW) ? { row: getRowGridGroups(this) } : {}\n    );\n  }\n\n  public parseLegend() {\n    this.child().parseLegend();\n\n    // TODO: support legend for independent non-position scale across facets\n    // TODO: support legend for field reference of parent data (e.g., for SPLOM)\n\n    // For now, assuming that non-positional scales are always shared across facets\n    // Thus, just move all legends from its child\n    this.component.legend = this._child.component.legend;\n    this._child.component.legend = {};\n  }\n\n  public assembleParentGroupProperties(): any {\n    return null;\n  }\n\n  public assembleData(data: VgData[]): VgData[] {\n    // Prefix traversal – parent data might be referred by children data\n    assembleData(this, data);\n    this._child.assembleData(data);\n    assembleAxesGroupData(this, data);\n\n    return data;\n  }\n\n\n  public assembleLayout(layoutData: VgData[]): VgData[] {\n    // Postfix traversal – layout is assembled bottom-up\n    this._child.assembleLayout(layoutData);\n    return assembleLayout(this, layoutData);\n  }\n\n  public assembleMarks(): any[] {\n    return [].concat(\n      // axisGroup is a mapping to VgMarkGroup\n      vals(this.component.axisGroup),\n      flatten(vals(this.component.gridGroup)),\n      this.component.mark\n    );\n  }\n\n  public channels() {\n    return [ROW, COLUMN];\n  }\n\n  protected mapping() {\n    return this.facet();\n  }\n\n  public spacing(channel: Channel) {\n    return this._spacing[channel];\n  }\n\n  public isFacet() {\n    return true;\n  }\n}\n\nexport function hasSubPlotWithXy(model: FacetModel) {\n  return model.hasDescendantWithFieldOnChannel('x') ||\n    model.hasDescendantWithFieldOnChannel('y');\n}\n\nexport function spacing(scale: Scale, model: FacetModel, config: Config) {\n  if (scale.spacing !== undefined) {\n    return scale.spacing;\n  }\n\n  if (!hasSubPlotWithXy(model)) {\n    // If there is no subplot with x/y, it's a simple table so there should be no spacing.\n    return 0;\n  }\n  return config.scale.facetSpacing;\n}\n\nfunction getFacetGroupProperties(model: FacetModel) {\n  const child = model.child();\n  const mergedCellConfig = extend({}, child.config().cell, child.config().facet.cell);\n\n  return extend({\n      x: model.channelHasField(COLUMN) ? {\n          scale: model.scaleName(COLUMN),\n          field: model.field(COLUMN),\n          // offset by the spacing / 2\n          offset: model.spacing(COLUMN) / 2\n        } : {value: model.config().scale.facetSpacing / 2},\n\n      y: model.channelHasField(ROW) ? {\n        scale: model.scaleName(ROW),\n        field: model.field(ROW),\n        // offset by the spacing / 2\n        offset: model.spacing(ROW) / 2\n      } : {value: model.config().scale.facetSpacing / 2},\n\n      width: {field: {parent: model.child().sizeName('width')}},\n      height: {field: {parent: model.child().sizeName('height')}}\n    },\n    hasSubPlotWithXy(model) ? child.assembleParentGroupProperties(mergedCellConfig) : {}\n  );\n}\n\n// TODO: move the rest of the file src/compile/facet/*.ts\n\n/**\n * Add data for driving row/column axes when there are both row and column\n * Note that we don't have to deal with these in the parse step at all\n * because these items never get merged with any other items.\n */\nexport function assembleAxesGroupData(model: FacetModel, data: VgData[]) {\n  if (model.facet().column) {\n    data.push({\n      name: COLUMN_AXES_DATA_PREFIX + model.dataTable(),\n      source: model.dataTable(),\n      transform: [{\n        type: 'aggregate',\n        groupby: [model.field(COLUMN)]\n      }]\n    });\n  }\n\n  if (model.facet().row) {\n    data.push({\n      name: ROW_AXES_DATA_PREFIX + model.dataTable(),\n      source: model.dataTable(),\n      transform: [{\n        type: 'aggregate',\n        groupby: [model.field(ROW)]\n      }]\n    });\n  }\n  return data;\n}\n\nfunction parseAxisGroups(model: FacetModel, channel: 'x' | 'y') {\n  // TODO: add a case where inner spec is not a unit (facet/layer/concat)\n  let axisGroup: any = null;\n\n  const child = model.child();\n  if (child.channelHasField(channel)) {\n    if (child.axis(channel)) {\n      if (true) { // the channel has shared axes\n\n        // add a group for the shared axes\n        axisGroup = getSharedAxisGroup(model, channel);\n\n        if (child.axis(channel) && gridShow(child, channel)) { // show inner grid\n          // add inner axis (aka axis that shows only grid to )\n          child.component.axis[channel] = [parseGridAxis(channel, child)];\n        } else {\n          // Delete existing child axes\n          delete child.component.axis[channel];\n        }\n      } else {\n        // TODO: implement independent axes support\n      }\n    }\n  }\n  return axisGroup;\n}\n\n\nexport function getSharedAxisGroup(model: FacetModel, channel: 'x' | 'y'): VgEncodeEntry {\n  const isX = channel === 'x' ;\n  const facetChannel = isX ? 'column' : 'row';\n  const hasFacet = !!model.facet()[facetChannel];\n  const dataPrefix = isX ? COLUMN_AXES_DATA_PREFIX : ROW_AXES_DATA_PREFIX;\n\n  let axesGroup:VgEncodeEntry = {\n    name: model.name(channel + '-axes'),\n    type: 'group'\n  };\n\n  if (hasFacet) {\n    // Need to drive this with special data source that has one item for each column/row value.\n\n    // TODO: We might only need to drive this with special data source if there are both row and column\n    // However, it might be slightly difficult as we have to merge this with the main group.\n    axesGroup.from = {data: dataPrefix + model.dataTable()};\n  }\n\n  if (isX) {\n    axesGroup.encode = {\n      update: {\n        width: {field: {parent: model.child().sizeName('width')}},\n        height: {field: {group: 'height'}},\n        x: hasFacet ? {\n          scale: model.scaleName(COLUMN),\n          field: model.field(COLUMN),\n          // offset by the spacing\n          offset: model.spacing(COLUMN) / 2\n        } : {\n          // TODO: support custom spacing here\n          // offset by the spacing\n          value: model.config().scale.facetSpacing / 2\n        }\n      }\n    };\n  } else {\n    axesGroup.encode = {\n      update: {\n        width: {field: {group: 'width'}},\n        height: {field: {parent: model.child().sizeName('height')}},\n        y: hasFacet ? {\n          scale: model.scaleName(ROW),\n          field: model.field(ROW),\n          // offset by the spacing\n          offset: model.spacing(ROW) / 2\n        } : {\n          // offset by the spacing\n          value: model.config().scale.facetSpacing / 2\n        }\n      }\n    };\n  }\n\n  axesGroup.axes = [parseMainAxis(channel, model.child())];\n  return axesGroup;\n}\n\n\nfunction getRowGridGroups(model: Model): any[] { // TODO: VgMarks\n  const facetGridConfig = model.config().facet.grid;\n\n  const rowGrid = {\n    name: model.name('row-grid'),\n    type: 'rule',\n    from: {\n      data: ROW_AXES_DATA_PREFIX + model.dataTable()\n    },\n    encode: {\n      update: {\n        y: {\n          scale: model.scaleName(ROW),\n          field: model.field(ROW)\n        },\n        x: {value: 0, offset: -facetGridConfig.offset },\n        x2: {field: {group: 'width'}, offset: facetGridConfig.offset },\n        stroke: { value: facetGridConfig.color },\n        strokeOpacity: { value: facetGridConfig.opacity },\n        strokeWidth: {value: 0.5}\n      }\n    }\n  };\n\n  return [rowGrid, {\n    name: model.name('row-grid-end'),\n    type: 'rule',\n    encode: {\n      update: {\n        y: { field: {group: 'height'}},\n        x: {value: 0, offset: -facetGridConfig.offset },\n        x2: {field: {group: 'width'}, offset: facetGridConfig.offset },\n        stroke: { value: facetGridConfig.color },\n        strokeOpacity: { value: facetGridConfig.opacity },\n        strokeWidth: {value: 0.5}\n      }\n    }\n  }];\n}\n\nfunction getColumnGridGroups(model: Model): any { // TODO: VgMarks\n  const facetGridConfig = model.config().facet.grid;\n\n  const columnGrid = {\n    name: model.name('column-grid'),\n    type: 'rule',\n    from: {\n      data: COLUMN_AXES_DATA_PREFIX + model.dataTable()\n    },\n    encode: {\n      update: {\n        x: {\n          scale: model.scaleName(COLUMN),\n          field: model.field(COLUMN)\n        },\n        y: {value: 0, offset: -facetGridConfig.offset},\n        y2: {field: {group: 'height'}, offset: facetGridConfig.offset },\n        stroke: { value: facetGridConfig.color },\n        strokeOpacity: { value: facetGridConfig.opacity },\n        strokeWidth: {value: 0.5}\n      }\n    }\n  };\n\n  return [columnGrid,  {\n    name: model.name('column-grid-end'),\n    type: 'rule',\n    encode: {\n      update: {\n        x: { field: {group: 'width'}},\n        y: {value: 0, offset: -facetGridConfig.offset},\n        y2: {field: {group: 'height'}, offset: facetGridConfig.offset },\n        stroke: { value: facetGridConfig.color },\n        strokeOpacity: { value: facetGridConfig.opacity },\n        strokeWidth: {value: 0.5}\n      }\n    }\n  }];\n}\n","import {Channel} from '../channel';\nimport {defaultConfig, CellConfig, Config} from '../config';\nimport {FieldDef} from '../fielddef';\nimport {LayerSpec} from '../spec';\nimport {StackProperties} from '../stack';\nimport {FILL_STROKE_CONFIG} from '../mark';\nimport {keys, duplicate, mergeDeep, flatten, vals} from '../util';\nimport {VgData, VgEncodeEntry} from '../vega.schema';\nimport {isUrlData} from '../data';\n\nimport {assembleData, parseLayerData} from './data/data';\nimport {applyConfig, buildModel} from './common';\nimport {assembleLayout, parseLayerLayout} from './layout';\nimport {Model} from './model';\nimport {UnitModel} from './unit';\n\nimport {ScaleComponents} from './scale/scale';\nimport {unionDomains} from './scale/domain';\n\n\nexport class LayerModel extends Model {\n  private _children: UnitModel[];\n\n  /**\n   * Fixed width for the unit visualization.\n   * If undefined (e.g., for ordinal scale), the width of the\n   * visualization will be calculated dynamically.\n   */\n  private readonly _width: number;\n\n  /**\n   * Fixed height for the unit visualization.\n   * If undefined (e.g., for ordinal scale), the height of the\n   * visualization will be calculated dynamically.\n   */\n  private readonly _height: number;\n\n\n  constructor(spec: LayerSpec, parent: Model, parentGivenName: string) {\n    super(spec, parent, parentGivenName);\n\n    this._width = spec.width;\n    this._height = spec.height;\n\n    this._config = this._initConfig(spec.config, parent);\n    this._children = spec.layers.map((layer, i) => {\n      // we know that the model has to be a unit model because we pass in a unit spec\n      return buildModel(layer, this, this.name('layer_' + i)) as UnitModel;\n    });\n  }\n\n  private _initConfig(specConfig: Config, parent: Model) {\n    return mergeDeep(duplicate(defaultConfig), specConfig, parent ? parent.config() : {});\n  }\n\n  public get width(): number {\n    return this._width;\n  }\n\n  public get height(): number {\n    return this._height;\n  }\n\n  public channelHasField(_: Channel): boolean {\n    // layer does not have any channels\n    return false;\n  }\n\n  public children() {\n    return this._children;\n  }\n\n  public hasDiscreteScale(channel: Channel) {\n    // since we assume shared scales we can just ask the first child\n    return this._children[0].hasDiscreteScale(channel);\n  }\n\n  public dataTable() {\n    // FIXME: don't just use the first child\n    return this._children[0].dataTable();\n  }\n\n  public fieldDef(_: Channel): FieldDef {\n    return null; // layer does not have field defs\n  }\n\n  public stack(): StackProperties {\n    return null; // this is only a property for UnitModel\n  }\n\n  public parseData() {\n    this._children.forEach((child) => {\n      child.parseData();\n    });\n    this.component.data = parseLayerData(this);\n  }\n\n  public parseSelectionData() {\n    // TODO: @arvind can write this\n    // We might need to split this into compileSelectionData and compileSelectionSignals?\n  }\n\n  public parseLayoutData() {\n    // TODO: correctly union ordinal scales rather than just using the layout of the first child\n    this._children.forEach(child => {\n      child.parseLayoutData();\n    });\n    this.component.layout = parseLayerLayout(this);\n  }\n\n  public parseScale(this: LayerModel) {\n    const model = this;\n\n    let scaleComponent = this.component.scale = {};\n\n    this._children.forEach(function(child) {\n      child.parseScale();\n\n      // FIXME(#1602): correctly implement independent scale\n      // Also need to check whether the scales are actually compatible, e.g. use the same sort or throw error\n      if (true) { // if shared/union scale\n        keys(child.component.scale).forEach(function(channel) {\n          let childScales: ScaleComponents = child.component.scale[channel];\n          if (!childScales) {\n            // the child does not have any scales so we have nothing to merge\n            return;\n          }\n\n          const modelScales: ScaleComponents = scaleComponent[channel];\n          if (modelScales && modelScales.main) {\n            // Scales are unioned by combining the domain of the main scale.\n            // Other scales that are used for ordinal legends are appended.\n\n            modelScales.main.domain = unionDomains(modelScales.main.domain, childScales.main.domain);\n            modelScales.binLegend = modelScales.binLegend ? modelScales.binLegend : childScales.binLegend;\n            modelScales.binLegendLabel = modelScales.binLegendLabel ? modelScales.binLegendLabel : childScales.binLegendLabel;\n          } else {\n            scaleComponent[channel] = childScales;\n          }\n\n          // rename child scales to parent scales\n          vals(childScales).forEach(function(scale: any) {\n            const scaleNameWithoutPrefix = scale.name.substr(child.name('').length);\n            const newName = model.scaleName(scaleNameWithoutPrefix, true);\n            child.renameScale(scale.name, newName);\n            scale.name = newName;\n          });\n\n          delete childScales[channel];\n        });\n      }\n    });\n  }\n\n  public parseMark() {\n    this._children.forEach(function(child) {\n      child.parseMark();\n    });\n  }\n\n  public parseAxis() {\n    let axisComponent = this.component.axis = {};\n\n    this._children.forEach(function(child) {\n      child.parseAxis();\n\n      // TODO: correctly implement independent axes\n      if (true) { // if shared/union scale\n        keys(child.component.axis).forEach(function(channel) {\n          // TODO: support multiple axes for shared scale\n\n          // just use the first axis definition for each channel\n          if (!axisComponent[channel]) {\n            axisComponent[channel] = child.component.axis[channel];\n          }\n        });\n      }\n    });\n  }\n\n  public parseAxisGroup(): void {\n    return null;\n  }\n\n  public parseGridGroup(): void {\n    return null;\n  }\n\n  public parseLegend() {\n    let legendComponent = this.component.legend = {};\n\n    this._children.forEach(function(child) {\n      child.parseLegend();\n\n      // TODO: correctly implement independent axes\n      if (true) { // if shared/union scale\n        keys(child.component.legend).forEach(function(channel) {\n          // just use the first legend definition for each channel\n          if (!legendComponent[channel]) {\n            legendComponent[channel] = child.component.legend[channel];\n          }\n        });\n      }\n    });\n  }\n\n  public assembleParentGroupProperties(cellConfig: CellConfig): VgEncodeEntry {\n    return applyConfig({}, cellConfig, FILL_STROKE_CONFIG.concat(['clip']));\n  }\n\n  public assembleData(data: VgData[]): VgData[] {\n    // Prefix traversal – parent data might be referred to by children data\n    assembleData(this, data);\n    this._children.forEach((child) => {\n      child.assembleData(data);\n    });\n    return data;\n  }\n\n  public assembleLayout(layoutData: VgData[]): VgData[] {\n    // Postfix traversal – layout is assembled bottom-up\n    this._children.forEach((child) => {\n      child.assembleLayout(layoutData);\n    });\n    return assembleLayout(this, layoutData);\n  }\n\n  public assembleMarks(): any[] {\n    // only children have marks\n    return flatten(this._children.map((child) => {\n      return child.assembleMarks();\n    }));\n  }\n\n  public channels(): Channel[] {\n    return [];\n  }\n\n  protected mapping(): any {\n    return null;\n  }\n\n  public isLayer() {\n    return true;\n  }\n\n  /**\n   * Returns true if the child either has no source defined or uses the same url.\n   * This is useful if you want to know whether it is possible to move a filter up.\n   *\n   * This function can only be called once th child has been parsed.\n   */\n  public compatibleSource(child: UnitModel) {\n    const data = this.data();\n    const childData = child.component.data;\n    const compatible = !childData.source || (data && isUrlData(data) && data.url === childData.source.url);\n    return compatible;\n  }\n}\n","\nimport {Channel, X, Y, ROW, COLUMN} from '../channel';\nimport {LAYOUT} from '../data';\nimport {hasDiscreteDomain} from '../scale';\nimport {Formula} from '../transform';\nimport {extend, keys, StringSet} from '../util';\nimport {VgData} from '../vega.schema';\n\nimport {FacetModel} from './facet';\nimport {LayerModel} from './layer';\nimport {Model} from './model';\nimport {UnitModel} from './unit';\n\n// FIXME: for nesting x and y, we need to declare x,y layout separately before joining later\n// For now, let's always assume shared scale\nexport interface LayoutComponent {\n  width: SizeComponent;\n  height: SizeComponent;\n}\n\nexport interface SizeComponent {\n  /** Field that we need to calculate distinct */\n  distinct: StringSet;\n\n  /** Array of formulas */\n  formula: Formula[];\n}\n\nexport function assembleLayout(model: Model, layoutData: VgData[]): VgData[] {\n  const layoutComponent = model.component.layout;\n  if (!layoutComponent.width && !layoutComponent.height) {\n    return layoutData; // Do nothing\n  }\n\n  if (true) { // if both are shared scale, we can simply merge data source for width and for height\n    const distinctFields = keys(extend(layoutComponent.width.distinct, layoutComponent.height.distinct));\n    const formula = layoutComponent.width.formula.concat(layoutComponent.height.formula)\n      .map(f => extend({type: 'formula'}, f));\n\n    return [\n      distinctFields.length > 0 ? {\n        name: model.dataName(LAYOUT),\n        source: model.dataTable(),\n        transform: [{\n          type: 'aggregate',\n          fields: distinctFields,\n          ops: distinctFields.map(() => 'distinct')\n        } as any].concat(formula)\n      } : {\n        name: model.dataName(LAYOUT),\n        values: [{}],\n        transform: formula\n      }\n    ];\n  }\n  // FIXME: implement\n  // otherwise, we need to join width and height (cross)\n}\n\n// FIXME: for nesting x and y, we need to declare x,y layout separately before joining later\n// For now, let's always assume shared scale\nexport function parseUnitLayout(model: UnitModel): LayoutComponent {\n  return {\n    width: parseUnitSizeLayout(model, X),\n    height: parseUnitSizeLayout(model, Y)\n  };\n}\n\nfunction parseUnitSizeLayout(model: UnitModel, channel: Channel): SizeComponent {\n  return {\n    distinct: getDistinct(model, channel),\n    formula: [{\n      as: model.channelSizeName(channel),\n      expr: unitSizeExpr(model, channel)\n    }]\n  };\n}\n\nexport function unitSizeExpr(model: UnitModel, channel: Channel): string {\n  const scale = model.scale(channel);\n  if (scale) {\n\n    if (hasDiscreteDomain(scale.type) && scale.rangeStep) {\n      // If the spec has top level size or specified rangeStep = fit, it will be undefined here.\n\n      const cardinality = cardinalityExpr(model, channel);\n      const paddingOuter = scale.paddingOuter !== undefined ? scale.paddingOuter : scale.padding;\n      const paddingInner = scale.type === 'band' ?\n        // only band has real paddingInner\n        (scale.paddingInner !== undefined ? scale.paddingInner : scale.padding) :\n        // For point, as calculated in https://github.com/vega/vega-scale/blob/master/src/band.js#L128,\n        // it's equivalent to have paddingInner = 1 since there is only n-1 steps between n points.\n        1;\n\n      let space = cardinality +\n        (paddingInner ? ` - ${paddingInner}` : '') +\n        (paddingOuter ? ` + 2*${paddingOuter}` : '');\n\n      // This formula is equivalent to\n      // space = count - inner + outer * 2\n      // range = rangeStep * (space > 0 ? space : 0)\n      // in https://github.com/vega/vega-encode/blob/master/src/Scale.js#L112\n      return `max(${space}, 0) * ${scale.rangeStep}`;\n    }\n  }\n  return (channel === X ? model.width : model.height) + '';\n}\n\nexport function parseFacetLayout(model: FacetModel): LayoutComponent {\n  return {\n    width: parseFacetSizeLayout(model, COLUMN),\n    height: parseFacetSizeLayout(model, ROW)\n  };\n}\n\nfunction parseFacetSizeLayout(model: FacetModel, channel: Channel): SizeComponent {\n  const childLayoutComponent = model.child().component.layout;\n  const sizeType = channel === ROW ? 'height' : 'width';\n  const childSizeComponent: SizeComponent = childLayoutComponent[sizeType];\n\n  if (true) { // assume shared scale\n    // For shared scale, we can simply merge the layout into one data source\n\n    const distinct = extend(getDistinct(model, channel), childSizeComponent.distinct);\n    const formula = childSizeComponent.formula.concat([{\n      as: model.channelSizeName(channel),\n      expr: facetSizeFormula(model, channel, model.child().channelSizeName(channel))\n    }]);\n\n    delete childLayoutComponent[sizeType];\n    return {\n      distinct: distinct,\n      formula: formula\n    };\n  }\n  // FIXME implement independent scale as well\n  // TODO: - also consider when children have different data source\n}\n\nfunction facetSizeFormula(model: FacetModel, channel: Channel, innerSize: string) {\n  if (model.channelHasField(channel)) {\n    return '(datum[\"' + innerSize + '\"] + ' + model.spacing(channel) + ')' + ' * ' + cardinalityExpr(model, channel);\n  } else {\n    return 'datum[\"' + innerSize + '\"] + ' + model.config().scale.facetSpacing; // need to add outer padding for facet\n  }\n}\n\nexport function parseLayerLayout(model: LayerModel): LayoutComponent {\n  return {\n    width: parseLayerSizeLayout(model, X),\n    height: parseLayerSizeLayout(model, Y)\n  };\n}\n\nfunction parseLayerSizeLayout(model: LayerModel, channel: Channel): SizeComponent {\n  if (true) {\n    // For shared scale, we can simply merge the layout into one data source\n    // TODO: don't just take the layout from the first child\n\n    const childLayoutComponent = model.children()[0].component.layout;\n    const sizeType = channel === Y ? 'height' : 'width';\n    const childSizeComponent: SizeComponent = childLayoutComponent[sizeType];\n\n    const distinct = childSizeComponent.distinct;\n    const formula: Formula[] = [{\n      as: model.channelSizeName(channel),\n      expr: childSizeComponent.formula[0].expr\n    }];\n\n    model.children().forEach((child) => {\n      delete child.component.layout[sizeType];\n    });\n\n    return {\n      distinct: distinct,\n      formula: formula\n    };\n  }\n}\n\nfunction getDistinct(model: Model, channel: Channel): StringSet {\n  if (model.channelHasField(channel) && model.hasDiscreteScale(channel)) {\n    const scale = model.scale(channel);\n    if (hasDiscreteDomain(scale.type) && !(scale.domain instanceof Array)) {\n      // if explicit domain is declared, use array length\n      const distinctField = model.field(channel);\n      let distinct: StringSet = {};\n      distinct[distinctField] = true;\n      return distinct;\n    }\n  }\n  return {};\n}\n\nexport function cardinalityExpr(model: Model, channel: Channel):string {\n  const scale = model.scale(channel);\n  if (scale.domain instanceof Array) {\n    return scale.domain.length + '';\n  }\n\n  return model.field(channel, {datum: true, prefix: 'distinct'});\n}\n","import {COLOR, SIZE, SHAPE, OPACITY, Channel} from '../../channel';\nimport {FieldDef, isValueDef} from '../../fielddef';\nimport {AREA, BAR, TICK, TEXT, LINE, POINT, CIRCLE, SQUARE, FILL_STROKE_CONFIG} from '../../mark';\nimport {hasContinuousDomain} from '../../scale';\nimport {TEMPORAL} from '../../type';\nimport {extend, keys, without} from '../../util';\n\nimport {VgValueRef} from '../../vega.schema';\n\nimport {applyMarkConfig, timeFormatExpression} from '../common';\nimport {BIN_LEGEND_LABEL_SUFFIX} from '../scale/scale';\nimport {UnitModel} from '../unit';\n\nexport function symbols(fieldDef: FieldDef, symbolsSpec: any, model: UnitModel, channel: Channel) {\n  let symbols:any = {};\n  const mark = model.mark();\n  const legend = model.legend(channel);\n\n  switch (mark) {\n    case BAR:\n    case TICK:\n    case TEXT:\n      symbols.shape = {value: 'square'};\n      break;\n    case CIRCLE:\n    case SQUARE:\n      symbols.shape = { value: mark };\n      break;\n    case POINT:\n    case LINE:\n    case AREA:\n      // use default circle\n      break;\n  }\n\n  const cfg = model.config();\n  const filled = cfg.mark.filled;\n\n  let config = channel === COLOR ?\n      /* For color's legend, do not set fill (when filled) or stroke (when unfilled) property from config because the legend's `fill` or `stroke` scale should have precedence */\n      without(FILL_STROKE_CONFIG, [ filled ? 'fill' : 'stroke', 'strokeDash', 'strokeDashOffset']) :\n      /* For other legend, no need to omit. */\n      without(FILL_STROKE_CONFIG, ['strokeDash', 'strokeDashOffset']);\n\n  config = without(config, ['strokeDash', 'strokeDashOffset']);\n\n  applyMarkConfig(symbols, model, config);\n\n  if (filled) {\n    symbols.strokeWidth = { value: 0 };\n  }\n\n  // Avoid override default mapping for opacity channel\n  if (channel === OPACITY) {\n    delete symbols.opacity;\n  }\n\n  let value: VgValueRef;\n  const colorDef = model.encoding().color;\n  if (isValueDef(colorDef)) {\n    value = { value: colorDef.value };\n  }\n\n  if (value !== undefined) {\n    // apply the value\n    if (filled) {\n      symbols.fill = value;\n    } else {\n      symbols.stroke = value;\n    }\n  } else if (channel !== COLOR) {\n    // For non-color legend, apply color config if there is no fill / stroke config.\n    // (For color, do not override scale specified!)\n    symbols[filled ? 'fill' : 'stroke'] = symbols[filled ? 'fill' : 'stroke'] ||\n      {value: cfg.mark.color};\n  }\n\n  if (legend.symbolColor !== undefined) {\n    symbols.fill = {value: legend.symbolColor};\n  } else if (symbols.fill === undefined) {\n    // fall back to mark config colors for legend fill\n    if (cfg.mark.fill !== undefined) {\n      symbols.fill = {value: cfg.mark.fill};\n    } else if (cfg.mark.stroke !== undefined) {\n      symbols.stroke = {value: cfg.mark.stroke};\n    }\n  }\n\n  if (channel !== SHAPE) {\n    if (legend.symbolShape !== undefined) {\n      symbols.shape = {value: legend.symbolShape};\n    } else if (cfg.point.shape !== undefined) {\n      symbols.shape = {value: cfg.point.shape};\n    }\n  }\n\n  if (channel !== SIZE) {\n    if (legend.symbolSize !== undefined) {\n      symbols.size = {value: legend.symbolSize};\n    }\n  }\n\n  if (fieldDef.bin && hasContinuousDomain(model.scale(channel).type)) {\n    const def = {\n      scale: model.scaleName(channel),\n      field: 'value'\n    };\n    switch (channel) {\n      case OPACITY:\n        symbols.opacity = def;\n        break;\n      case SIZE:\n        symbols.size = def;\n        break;\n      case COLOR:\n        symbols[filled ? 'fill' : 'stroke'] = def;\n        break;\n      default:\n        throw Error(`Legend for channel ${channel} not implemented`);\n    }\n  }\n\n  if (legend.symbolStrokeWidth !== undefined) {\n    symbols.strokeWidth = {value: legend.symbolStrokeWidth};\n  }\n\n  symbols = extend(symbols, symbolsSpec || {});\n\n  return keys(symbols).length > 0 ? symbols : undefined;\n}\n\nexport function labels(fieldDef: FieldDef, labelsSpec: any, model: UnitModel, channel: Channel) {\n  const legend = model.legend(channel);\n  const config = model.config();\n\n  let labels:any = {};\n\n  if (fieldDef.bin && hasContinuousDomain(model.scale(channel).type)) {\n    // Override label's text to map bin's quantitative value to range\n    labelsSpec = extend({\n      text: {\n        scale: model.scaleName(channel) + BIN_LEGEND_LABEL_SUFFIX,\n        field: 'value'\n      }\n    }, labelsSpec || {});\n  } else if (fieldDef.type === TEMPORAL) {\n    labelsSpec = extend({\n      text: {\n        signal: timeFormatExpression('datum.value', fieldDef.timeUnit, legend.format, legend.shortTimeLabels, config)\n      }\n    }, labelsSpec || {});\n  }\n\n  if (legend.labelAlign !== undefined) {\n    labels.align = {value: legend.labelAlign};\n  }\n\n  if (legend.labelColor !== undefined) {\n    labels.fill = {value: legend.labelColor};\n  }\n\n  if (legend.labelFont !== undefined) {\n    labels.font = {value: legend.labelFont};\n  }\n\n  if (legend.labelFontSize !== undefined) {\n    labels.fontSize = {value: legend.labelFontSize};\n  }\n\n  if (legend.labelBaseline !== undefined) {\n    labels.baseline = {value: legend.labelBaseline};\n  }\n\n  labels = extend(labels, labelsSpec || {});\n\n  return keys(labels).length > 0 ? labels : undefined;\n}\n\nexport function title(_: FieldDef, titleSpec: any, model: UnitModel, channel: Channel) {\n  const legend = model.legend(channel);\n\n  let titles:any = {};\n\n  if (legend.titleColor !== undefined) {\n    titles.fill = {value: legend.titleColor};\n  }\n\n  if (legend.titleFont !== undefined) {\n    titles.font = {value: legend.titleFont};\n  }\n\n  if (legend.titleFontSize !== undefined) {\n    titles.fontSize = {value: legend.titleFontSize};\n  }\n\n  if (legend.titleFontWeight !== undefined) {\n    titles.fontWeight = {value: legend.titleFontWeight};\n  }\n\n  titles = extend(titles, titleSpec || {});\n\n  return keys(titles).length > 0 ? titles : undefined;\n}\n","import {COLOR, SIZE, SHAPE, OPACITY, Channel} from '../../channel';\nimport {hasContinuousDomain} from '../../scale';\nimport {keys, Dict} from '../../util';\nimport {VgLegend} from '../../vega.schema';\n\nimport {numberFormat} from '../common';\nimport {BIN_LEGEND_SUFFIX} from '../scale/scale';\nimport {UnitModel} from '../unit';\n\nimport * as encode from './encode';\nimport * as rules from './rules';\n\nexport function parseLegendComponent(model: UnitModel): Dict<VgLegend> {\n  return [COLOR, SIZE, SHAPE, OPACITY].reduce(function(legendComponent, channel) {\n    if (model.legend(channel)) {\n      legendComponent[channel] = parseLegend(model, channel);\n    }\n    return legendComponent;\n  }, {});\n}\n\nfunction getLegendDefWithScale(model: UnitModel, channel: Channel): VgLegend {\n  // For binned field with continuous scale, use a special scale so we can overrride the mark props and labels\n  const suffix = model.fieldDef(channel).bin && hasContinuousDomain(model.scale(channel).type) ? BIN_LEGEND_SUFFIX : '';\n  switch (channel) {\n    case COLOR:\n      const scale = model.scaleName(COLOR) + suffix;\n      return model.config().mark.filled ? { fill: scale } : { stroke: scale };\n    case SIZE:\n      return { size: model.scaleName(SIZE) + suffix };\n    case SHAPE:\n      return { shape: model.scaleName(SHAPE) + suffix };\n    case OPACITY:\n      return { opacity: model.scaleName(OPACITY) + suffix };\n  }\n  return null;\n}\n\nexport function parseLegend(model: UnitModel, channel: Channel): VgLegend {\n  const fieldDef = model.fieldDef(channel);\n  const legend = model.legend(channel);\n  const config = model.config();\n\n  let def: VgLegend = getLegendDefWithScale(model, channel);\n\n  // 1.1 Add properties with special rules\n  def.title = rules.title(legend, fieldDef, config);\n  const format = numberFormat(fieldDef, legend.format, config, channel);\n  if (format) {\n    def.format = format;\n  }\n  const vals = rules.values(legend);\n  if (vals) {\n    def.values = vals;\n  }\n  const t = rules.type(legend, fieldDef, channel);\n  if (t) {\n    def.type = t;\n  }\n\n  // 1.2 Add properties without rules\n  ['offset', 'orient'].forEach(function(property) {\n    const value = legend[property];\n    if (value !== undefined) {\n      def[property] = value;\n    }\n  });\n\n  // 2) Add mark property definition groups\n  const encodeSpec = legend.encode || {};\n  ['title', 'symbols', 'legend', 'labels'].forEach(function(part) {\n    let value = encode[part] ?\n      encode[part](fieldDef, encodeSpec[part], model, channel) : // apply rule\n      encodeSpec[part]; // no rule -- just default values\n    if (value !== undefined && keys(value).length > 0) {\n      def.encode = def.encode || {};\n      def.encode[part] = {update: value};\n    }\n  });\n\n  return def;\n}\n","import {COLOR, Channel} from '../../channel';\nimport {Config} from '../../config';\nimport {DateTime, isDateTime, timestamp} from '../../datetime';\nimport {FieldDef} from '../../fielddef';\nimport {Legend} from '../../legend';\nimport {title as fieldTitle} from '../../fielddef';\nimport {TEMPORAL, QUANTITATIVE} from '../../type';\nimport {contains} from '../../util';\n\nexport function title(legend: Legend, fieldDef: FieldDef, config: Config) {\n  if (legend.title !== undefined) {\n    return legend.title;\n  }\n\n  return fieldTitle(fieldDef, config);\n}\n\nexport function values(legend: Legend) {\n  const vals = legend.values;\n  if (vals && isDateTime(vals[0])) {\n    return (vals as DateTime[]).map((dt) => {\n      // normalize = true as end user won't put 0 = January\n      return timestamp(dt, true);\n    });\n  }\n  return vals;\n}\n\nexport function type(legend: Legend, fieldDef: FieldDef, channel: Channel) {\n  if (legend.type) {\n    return legend.type;\n  }\n\n  if (channel === COLOR && !fieldDef.bin && !fieldDef.timeUnit && contains([QUANTITATIVE, TEMPORAL], fieldDef.type)) {\n    return 'gradient';\n  }\n  return undefined;\n}\n","import {X, X2, Y, Y2} from '../../channel';\nimport {VgEncodeEntry} from '../../vega.schema';\n\nimport {applyMarkConfig} from '../common';\nimport {applyColorAndOpacity} from './common';\nimport {UnitModel} from '../unit';\n\nimport {MarkCompiler} from './base';\nimport * as ref from './valueref';\n\nexport const area: MarkCompiler = {\n  markType: () => {\n    return 'area';\n  },\n  encodeEntry: (model: UnitModel) => {\n    let e: VgEncodeEntry = {};\n    const config = model.config();\n\n    // We should always have orient as we augment it in config.ts\n    const orient = config.mark.orient;\n    e.orient = { value: orient} ;\n\n    const stack = model.stack();\n\n    // TODO: refactor how refer to scale as discussed in https://github.com/vega/vega-lite/pull/1613\n\n    e.x = ref.stackable(X, model.encoding().x, model.scaleName(X), model.scale(X), stack, 'base');\n    e.y = ref.stackable(Y, model.encoding().y, model.scaleName(Y), model.scale(Y), stack, 'base');\n\n    // Have only x2 or y2 based on orientation\n    if (orient === 'horizontal') {\n      e.x2 = ref.stackable2(X2, model.encoding().x, model.encoding().x2, model.scaleName(X), model.scale(X), stack, 'base');\n    } else {\n      e.y2 = ref.stackable2(Y2, model.encoding().y, model.encoding().y2, model.scaleName(Y), model.scale(Y), stack, 'base');\n    }\n\n    applyColorAndOpacity(e, model);\n    applyMarkConfig(e, model, ['interpolate', 'tension']);\n    return e;\n  }\n};\n","import {X, Y, X2, Y2, SIZE} from '../../channel';\nimport {Config} from '../../config';\nimport {isFieldDef} from '../../fielddef';\nimport {Scale, ScaleType} from '../../scale';\nimport {StackProperties} from '../../stack';\nimport {extend} from '../../util';\nimport * as log from '../../log';\nimport {VgEncodeEntry} from '../../vega.schema';\n\nimport {applyColorAndOpacity} from './common';\nimport {UnitModel} from '../unit';\nimport {VgValueRef} from '../../vega.schema';\n\nimport {MarkCompiler} from './base';\nimport * as ref from './valueref';\n\nexport const bar: MarkCompiler = {\n  markType: () => {\n    return 'rect';\n  },\n  encodeEntry: (model: UnitModel) => {\n    const stack = model.stack();\n    let e: VgEncodeEntry = extend(\n      x(model, stack),\n      y(model, stack)\n    );\n    applyColorAndOpacity(e, model);\n    return e;\n  }\n};\n\nfunction x(model: UnitModel, stack: StackProperties) {\n  let e: VgEncodeEntry = {};\n  const config = model.config();\n  const orient = model.config().mark.orient;\n  const sizeDef = model.encoding().size;\n\n  const xDef = model.encoding().x;\n  const xScaleName = model.scaleName(X);\n  const xScale = model.scale(X);\n  // x, x2, and width -- we must specify two of these in all conditions\n  if (orient === 'horizontal') {\n    e.x = ref.stackable(X, xDef, xScaleName, model.scale(X), stack, 'base');\n    e.x2 = ref.stackable2(X2, xDef, model.encoding().x2, xScaleName, model.scale(X), stack, 'base');\n    return e;\n  } else { // vertical\n    if (isFieldDef(xDef)) {\n      if (xDef.bin && !sizeDef) {\n        // TODO: check scale type = linear\n\n        e.x2 = ref.bin(xDef, xScaleName, 'start', config.bar.binSpacing);\n        e.x = ref.bin(xDef, xScaleName, 'end');\n        return e;\n      } else if (xScale.type === ScaleType.BAND) {\n        // TODO: band scale doesn't support size yet\n        e.x = ref.fieldRef(xDef, xScaleName, {});\n        e.width = ref.band(xScaleName);\n        return e;\n      }\n    }\n    // sized bin, normal point-ordinal axis, quantitative x-axis, or no x\n    e.xc = ref.midPoint(X, xDef, xScaleName, model.scale(X),\n      extend(ref.midX(config), {offset: 1}) // TODO: config.singleBarOffset\n    );\n    e.width = ref.midPoint(SIZE, model.encoding().size, model.scaleName(SIZE), model.scale(SIZE),\n      defaultSizeRef(xScaleName, model.scale(X), config)\n    );\n    return e;\n  }\n}\n\nfunction y(model: UnitModel, stack: StackProperties) {\n  let e: VgEncodeEntry = {};\n  const config = model.config();\n  const orient = model.config().mark.orient;\n  const sizeDef = model.encoding().size;\n\n  const yDef = model.encoding().y;\n  const yScaleName = model.scaleName(Y);\n  const yScale = model.scale(Y);\n  // y, y2 & height -- we must specify two of these in all conditions\n  if (orient === 'vertical') {\n    e.y = ref.stackable(Y, model.encoding().y, yScaleName, model.scale(Y), stack, 'base');\n    e.y2 = ref.stackable2(Y2, model.encoding().y, model.encoding().y2, yScaleName, model.scale(Y), stack, 'base');\n    return e;\n  } else {\n    if (isFieldDef(yDef)) {\n      if (yDef.bin && !sizeDef) {\n        e.y2 = ref.bin(yDef, yScaleName, 'start');\n        e.y = ref.bin(yDef, yScaleName, 'end', config.bar.binSpacing);\n        return e;\n      } else if (yScale.type === ScaleType.BAND) {\n        // TODO: band scale doesn't support size yet\n        e.y = ref.fieldRef(yDef, yScaleName, {});\n        e.height = ref.band(yScaleName);\n        return e;\n      }\n    }\n    e.yc = ref.midPoint(Y, yDef, yScaleName, model.scale(Y),\n      ref.midY(config)\n    );\n    e.height = ref.midPoint(SIZE, model.encoding().size, model.scaleName(SIZE), model.scale(SIZE),\n      defaultSizeRef(yScaleName, model.scale(Y), config)\n    );\n    return e;\n  }\n}\n\nfunction defaultSizeRef(scaleName: string, scale: Scale, config: Config): VgValueRef {\n  if (config.bar.discreteBandSize) {\n    return {value: config.bar.discreteBandSize};\n  }\n\n  if (scale) {\n    if (scale.type === ScaleType.POINT) {\n      if (scale.rangeStep !== null) {\n        return {value: scale.rangeStep - 1};\n      }\n      log.warn(log.message.BAR_WITH_POINT_SCALE_AND_RANGESTEP_NULL);\n    } else if (scale.type === ScaleType.BAND) {\n      return ref.band(scaleName);\n    } else { // non-ordinal scale\n      return {value: config.bar.continuousBandSize};\n    }\n  }\n  if (config.scale.rangeStep && config.scale.rangeStep !== null) {\n    return {value: config.scale.rangeStep - 1};\n  }\n  // TODO: this should depends on cell's width / height?\n  return {value: 20};\n}\n\n","import {FILL_CONFIG, STROKE_CONFIG} from '../../mark';\nimport * as util from '../../util';\nimport {VgEncodeEntry} from '../../vega.schema';\n\nimport {applyMarkConfig} from '../common';\nimport {UnitModel} from '../unit';\n\nimport * as ref from './valueref';\n\n\nexport function applyColorAndOpacity(e: VgEncodeEntry, model: UnitModel) {\n  const config = model.config();\n  const filled = config.mark.filled;\n\n  // TODO: remove this once we correctly integrate theme\n  // Apply fill stroke config first so that color field / value can override\n  // fill / stroke\n  if (filled) {\n    applyMarkConfig(e, model, FILL_CONFIG);\n  } else {\n    applyMarkConfig(e, model, STROKE_CONFIG);\n  }\n\n  let colorRef = ref.midPoint('color', model.encoding().color, model.scaleName('color'), model.scale('color'), undefined);\n  let opacityRef = ref.midPoint('opacity', model.encoding().opacity, model.scaleName('opacity'), model.scale('opacity'), config.mark.opacity && {value: config.mark.opacity});\n\n  if (colorRef !== undefined) {\n    if (filled) {\n      e.fill = colorRef;\n    } else {\n      e.stroke = colorRef;\n    }\n  } else { // TODO: remove this once we correctly integrate theme\n    // apply color config if there is no fill / stroke config\n    e[filled ? 'fill' : 'stroke'] = e[filled ? 'fill' : 'stroke'] ||\n      {value: model.config().mark.color};\n  }\n\n  // If there is no fill, always fill symbols\n  // with transparent fills https://github.com/vega/vega-lite/issues/1316\n  if (!e.fill && util.contains(['bar', 'point', 'circle', 'square'], model.mark())) {\n    e.fill = {value: 'transparent'};\n  }\n\n  if (opacityRef) {\n    e.opacity = opacityRef;\n  }\n}\n","import {X, Y} from '../../channel';\nimport {Config} from '../../config';\nimport {ChannelDef, isValueDef} from '../../fielddef';\nimport {VgEncodeEntry} from '../../vega.schema';\n\nimport {applyMarkConfig} from '../common';\nimport {applyColorAndOpacity} from './common';\nimport {UnitModel} from '../unit';\n\nimport {MarkCompiler} from './base';\nimport * as ref from './valueref';\n\nexport const line: MarkCompiler = {\n  markType: () => {\n    return 'line';\n  },\n  encodeEntry: (model: UnitModel) => {\n    let e: VgEncodeEntry = {};\n    const config = model.config();\n    const stack = model.stack();\n\n    // TODO: refactor how refer to scale as discussed in https://github.com/vega/vega-lite/pull/1613\n\n    e.x = ref.stackable(X, model.encoding().x, model.scaleName(X), model.scale(X), stack, 'base');\n    e.y = ref.stackable(Y, model.encoding().y, model.scaleName(Y), model.scale(Y), stack, 'base');\n\n    const _size = size(model.encoding().size, config);\n    if (_size) { e.strokeWidth = _size; }\n\n    applyColorAndOpacity(e, model);\n    applyMarkConfig(e, model, ['interpolate', 'tension']);\n    return e;\n  }\n};\n\n// FIXME: replace this with normal size and throw warning if the size field is not the grouping field instead?\n// NOTE: This is different from other size because\n// Vega does not support variable line size.\nfunction size(sizeDef: ChannelDef, config: Config) {\n  if (isValueDef(sizeDef)) {\n      return { value: sizeDef.value};\n  }\n  // FIXME: We should not need this line since this should be taken care by applyColorAndOpacity\n  // but we have to refactor \\ first\n  return { value: config.mark.strokeWidth };\n}\n\n","import {X, Y, COLOR, NONSPATIAL_CHANNELS, Channel} from '../../channel';\nimport {AREA, LINE, TEXT as TEXTMARK} from '../../mark';\nimport {contains, without} from '../../util';\n\nimport {area} from './area';\nimport {bar} from './bar';\nimport {line} from './line';\nimport {point, circle, square} from './point';\nimport {rect} from './rect';\nimport {rule} from './rule';\nimport {text} from './text';\nimport {tick} from './tick';\n\nimport {FacetModel} from '../facet';\nimport {UnitModel} from '../unit';\n\nconst markCompiler = {\n  area: area,\n  bar: bar,\n  line: line,\n  point: point,\n  text: text,\n  tick: tick,\n  rect: rect,\n  rule: rule,\n  circle: circle,\n  square: square\n};\n\nexport function parseMark(model: UnitModel): any[] {\n  if (contains([LINE, AREA], model.mark())) {\n    return parsePathMark(model);\n  } else {\n    return parseNonPathMark(model);\n  }\n}\n\n// FIXME: maybe this should not be here.  Need re-think and refactor, esp. after having all composition in.\nfunction dataFrom(model: UnitModel): string {\n  const parent = model.parent();\n  if (parent && parent.isFacet()) {\n    return (parent as FacetModel).facetedTable();\n  }\n  if (model.stack()) {\n    return model.dataName('stacked');\n  }\n  return model.dataTable();\n}\n\nconst FACETED_PATH_PREFIX = 'faceted-path-';\n\nfunction parsePathMark(model: UnitModel) {\n  const mark = model.mark();\n  // FIXME: replace this with more general case for composition\n  const details = detailFields(model);\n\n  let pathMarks: any = [\n    {\n      name: model.name('marks'),\n      type: markCompiler[mark].markType(),\n      // If has subfacet for line/area group, need to use faceted data from below.\n      // FIXME: support sorting path order (in connected scatterplot)\n      from: {data: (details.length > 0 ? FACETED_PATH_PREFIX : '') + dataFrom(model)},\n      encode: { update: markCompiler[mark].encodeEntry(model) }\n    }\n  ];\n\n  if (details.length > 0) { // have level of details - need to facet line into subgroups\n    // TODO: for non-stacked plot, map order to zindex. (Maybe rename order for layer to zindex?)\n\n    return [{\n      name: model.name('pathgroup'),\n      type: 'group',\n      from: {\n        facet: {\n          name: FACETED_PATH_PREFIX + dataFrom(model),\n          data: dataFrom(model),\n          groupby: details,\n        }\n      },\n      encode: {\n        update: {\n          width: { field: { group: 'width' } },\n          height: { field: { group: 'height' } }\n        }\n      },\n      marks: pathMarks\n    }];\n  } else {\n    return pathMarks;\n  }\n}\n\nfunction parseNonPathMark(model: UnitModel) {\n  const mark = model.mark();\n\n  let marks: any[] = []; // TODO: vgMarks\n  if (mark === TEXTMARK &&\n    model.channelHasField(COLOR) &&\n    model.config().text.applyColorToBackground &&\n    !model.channelHasField(X) &&\n    !model.channelHasField(Y)\n  ) {\n    // add background to 'text' marks if has color\n    marks.push({\n      name: model.name('background'),\n      type: 'rect',\n      from: {data: dataFrom(model)},\n      encode: { update: text.background(model) }\n    });\n  }\n\n  // TODO: for non-stacked plot, map order to zindex. (Maybe rename order for layer to zindex?)\n\n  marks.push({\n    name: model.name('marks'),\n    type: markCompiler[mark].markType(),\n    from: {data: dataFrom(model)},\n    encode: { update: markCompiler[mark].encodeEntry(model)}\n  });\n\n  return marks;\n}\n\nconst NONSPATIAL_CHANNELS_EXCEPT_ORDER = without(NONSPATIAL_CHANNELS, ['order'] as Channel[]);\n\n/**\n * Returns list of detail (group-by) fields\n * that the model's spec contains.\n */\nfunction detailFields(model: UnitModel): string[] {\n  return NONSPATIAL_CHANNELS_EXCEPT_ORDER.reduce(function(details, channel) {\n    if (model.channelHasField(channel) && !model.fieldDef(channel).aggregate) {\n      details.push(model.field(channel));\n    }\n    return details;\n  }, []);\n}\n","import {X, Y, SHAPE, SIZE} from '../../channel';\nimport {LegendFieldDef} from '../../fielddef';\nimport {SymbolConfig, PointConfig} from '../../mark';\nimport {Scale} from '../../scale';\nimport {VgEncodeEntry, VgValueRef} from '../../vega.schema';\n\nimport {applyColorAndOpacity} from './common';\nimport {UnitModel} from '../unit';\n\nimport {MarkCompiler} from './base';\nimport * as ref from './valueref';\n\nfunction encodeEntry(model: UnitModel, fixedShape?: string) {\n  let e: VgEncodeEntry = {};\n  const config = model.config();\n  const markSpecificConfig: SymbolConfig = fixedShape ? config[fixedShape] : config.point;\n  const stack = model.stack();\n\n  // TODO: refactor how refer to scale as discussed in https://github.com/vega/vega-lite/pull/1613\n\n  e.x = ref.stackable(X, model.encoding().x, model.scaleName(X), model.scale(X), stack, ref.midX(config));\n  e.y = ref.stackable(Y, model.encoding().y, model.scaleName(Y), model.scale(Y), stack, ref.midY(config));\n\n  e.size = ref.midPoint(SIZE, model.encoding().size, model.scaleName(SIZE), model.scale(SIZE),\n    {value: markSpecificConfig.size}\n  );\n\n  e.shape = shape(model.encoding().shape, model.scaleName(SHAPE), model.scale(SHAPE), config.point, fixedShape);\n\n  applyColorAndOpacity(e, model);\n  return e;\n}\n\nfunction shape(shapeDef: LegendFieldDef, scaleName: string, scale: Scale, pointConfig: PointConfig, fixedShape?: string): VgValueRef {\n  // shape\n  if (fixedShape) { // square and circle marks\n    return { value: fixedShape };\n  }\n  return ref.midPoint(SHAPE, shapeDef, scaleName, scale, {value: pointConfig.shape});\n}\n\nexport const point: MarkCompiler = {\n  markType: () => {\n    return 'symbol';\n  },\n  encodeEntry: (model: UnitModel) => {\n    return encodeEntry(model);\n  }\n};\n\nexport const circle: MarkCompiler = {\n  markType: () => {\n    return 'symbol';\n  },\n  encodeEntry: (model: UnitModel) => {\n    return encodeEntry(model, 'circle');\n  }\n};\n\nexport const square: MarkCompiler = {\n  markType: () => {\n    return 'symbol';\n  },\n  encodeEntry: (model: UnitModel) => {\n    return encodeEntry(model, 'square');\n  }\n};\n","import {X, X2, Y, Y2} from '../../channel';\nimport {isFieldDef} from '../../fielddef';\nimport {ScaleType, hasDiscreteDomain} from '../../scale';\nimport {RECT} from '../../mark';\nimport {extend} from '../../util';\nimport * as log from '../../log';\nimport {VgEncodeEntry} from '../../vega.schema';\n\nimport {applyColorAndOpacity} from './common';\nimport {UnitModel} from '../unit';\n\nimport {MarkCompiler} from './base';\nimport * as ref from './valueref';\n\nexport const rect: MarkCompiler = {\n  markType: () => {\n    return 'rect';\n  },\n  encodeEntry: (model: UnitModel) => {\n    let e: VgEncodeEntry = extend(\n      x(model),\n      y(model)\n    );\n    applyColorAndOpacity(e, model);\n    return e;\n  }\n};\n\nfunction x(model: UnitModel) {\n  let e: VgEncodeEntry = {};\n\n  const xDef = model.encoding().x;\n  const x2Def = model.encoding().x2;\n  const xScaleName = model.scaleName(X);\n  const xScale = model.scale(X);\n\n  if (isFieldDef(xDef) && xDef.bin && !x2Def) { // TODO: better check for bin\n    e.x2 = ref.bin(xDef, xScaleName, 'start');\n    e.x = ref.bin(xDef, xScaleName, 'end');\n  } else if (xScale && hasDiscreteDomain(xScale.type)) {\n    /* istanbul ignore else */\n    if (xScale.type === ScaleType.BAND) {\n      e.x = ref.fieldRef(xDef, xScaleName, {});\n      e.width = ref.band(xScaleName);\n    } else {\n      // We don't support rect mark with point/ordinal scale\n      throw new Error(log.message.scaleTypeNotWorkWithMark(RECT, xScale.type));\n    }\n    // TODO: Currently we only support band scale for rect -- support point-ordinal axis case (if we support arbitrary scale type)\n  } else { // continuous scale or no scale\n    e.x = ref.midPoint(X, xDef, xScaleName, xScale, 'baseOrMax');\n    e.x2 = ref.midPoint(X2, x2Def, xScaleName, xScale, 'base');\n  }\n  return e;\n}\n\nfunction y(model: UnitModel) {\n  let e: VgEncodeEntry = {};\n\n  const yDef = model.encoding().y;\n  const y2Def = model.encoding().y2;\n  const yScaleName = model.scaleName(Y);\n  const yScale = model.scale(Y);\n\n  if (isFieldDef(yDef) && yDef.bin && !y2Def) { // TODO: better check for bin\n    e.y2 = ref.bin(yDef, yScaleName, 'start');\n    e.y = ref.bin(yDef, yScaleName, 'end');\n  } else if (yScale && hasDiscreteDomain(yScale.type)) {\n    /* istanbul ignore else */\n    if (yScale.type === ScaleType.BAND) {\n      e.y = ref.fieldRef(yDef, yScaleName, {});\n      e.height = ref.band(yScaleName);\n    } else {\n      // We don't support rect mark with point/ordinal scale\n      throw new Error(log.message.scaleTypeNotWorkWithMark(RECT, yScale.type));\n    }\n  } else { // continuous scale or no scale\n    e.y = ref.midPoint(Y, yDef, yScaleName, yScale, 'baseOrMax');\n    e.y2 = ref.midPoint(Y2, y2Def, yScaleName, yScale, 'base');\n  }\n  return e;\n}\n","import {X, Y, X2, Y2, SIZE} from '../../channel';\nimport {VgEncodeEntry} from '../../vega.schema';\n\nimport {applyColorAndOpacity} from './common';\nimport {UnitModel} from '../unit';\n\nimport {MarkCompiler} from './base';\nimport * as ref from './valueref';\n\nexport const rule: MarkCompiler = {\n  markType: () => {\n    return 'rule';\n  },\n  encodeEntry: (model: UnitModel) => {\n    let e: VgEncodeEntry = {};\n    const orient = model.config().mark.orient;\n    const config = model.config();\n\n    // TODO: refactor how refer to scale as discussed in https://github.com/vega/vega-lite/pull/1613\n    const stack = model.stack();\n\n    e.x = ref.stackable(X,model.encoding().x, model.scaleName(X), model.scale(X), stack, 'base');\n    e.y = ref.stackable(Y, model.encoding().y, model.scaleName(Y), model.scale(Y), stack, 'base');\n\n    if(orient === 'vertical') {\n      e.y2 = ref.stackable2(Y2, model.encoding().y, model.encoding().y2, model.scaleName(Y), model.scale(Y), stack, 'baseOrMax');\n    } else {\n      e.x2 = ref.stackable2(X2, model.encoding().x, model.encoding().x2, model.scaleName(X), model.scale(X), stack, 'baseOrMax');\n    }\n\n    // FIXME: this function would overwrite strokeWidth but shouldn't\n    applyColorAndOpacity(e, model);\n\n    e.strokeWidth = ref.midPoint(SIZE, model.encoding().size, model.scaleName(SIZE), model.scale(SIZE), {\n      value: config.rule.strokeWidth\n    });\n\n    return e;\n  }\n};\n","import {X, Y, COLOR, TEXT, SIZE} from '../../channel';\nimport {applyConfig, numberFormat, timeFormatExpression} from '../common';\n\nimport {applyColorAndOpacity} from './common';\nimport {Config} from '../../config';\nimport {ChannelDef, field, isFieldDef} from '../../fielddef';\nimport {QUANTITATIVE, TEMPORAL} from '../../type';\nimport {UnitModel} from '../unit';\nimport {VgValueRef, VgEncodeEntry} from '../../vega.schema';\n\nimport {MarkCompiler} from './base';\nimport * as ref from './valueref';\n\n// FIXME: remove thie once we remove the background hack\nexport interface TextCompiler extends MarkCompiler {\n  background: (model: UnitModel) => VgEncodeEntry;\n}\n\nexport const text: TextCompiler = {\n  markType: () => {\n    return 'text';\n  },\n\n  background: (model: UnitModel) => {\n    return {\n      x: { value: 0 },\n      y: { value: 0 },\n      width: { field: { group: 'width' } },\n      height: { field: { group: 'height' } },\n      fill: {\n        scale: model.scaleName(COLOR),\n        field: model.field(COLOR)\n      }\n    };\n  },\n\n  encodeEntry: (model: UnitModel) => {\n    let e: VgEncodeEntry = {};\n\n    applyConfig(e, model.config().text,\n      ['angle', 'align', 'baseline', 'dx', 'dy', 'font', 'fontWeight',\n        'fontStyle', 'radius', 'theta', 'text']);\n\n    const config = model.config();\n    const stack = model.stack();\n    const textDef = model.encoding().text;\n\n    // TODO: refactor how refer to scale as discussed in https://github.com/vega/vega-lite/pull/1613\n\n    e.x = ref.stackable(X, model.encoding().x, model.scaleName(X), model.scale(X), stack, xDefault(config, textDef));\n    e.y = ref.stackable(Y, model.encoding().y, model.scaleName(Y), model.scale(Y), stack, ref.midY(config));\n\n    e.fontSize = ref.midPoint(SIZE, model.encoding().size, model.scaleName(SIZE), model.scale(SIZE),\n       {value: config.text.fontSize}\n    );\n\n    e.text = textRef(textDef, config);\n\n    if (model.config().text.applyColorToBackground &&\n        !model.channelHasField(X) &&\n        !model.channelHasField(Y)) {\n      e.fill = {value: 'black'}; // TODO: add rules for swapping between black and white\n      // opacity\n      const opacity = model.config().mark.opacity;\n      if (opacity) { e.opacity = { value: opacity }; };\n    } else {\n      applyColorAndOpacity(e, model);\n    }\n\n    return e;\n  }\n};\n\nfunction xDefault(config: Config, textDef: ChannelDef): VgValueRef {\n  if (isFieldDef(textDef) && textDef.type === QUANTITATIVE) {\n    return { field: { group: 'width' }, offset: -5 };\n  }\n  // TODO: allow this to fit (Be consistent with ref.midX())\n  return { value: config.scale.textXRangeStep / 2 };\n}\n\nfunction textRef(textDef: ChannelDef, config: Config): VgValueRef {\n  // text\n  if (textDef) {\n    if (isFieldDef(textDef)) {\n      if (QUANTITATIVE === textDef.type) {\n        // FIXME: what happens if we have bin?\n        const format = numberFormat(textDef, config.text.format, config, TEXT);\n        return {\n          signal: `format(${field(textDef, { datum: true })}, '${format}')`\n        };\n      } else if (TEMPORAL === textDef.type) {\n        return {\n          signal: timeFormatExpression(field(textDef, {datum: true}), textDef.timeUnit, config.text.format, config.text.shortTimeLabels, config)\n        };\n      } else {\n        return { field: textDef.field };\n      }\n    } else if (textDef.value) {\n      return { value: textDef.value };\n    }\n  }\n  return {value: config.text.text};\n}\n","import {X, Y, SIZE} from '../../channel';\nimport {Config} from '../../config';\nimport {FieldDef} from '../../fielddef';\nimport {Scale} from '../../scale';\nimport {VgEncodeEntry, VgValueRef} from '../../vega.schema';\n\nimport {applyColorAndOpacity} from './common';\nimport {UnitModel} from '../unit';\n\nimport {MarkCompiler} from './base';\nimport * as ref from './valueref';\n\nexport const tick: MarkCompiler = {\n  markType: () => {\n    return 'rect';\n  },\n\n  encodeEntry: (model: UnitModel) => {\n    let e: VgEncodeEntry = {};\n    const config = model.config();\n    const stack = model.stack();\n\n    // TODO: refactor how refer to scale as discussed in https://github.com/vega/vega-lite/pull/1613\n\n    e.xc = ref.stackable(X, model.encoding().x, model.scaleName(X), model.scale(X), stack, ref.midX(config));\n    e.yc = ref.stackable(Y, model.encoding().y, model.scaleName(Y), model.scale(Y), stack, ref.midY(config));\n\n    if (config.mark.orient === 'horizontal') {\n      e.width = size(model.encoding().size, model.scaleName(SIZE), model.scale(SIZE), config, (model.scale(X) || {}).rangeStep);\n      e.height = { value: config.tick.thickness };\n    } else {\n      e.width = { value: config.tick.thickness };\n      e.height = size(model.encoding().size, model.scaleName(SIZE), model.scale(SIZE), config, (model.scale(Y) || {}).rangeStep);\n    }\n\n    applyColorAndOpacity(e, model);\n    return e;\n  }\n};\n\nfunction size(fieldDef: FieldDef, scaleName: string, scale: Scale, config: Config, scaleRangeStep: number | null): VgValueRef {\n  let defaultSize: number;\n  if (config.tick.bandSize !== undefined) {\n    defaultSize = config.tick.bandSize;\n  } else {\n    const rangeStep = scaleRangeStep !== undefined ?\n      scaleRangeStep :\n      config.scale.rangeStep;\n    if (typeof rangeStep !== 'number') {\n      // FIXME consolidate this log\n      throw new Error('Function does not handle non-numeric rangeStep');\n    }\n    defaultSize = rangeStep / 1.5;\n  }\n\n  return ref.midPoint(SIZE, fieldDef, scaleName, scale, {value: defaultSize});\n}\n","/**\n * Utility files for producing Vega ValueRef for marks\n */\n\nimport {Channel, X, X2, Y, Y2} from '../../channel';\nimport {Config} from '../../config';\nimport {ChannelDef, FieldDef, FieldRefOption, field, isFieldDef} from '../../fielddef';\nimport {Scale, ScaleType, hasDiscreteDomain} from '../../scale';\nimport {StackProperties} from '../../stack';\nimport {contains} from '../../util';\nimport {VgValueRef} from '../../vega.schema';\n\n// TODO: we need to find a way to refactor these so that scaleName is a part of scale\n// but that's complicated.  For now, this is a huge step moving forward.\n\n/**\n * @return Vega ValueRef for stackable x or y\n */\nexport function stackable(channel: Channel, channelDef: ChannelDef, scaleName: string, scale: Scale,\n    stack: StackProperties, defaultRef: VgValueRef): VgValueRef {\n  if (channelDef && stack && channel === stack.fieldChannel) {\n    // x or y use stack_end so that stacked line's point mark use stack_end too.\n    return fieldRef(channelDef, scaleName, {suffix: 'end'});\n  }\n  return midPoint(channel, channelDef, scaleName, scale, defaultRef);\n}\n\n/**\n * @return Vega ValueRef for stackable x2 or y2\n */\nexport function stackable2(channel: Channel, aFieldDef: FieldDef, a2fieldDef: FieldDef, scaleName: string, scale: Scale,\n    stack: StackProperties, defaultRef: VgValueRef): VgValueRef {\n  if (aFieldDef && stack &&\n      // If fieldChannel is X and channel is X2 (or Y and Y2)\n      channel.charAt(0) === stack.fieldChannel.charAt(0)\n      ) {\n    return fieldRef(aFieldDef, scaleName, {suffix: 'start'});\n  }\n  return midPoint(channel, a2fieldDef, scaleName, scale, defaultRef);\n}\n\n/**\n * Value Ref for binned fields\n */\nexport function bin(fieldDef: FieldDef, scaleName: string, side: 'start' | 'end',  offset?: number) {\n  return fieldRef(fieldDef, scaleName, {binSuffix: side}, offset);\n}\n\nexport function fieldRef(fieldDef: FieldDef, scaleName: string, opt: FieldRefOption, offset?: number | VgValueRef): VgValueRef {\n  let ref: VgValueRef = {\n    scale: scaleName,\n    field: field(fieldDef, opt),\n  };\n  if (offset) {\n    ref.offset = offset;\n  }\n  return ref;\n}\n\nexport function band(scaleName: string, band: number|boolean = true): VgValueRef {\n  return {\n    scale: scaleName,\n    band: band\n  };\n}\n\nexport function binMidSignal(fieldDef: FieldDef, scaleName: string) {\n  return {\n    scale: scaleName,\n    signal: '(' + field(fieldDef, {binSuffix: 'start', datum: true}) + '+' +\n      field(fieldDef, {binSuffix: 'end', datum: true}) + ')/2'\n  };\n}\n\n/**\n * @returns {VgValueRef} Value Ref for xc / yc or mid point for other channels.\n */\nexport function midPoint(channel: Channel, channelDef: ChannelDef, scaleName: string, scale: Scale,\n  defaultRef: VgValueRef | 'base' | 'baseOrMax'): VgValueRef {\n  // TODO: datum support\n\n  if (channelDef) {\n    /* istanbul ignore else */\n    if (isFieldDef(channelDef)) {\n      if (hasDiscreteDomain(scale.type)) {\n        if (scale.type === 'band') {\n          // For band, to get mid point, need to offset by half of the band\n          return fieldRef(channelDef, scaleName, {binSuffix: 'range'}, band(scaleName, 0.5));\n        }\n        return fieldRef(channelDef, scaleName, {binSuffix: 'range'});\n      } else {\n        if (channelDef.bin) {\n          return binMidSignal(channelDef, scaleName);\n        } else {\n          return fieldRef(channelDef, scaleName, {}); // no need for bin suffix\n        }\n      }\n    } else if (channelDef.value) {\n      return {\n        value: channelDef.value\n      };\n    } else {\n      throw new Error('FieldDef without field or value.'); // FIXME add this to log.message\n    }\n  }\n\n  if (defaultRef === 'base') {\n    /* istanbul ignore else */\n    if (channel === X || channel === X2) {\n      return baseX(scaleName, scale);\n    } else if (channel === Y || channel === Y2) {\n      return baseY(scaleName, scale);\n    } else {\n      throw new Error(`Unsupported channel ${channel} for base function`); // FIXME add this to log.message\n    }\n  } else if (defaultRef === 'baseOrMax') {\n    /* istanbul ignore else */\n    if (channel === X || channel === X2) {\n      return baseOrMaxX(scaleName, scale);\n    } else if (channel === Y || channel === Y2) {\n      return baseOrMaxY(scaleName, scale);\n    } else {\n      throw new Error(`Unsupported channel ${channel} for base function`); // FIXME add this to log.message\n    }\n  }\n  return defaultRef;\n}\n\nexport function midX(config: Config): VgValueRef {\n\n  if (typeof config.scale.rangeStep === 'string') {\n    // TODO: For fit-mode, use middle of the width\n    throw new Error('midX can not handle string rangeSteps');\n  }\n  return {value: config.scale.rangeStep / 2};\n}\n\nexport function midY(config: Config): VgValueRef {\n  if (typeof config.scale.rangeStep === 'string') {\n    // TODO: For fit-mode, use middle of the width\n    throw new Error('midX can not handle string rangeSteps');\n  }\n  return {value: config.scale.rangeStep / 2};\n}\n\nfunction baseX(scaleName: string, scale: Scale): VgValueRef {\n  if (scaleName) {\n    // Log / Time / UTC scale do not support zero\n    if (!contains([ScaleType.LOG, ScaleType.TIME, ScaleType.UTC], scale.type) &&\n      scale.zero !== false) {\n\n      return {\n        scale: scaleName,\n        value: 0\n      };\n    }\n  }\n  // Put the mark on the x-axis\n  return {value: 0};\n}\n\n/**\n * @returns {VgValueRef} base value if scale exists and return max value if scale does not exist\n */\nfunction baseOrMaxX(scaleName: string, scale: Scale): VgValueRef {\n  if (scaleName) {\n    // Log / Time / UTC scale do not support zero\n    if (!contains([ScaleType.LOG, ScaleType.TIME, ScaleType.UTC], scale.type) &&\n      scale.zero !== false) {\n\n      return {\n        scale: scaleName,\n        value: 0\n      };\n    }\n  }\n  return {field: {group: 'width'}};\n}\n\nfunction baseY(scaleName: string, scale: Scale): VgValueRef {\n  if (scaleName) {\n    // Log / Time / UTC scale do not support zero\n    if (!contains([ScaleType.LOG, ScaleType.TIME, ScaleType.UTC], scale.type) &&\n      scale.zero !== false) {\n\n      return {\n        scale: scaleName,\n        value: 0\n      };\n    }\n  }\n  // Put the mark on the y-axis\n  return {field: {group: 'height'}};\n}\n\n/**\n * @returns {VgValueRef} base value if scale exists and return max value if scale does not exist\n */\nfunction baseOrMaxY(scaleName: string, scale: Scale): VgValueRef {\n  if (scaleName) {\n    // Log / Time / UTC scale do not support zero\n    if (!contains([ScaleType.LOG, ScaleType.TIME, ScaleType.UTC], scale.type) &&\n      scale.zero !== false) {\n\n      return {\n        scale: scaleName,\n        value: 0\n      };\n    }\n  }\n  // Put the mark on the y-axis\n  return {value: 0};\n}\n","import * as log from '../log';\n\nimport {Axis} from '../axis';\nimport {Channel, X, COLUMN} from '../channel';\nimport {Config, CellConfig} from '../config';\nimport {Data, DataSourceType} from '../data';\nimport {reduce, forEach} from '../encoding';\nimport {FieldDef, FieldRefOption, field} from '../fielddef';\nimport {Legend} from '../legend';\nimport {Scale, hasDiscreteDomain} from '../scale';\nimport {SortField, SortOrder} from '../sort';\nimport {BaseSpec, Padding} from '../spec';\nimport {Transform} from '../transform';\nimport {extend, flatten, vals, Dict} from '../util';\nimport {VgData, VgEncodeEntry, VgScale, VgAxis, VgLegend} from '../vega.schema';\nimport {Formula} from '../transform';\nimport {OneOfFilter, EqualFilter, RangeFilter} from '../filter';\n\nimport {DataComponent} from './data/data';\nimport {LayoutComponent} from './layout';\nimport {ScaleComponents, BIN_LEGEND_SUFFIX, BIN_LEGEND_LABEL_SUFFIX} from './scale/scale';\nimport {StackProperties} from '../stack';\n\n\n/**\n * Composable Components that are intermediate results of the parsing phase of the\n * compilations.  These composable components will be assembled in the last\n * compilation step.\n */\nexport interface Component {\n  data: DataComponent;\n  layout: LayoutComponent;\n  scale: Dict<ScaleComponents>;\n\n  /** Dictionary mapping channel to VgAxis definition */\n  axis: Dict<VgAxis[]>;\n\n  /** Dictionary mapping channel to VgLegend definition */\n  legend: Dict<VgLegend>;\n\n  /** Dictionary mapping channel to axis mark group for facet and concat */\n  axisGroup: Dict<VgEncodeEntry>;\n\n  /** Dictionary mapping channel to grid mark group for facet (and concat?) */\n  gridGroup: Dict<VgEncodeEntry[]>;\n\n  mark: VgEncodeEntry[];\n}\n\nclass NameMap implements NameMapInterface {\n  private _nameMap: Dict<string>;\n\n  constructor() {\n    this._nameMap = {};\n  }\n\n  public rename(oldName: string, newName: string) {\n    this._nameMap[oldName] = newName;\n  }\n\n\n  public has(name: string): boolean {\n    return this._nameMap[name] !== undefined;\n  }\n\n  public get(name: string): string {\n    // If the name appears in the _nameMap, we need to read its new name.\n    // We have to loop over the dict just in case the new name also gets renamed.\n    while (this._nameMap[name]) {\n      name = this._nameMap[name];\n    }\n\n    return name;\n  }\n}\n\nexport interface NameMapInterface {\n  rename(oldname: string, newName: string): void;\n  has(name: string): boolean;\n  get(name: string): string;\n}\n\nexport abstract class Model {\n  protected readonly _parent: Model;\n  protected readonly _name: string;\n  protected readonly _description: string;\n  protected readonly _padding: Padding;\n\n  protected readonly _data: Data;\n\n  /** Name map for data sources, which can be renamed by a model's parent. */\n  protected _dataNameMap: NameMapInterface;\n\n  /** Name map for scales, which can be renamed by a model's parent. */\n  protected _scaleNameMap: NameMapInterface;\n\n  /** Name map for size, which can be renamed by a model's parent. */\n  protected _sizeNameMap: NameMapInterface;\n\n  protected readonly _transform: Transform;\n  protected _scale: Dict<Scale> = {};\n\n  protected _axis: Dict<Axis> = {};\n\n  protected _legend: Dict<Legend> = {};\n\n  protected _config: Config;\n\n  public component: Component;\n\n  constructor(spec: BaseSpec, parent: Model, parentGivenName: string) {\n    this._parent = parent;\n\n    // If name is not provided, always use parent's givenName to avoid name conflicts.\n    this._name = spec.name || parentGivenName;\n\n    // Shared name maps\n    this._dataNameMap = parent ? parent._dataNameMap : new NameMap();\n    this._scaleNameMap = parent ? parent._scaleNameMap : new NameMap();\n    this._sizeNameMap = parent ? parent._sizeNameMap : new NameMap();\n\n    this._data = spec.data;\n\n    this._description = spec.description;\n    this._padding = spec.padding;\n    this._transform = spec.transform;\n\n    if (spec.transform) {\n      if (spec.transform.filterInvalid === undefined &&\n          spec.transform['filterNull'] !== undefined) {\n        spec.transform.filterInvalid = spec.transform['filterNull'];\n        log.warn(log.message.DEPRECATED_FILTER_NULL);\n      }\n    }\n\n    this.component = {data: null, layout: null, mark: null, scale: null, axis: null, axisGroup: null, gridGroup: null, legend: null};\n  }\n\n\n  public parse() {\n    this.parseData();\n    this.parseSelectionData();\n    this.parseLayoutData();\n    this.parseScale(); // depends on data name\n    this.parseAxis(); // depends on scale name\n    this.parseLegend(); // depends on scale name\n    this.parseAxisGroup(); // depends on child axis\n    this.parseGridGroup();\n    this.parseMark(); // depends on data name and scale name, axisGroup, gridGroup and children's scale, axis, legend and mark.\n  }\n\n  public abstract parseData(): void;\n\n  public abstract parseSelectionData(): void;\n\n  public abstract parseLayoutData(): void;\n\n  public abstract parseScale(): void;\n\n  public abstract parseMark(): void;\n\n  public abstract parseAxis(): void;\n\n  public abstract parseLegend(): void;\n\n  // TODO: revise if these two methods make sense for shared scale concat\n  public abstract parseAxisGroup(): void;\n  public abstract parseGridGroup(): void;\n\n\n  public abstract assembleData(data: VgData[]): VgData[];\n\n  public abstract assembleLayout(layoutData: VgData[]): VgData[];\n\n  // TODO: for Arvind to write\n  // public abstract assembleSelectionSignal(layoutData: VgData[]): VgData[];\n  // public abstract assembleSelectionData(layoutData: VgData[]): VgData[];\n\n  public assembleScales(): VgScale[] {\n    // FIXME: write assembleScales() in scale.ts that\n    // help assemble scale domains with scale signature as well\n    return flatten(vals(this.component.scale).map((scales: ScaleComponents) => {\n      let arr = [scales.main];\n      if (scales.binLegend) {\n        arr.push(scales.binLegend);\n      }\n      if (scales.binLegendLabel) {\n        arr.push(scales.binLegendLabel);\n      }\n      return arr;\n    }));\n  }\n\n  public abstract assembleMarks(): any[]; // TODO: VgMarkGroup[]\n\n  public assembleAxes(): VgAxis[] {\n    return [].concat.apply([], vals(this.component.axis));\n  }\n\n  public assembleLegends(): any[] { // TODO: VgLegend[]\n    return vals(this.component.legend);\n  }\n\n  public assembleGroup() {\n    let group: VgEncodeEntry = {};\n\n    // TODO: consider if we want scales to come before marks in the output spec.\n\n    group.marks = this.assembleMarks();\n    const scales = this.assembleScales();\n    if (scales.length > 0) {\n      group.scales = scales;\n    }\n\n    const axes = this.assembleAxes();\n    if (axes.length > 0) {\n      group.axes = axes;\n    }\n\n    const legends = this.assembleLegends();\n    if (legends.length > 0) {\n      group.legends = legends;\n    }\n\n    return group;\n  }\n\n  public abstract assembleParentGroupProperties(cellConfig: CellConfig): VgEncodeEntry;\n\n  public abstract channels(): Channel[];\n\n  protected abstract mapping(): any;\n\n  public reduce<T>(f: (acc: any, fd: FieldDef, c: Channel) => any, init: T, t?: any) {\n    return reduce(this.mapping(), f, init, t);\n  }\n\n  public forEach(f: (fd: FieldDef, c: Channel) => void, t?: any) {\n    forEach(this.mapping(), f, t);\n  }\n\n  public hasDescendantWithFieldOnChannel(channel: Channel) {\n    for (let child of this.children()) {\n      if (child.isUnit()) {\n        if (child.channelHasField(channel)) {\n          return true;\n        }\n      } else {\n        if (child.hasDescendantWithFieldOnChannel(channel)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  public abstract channelHasField(channel: Channel): boolean;\n\n  public parent(): Model {\n    return this._parent;\n  }\n\n  public abstract children(): Model[];\n\n  public name(text: string, delimiter: string = '_') {\n    return (this._name ? this._name + delimiter : '') + text;\n  }\n\n  public description() {\n    return this._description;\n  }\n\n  public padding() {\n    return this._padding;\n  }\n\n  public data() {\n    return this._data;\n  }\n\n  public renameData(oldName: string, newName: string) {\n     this._dataNameMap.rename(oldName, newName);\n  }\n\n  /**\n   * Return the data source name for the given data source type.\n   *\n   * For unit spec, this is always simply the spec.name + '-' + dataSourceType.\n   * We already use the name map so that marks and scales use the correct data.\n   */\n  public dataName(dataSourceType: DataSourceType): string {\n    return this._dataNameMap.get(this.name(String(dataSourceType)));\n  }\n\n  public renameSize(oldName: string, newName: string) {\n    this._sizeNameMap.rename(oldName, newName);\n  }\n\n  public channelSizeName(channel: Channel): string {\n    return this.sizeName(channel === X || channel === COLUMN ? 'width' : 'height');\n  }\n\n  public sizeName(size: string): string {\n     return this._sizeNameMap.get(this.name(size, '_'));\n  }\n\n  public abstract dataTable(): string;\n\n  // TRANSFORMS\n  public calculate(): Formula[] {\n    return this._transform ? this._transform.calculate : undefined;\n  }\n\n  public filterInvalid(): boolean {\n    const transform = this._transform || {};\n    if (transform.filterInvalid === undefined) {\n      return this.parent() ? this.parent().filterInvalid() : undefined;\n    }\n    return transform.filterInvalid;\n  }\n\n  public filter(): string | OneOfFilter | EqualFilter| RangeFilter | (string | OneOfFilter | EqualFilter| RangeFilter)[] {\n    return this._transform ? this._transform.filter : undefined;\n  }\n\n  /** Get \"field\" reference for vega */\n  public field(channel: Channel, opt: FieldRefOption = {}) {\n    const fieldDef = this.fieldDef(channel);\n\n    if (fieldDef.bin) { // bin has default suffix that depends on scaleType\n      opt = extend({\n        binSuffix: hasDiscreteDomain(this.scale(channel).type) ? 'range' : 'start'\n      }, opt);\n    }\n\n    return field(fieldDef, opt);\n  }\n\n  public abstract fieldDef(channel: Channel): FieldDef;\n\n  public scale(channel: Channel): Scale {\n    return this._scale[channel];\n  }\n\n  public hasDiscreteScale(channel: Channel) {\n    const scale = this.scale(channel);\n    return scale && hasDiscreteDomain(scale.type);\n  }\n\n  public renameScale(oldName: string, newName: string) {\n    this._scaleNameMap.rename(oldName, newName);\n  }\n\n\n  /**\n   * @return scale name for a given channel after the scale has been parsed and named.\n   * (DO NOT USE THIS METHOD DURING SCALE PARSING, use model.name() instead)\n   */\n  public scaleName(originalScaleName: Channel|string, parse?: boolean): string {\n    const channel = originalScaleName.replace(BIN_LEGEND_SUFFIX, '').replace(BIN_LEGEND_LABEL_SUFFIX, '');\n\n    if (parse) {\n      // During the parse phase always return a value\n      // No need to refer to rename map because a scale can't be renamed\n      // before it has the original name.\n      return this.name(originalScaleName + '');\n    }\n\n    // If there is a scale for the channel, it should either\n    // be in the _scale mapping or exist in the name map\n    if (\n        // in the scale map (the scale is not merged by its parent)\n        (this._scale && this._scale[channel]) ||\n        // in the scale name map (the the scale get merged by its parent)\n        this._scaleNameMap.has(this.name(originalScaleName + ''))\n      ) {\n      return this._scaleNameMap.get(this.name(originalScaleName + ''));\n    }\n    return undefined;\n  }\n\n  public sort(channel: Channel): SortField | SortOrder {\n    return (this.mapping()[channel] || {}).sort;\n  }\n\n  public abstract stack(): StackProperties;\n\n  public axis(channel: Channel): Axis {\n    return this._axis[channel];\n  }\n\n  public legend(channel: Channel): Legend {\n    return this._legend[channel];\n  }\n\n  /**\n   * Get the spec configuration.\n   */\n  public config(): Config {\n    return this._config;\n  }\n\n  /**\n   * Type checks\n   */\n  public isUnit() {\n    return false;\n  }\n  public isFacet() {\n    return false;\n  }\n  public isLayer() {\n    return false;\n  }\n}\n","import * as log from '../../log';\n\nimport {SHARED_DOMAIN_OPS} from '../../aggregate';\nimport {Channel} from '../../channel';\nimport {SOURCE} from '../../data';\nimport {DateTime, isDateTime, timestamp} from '../../datetime';\nimport {Scale, ScaleType, hasDiscreteDomain} from '../../scale';\nimport {isSortField, SortOrder} from '../../sort';\nimport {StackOffset} from '../../stack';\nimport {FieldRefUnionDomain, VgSortField, isDataRefUnionedDomain, isFieldRefUnionDomain, isDataRefDomain, VgDomain, VgDataRef} from '../../vega.schema';\n\nimport * as util from '../../util';\n\nimport {Model} from '../model';\n\nexport default function domain(scale: Scale, model: Model, channel:Channel): any[] | VgDataRef | FieldRefUnionDomain {\n  const fieldDef = model.fieldDef(channel);\n\n  if (scale.domain) { // explicit value\n    if (isDateTime(scale.domain[0])) {\n      return (scale.domain as DateTime[]).map((dt) => {\n        return timestamp(dt, true);\n      });\n    }\n    return scale.domain;\n  }\n\n  // special case for temporal scale\n  if (fieldDef.type === 'temporal') {\n    return {\n      data: model.dataTable(),\n      field: model.field(channel),\n      sort: {\n        field: model.field(channel),\n        op: 'min'\n      }\n    };\n  }\n\n  // For stack, use STACKED data.\n  const stack = model.stack();\n  if (stack && channel === stack.fieldChannel) {\n    if(stack.offset === StackOffset.NORMALIZE) {\n      return [0, 1];\n    }\n    return {\n      data: model.dataName('stacked'),\n      fields: [\n        model.field(channel, {suffix: 'start'}),\n        model.field(channel, {suffix: 'end'})\n      ]\n    };\n  }\n\n  // FIXME refactor _useRawDomain's signature\n  const useRawDomain = _useRawDomain(scale, model, channel);\n\n  const sort = domainSort(model, channel, scale.type);\n\n  if (useRawDomain) { // useRawDomain - only Q/T\n    return {\n      data: SOURCE,\n      field: model.field(channel, {\n        // no aggregate rather than nofn as bin and timeUnit is fine\n        noAggregate: true\n      })\n    };\n  } else if (fieldDef.bin) { // bin\n    if (hasDiscreteDomain(scale.type)) {\n      // ordinal bin scale takes domain from bin_range, ordered by bin_start\n      // This is useful for both axis-based scale (x, y, column, and row) and legend-based scale (other channels).\n      return {\n        data: model.dataTable(),\n        field: model.field(channel, { binSuffix: 'range' }),\n        sort: {\n          field: model.field(channel, { binSuffix: 'start' }),\n          op: 'min' // min or max doesn't matter since same _range would have the same _start\n        }\n      };\n    } else { // continuous scales\n      if (channel === 'x' || channel === 'y') {\n        // X/Y position have to include start and end for non-ordinal scale\n        return {\n          data: model.dataTable(),\n          fields: [\n            model.field(channel, { binSuffix: 'start' }),\n            model.field(channel, { binSuffix: 'end' })\n          ]\n        };\n      } else {\n        // TODO: use bin_mid\n        return {\n          data: model.dataTable(),\n          field: model.field(channel, { binSuffix: 'start' })\n        };\n      }\n    }\n  } else if (sort) { // have sort -- only for ordinal\n    return {\n      // If sort by aggregation of a specified sort field, we need to use SOURCE table,\n      // so we can aggregate values for the scale independently from the main aggregation.\n      data: util.isBoolean(sort) ? model.dataTable(): SOURCE,\n      field: model.field(channel),\n      sort: sort\n    };\n  } else {\n    return {\n      data: model.dataTable(),\n      field: model.field(channel),\n    };\n  }\n}\n\nexport function domainSort(model: Model, channel: Channel, scaleType: ScaleType): VgSortField {\n  if (!hasDiscreteDomain(scaleType)) {\n    return undefined;\n  }\n\n  const sort = model.sort(channel);\n\n  // Sorted based on an aggregate calculation over a specified sort field (only for ordinal scale)\n  if (isSortField(sort)) {\n    return {\n      op: sort.op,\n      field: sort.field\n    };\n  }\n\n  if (util.contains([SortOrder.ASCENDING, SortOrder.DESCENDING, undefined /* default =ascending*/], sort)) {\n    return true;\n  }\n\n  // sort === 'none'\n  return undefined;\n}\n\n/**\n * Determine if useRawDomain should be activated for this scale.\n * @return {Boolean} Returns true if all of the following conditons applies:\n * 1. `useRawDomain` is enabled either through scale or config\n * 2. Aggregation function is not `count` or `sum`\n * 3. The scale is quantitative or time scale.\n */\nfunction _useRawDomain (scale: Scale, model: Model, channel: Channel) {\n  const fieldDef = model.fieldDef(channel);\n\n  return scale.useRawDomain && //  if useRawDomain is enabled\n    // only applied to aggregate table\n    fieldDef.aggregate &&\n    // only activated if used with aggregate functions that produces values ranging in the domain of the source data\n    SHARED_DOMAIN_OPS.indexOf(fieldDef.aggregate as any) >= 0 &&\n    (\n      // Q always uses quantitative scale except when it's binned.\n      // Binned field has similar values in both the source table and the summary table\n      // but the summary table has fewer values, therefore binned fields draw\n      // domain values from the summary table.\n      // Meanwhile, we rely on non-positive filter inside summary data source, thus\n      // we can't use raw domain to feed into log scale\n      // FIXME(https://github.com/vega/vega-lite/issues/1537):\n      // consider allowing useRawDomain for log scale once we reimplement data sources\n      (fieldDef.type === 'quantitative' && !fieldDef.bin && scale.type !== ScaleType.LOG) ||\n      // T uses non-ordinal scale when there's no unit or when the unit is not ordinal.\n      (fieldDef.type === 'temporal' && util.contains([ScaleType.TIME, ScaleType.UTC], scale.type))\n    );\n}\n\n\n/**\n * Convert the domain to an array of data refs or an array of values. Also, throw\n * away sorting information since we always sort the domain when we union two domains.\n */\nfunction normalizeDomain(domain: VgDomain): (any[] | VgDataRef)[] {\n  if (util.isArray(domain)) {\n    return [domain];\n  } else if (isDataRefDomain(domain)) {\n    delete domain.sort;\n    return [domain];\n  } else if(isFieldRefUnionDomain(domain)) {\n    return domain.fields.map(d => {\n      return {\n        data: domain.data,\n        field: d\n      };\n    });\n  } else if (isDataRefUnionedDomain(domain)) {\n    return domain.fields.map(d => {\n      if (util.isArray(d)) {\n        return d;\n      }\n      return {\n        field: d.field,\n        data: d.data\n      };\n    });\n  }\n  /* istanbul ignore next: This should never happen. */\n  throw new Error(log.message.INVAID_DOMAIN);\n}\n\n/**\n * Union two data domains. A unioned domain is always sorted.\n */\nexport function unionDomains(domain1: VgDomain, domain2: VgDomain): VgDomain {\n  const normalizedDomain1 = normalizeDomain(domain1);\n  const normalizedDomain2 = normalizeDomain(domain2);\n\n  let domains = normalizedDomain1.concat(normalizedDomain2);\n  domains = util.unique(domains, util.hash);\n\n  if (domains.length > 1) {\n    const allData = domains.map(d => {\n      if (isDataRefDomain(d)) {\n        return d.data;\n      }\n      return null;\n    });\n\n    if (util.unique(allData, x => x).length === 1 && allData[0] !== null) {\n      return {\n        data: allData[0],\n        fields: domains.map(d => (d as VgDataRef).field)\n      };\n    }\n\n    return { fields: domains, sort: true };\n  } else {\n    return domains[0];\n  }\n}\n","import * as log from '../../log';\n\nimport {Config} from '../../config';\nimport {Channel} from '../../channel';\nimport {ScaleFieldDef, FieldDef} from '../../fielddef';\nimport {Mark} from '../../mark';\nimport {Scale, ScaleConfig, scaleTypeSupportProperty, channelScalePropertyIncompatability} from '../../scale';\n\nimport rangeMixins from './range';\nimport * as rules from './rules';\nimport scaleType from './type';\nimport * as util from '../../util';\n\n/**\n * Initialize Vega-Lite Scale's properties\n *\n * Note that we have to apply these rules here because:\n * - many other scale and non-scale properties (including layout, mark) depend on scale type\n * - layout depends on padding\n * - range depends on zero and size (width and height) depends on range\n */\nexport default function init(\n    channel: Channel, fieldDef: ScaleFieldDef, config: Config,\n    mark: Mark | undefined, topLevelSize: number | undefined, xyRangeSteps: number[]): Scale {\n  let specifiedScale = (fieldDef || {}).scale || {};\n\n  let scale: Scale = {\n    type: scaleType(fieldDef, channel, mark, topLevelSize, config)\n  };\n\n  // Use specified value if compatible or determine default values for each property\n  [\n    // general properties\n    'domain', // For domain, we only copy specified value here.  Default value is determined during parsing phase.\n    'round',\n    // quantitative / time\n    'clamp', 'nice',\n    // quantitative\n    'exponent', 'zero', // zero depends on domain\n    // ordinal\n    'padding', 'paddingInner', 'paddingOuter', // padding\n\n    'useRawDomain'\n  ].forEach(function(property) {\n    const specifiedValue = specifiedScale[property];\n\n    let supportedByScaleType = scaleTypeSupportProperty(scale.type, property);\n    const channelIncompatability = channelScalePropertyIncompatability(channel, property);\n\n    if (specifiedValue !== undefined) {\n      // If there is a specified value, check if it is compatible with scale type and channel\n      if (!supportedByScaleType) {\n        log.warn(log.message.scalePropertyNotWorkWithScaleType(scale.type, property, channel));\n      } else if (channelIncompatability) { // channel\n        log.warn(channelIncompatability);\n      } else {\n        scale[property] = specifiedValue;\n      }\n      return;\n    } else {\n      // If there is no property specified, check if we need to determine default value.\n      if (supportedByScaleType && channelIncompatability === undefined) {\n        const value = getDefaultValue(property, scale, channel, fieldDef, config.scale);\n        if (value !== undefined) { // use the default value\n          scale[property] = value;\n        }\n      }\n    }\n  });\n\n  return util.extend(\n    scale,\n    rangeMixins(\n      channel, scale.type, fieldDef.type, specifiedScale, config,\n      scale.zero, mark, topLevelSize, xyRangeSteps\n    )\n  );\n}\n\nfunction getDefaultValue(property: string, scale: Scale, channel: Channel, fieldDef: FieldDef, scaleConfig: ScaleConfig) {\n  // If we have default rule-base, determine default value first\n  switch (property) {\n    case 'nice':\n      return rules.nice(scale.type, channel, fieldDef);\n    case 'padding':\n      return rules.padding(channel, scale.type, scaleConfig);\n    case 'paddingInner':\n      return rules.paddingInner(scale.padding, channel, scaleConfig);\n    case 'paddingOuter':\n      return rules.paddingOuter(scale.padding, channel, scale.type, scale.paddingInner, scaleConfig);\n    case 'round':\n      return rules.round(channel, scaleConfig);\n    case 'zero':\n      return rules.zero(scale, channel, fieldDef);\n  }\n  // Otherwise, use scale config\n  return scaleConfig[property];\n}\n\n","import {X, Y, X2, Y2, Channel} from '../../channel';\nimport {FieldDef, field} from '../../fielddef';\nimport {ScaleType, hasContinuousDomain} from '../../scale';\nimport {isSortField, SortOrder} from '../../sort';\nimport {Dict} from '../../util';\n\nimport {Model} from '../model';\n\nimport {ScaleComponent, ScaleComponents, BIN_LEGEND_SUFFIX, BIN_LEGEND_LABEL_SUFFIX} from './scale';\nimport {default as domain, unionDomains} from './domain';\nimport {parseRange} from './range';\nimport {VgScale, VgDomain} from '../../vega.schema';\n\n/**\n * Parse scales for all channels of a model.\n */\nexport default function parseScaleComponent(model: Model): Dict<ScaleComponents> {\n  // TODO: should model.channels() inlcude X2/Y2?\n  return model.channels().reduce(function(scaleComponentsIndex: Dict<ScaleComponents>, channel: Channel) {\n    const scaleComponents = parseScale(model, channel);\n    if (scaleComponents) {\n      scaleComponentsIndex[channel] = scaleComponents;\n    }\n    return scaleComponentsIndex;\n  }, {});\n}\n\n/**\n * Parse scales for a single channel of a model.\n */\nexport function parseScale(model: Model, channel: Channel) {\n   if (model.scale(channel)) {\n    const fieldDef = model.fieldDef(channel);\n    const scales: ScaleComponents = {\n      main: parseMainScale(model, channel)\n    };\n\n    // Add additional scale needed for the labels in the binned legend.\n    if (model.legend(channel) && fieldDef.bin && hasContinuousDomain(model.scale(channel).type)) {\n      scales.binLegend = parseBinLegend(channel, model);\n      scales.binLegendLabel = parseBinLegendLabel(channel, model, fieldDef);\n    }\n\n    return scales;\n  }\n  return null;\n}\n\n// TODO: consider return type of this method\n// maybe we should just return domain as we can have the rest of scale (ScaleSignature constant)\n/**\n * Return the main scale for each channel.  (Only color can have multiple scales.)\n */\nfunction parseMainScale(model: Model, channel: Channel) {\n  const scale = model.scale(channel);\n  const sort = model.sort(channel);\n\n  let scaleComponent: VgScale = {\n    name: model.scaleName(channel + '', true),\n    type: scale.type,\n    domain: parseDomain(model, channel),\n    range: parseRange(scale)\n  };\n\n  [ 'round',\n    // quantitative / time\n    'clamp', 'nice',\n    // quantitative\n    'exponent', 'zero', // zero depends on domain\n    // ordinal\n    'padding', 'paddingInner', 'paddingOuter', // padding\n  ].forEach((property) => {\n    scaleComponent[property] = scale[property];\n  });\n\n  if (sort && (isSortField(sort) ? sort.order : sort) === SortOrder.DESCENDING) {\n    scaleComponent.reverse = true;\n  }\n\n  return scaleComponent;\n}\n\nexport function parseDomain(model: Model, channel: Channel): VgDomain {\n  const scale = model.scale(channel);\n\n  // If channel is either X or Y then union them with X2 & Y2 if they exist\n  if (channel === X && model.channelHasField(X2)) {\n    if (model.channelHasField(X)) {\n      return unionDomains(domain(scale, model, X), domain(scale, model, X2));\n    } else {\n      return domain(scale, model, X2);\n    }\n  } else if (channel === Y && model.channelHasField(Y2)) {\n    if (model.channelHasField(Y)) {\n      return unionDomains(domain(scale, model, Y), domain(scale, model, Y2));\n    } else {\n      return domain(scale, model, Y2);\n    }\n  }\n  return domain(scale, model, channel);\n}\n\n/**\n * Return additional scale to drive legend when we use a continuous scale and binning.\n */\nfunction parseBinLegend(channel: Channel, model: Model): ScaleComponent {\n  return {\n    name: model.scaleName(channel, true) + BIN_LEGEND_SUFFIX,\n    type: ScaleType.POINT,\n    domain: {\n      data: model.dataTable(),\n      field: model.field(channel),\n      sort: true\n    },\n    range: [0,1] // doesn't matter because we override it\n  };\n}\n\n/**\n *  Return an additional scale for bin labels because we need to map bin_start to bin_range in legends\n */\nfunction parseBinLegendLabel(channel: Channel, model: Model, fieldDef: FieldDef): ScaleComponent {\n  return {\n    name: model.scaleName(channel, true) + BIN_LEGEND_LABEL_SUFFIX,\n    type: ScaleType.ORDINAL,\n    domain: {\n      data: model.dataTable(),\n      field: model.field(channel),\n      sort: true\n    },\n    range: {\n      data: model.dataTable(),\n      field: field(fieldDef, {binSuffix: 'range'}),\n      sort: {\n        field: model.field(channel, { binSuffix: 'start' }),\n        op: 'min' // min or max doesn't matter since same _range would have the same _start\n      }\n    }\n  };\n}\n","import * as log from '../../log';\n\nimport {COLUMN, ROW, X, Y, SHAPE, SIZE, COLOR, OPACITY, Channel} from '../../channel';\nimport {Config} from '../../config';\nimport {Mark} from '../../mark';\nimport {Scale, ScaleConfig, ScaleType, scaleTypeSupportProperty, Scheme, Range, isExtendedScheme, channelScalePropertyIncompatability} from '../../scale';\nimport {Type} from '../../type';\nimport {VgRange, VgRangeScheme} from '../../vega.schema';\nimport * as util from '../../util';\n\nexport type RangeMixins = {range: Range} | {rangeStep: number} | {scheme: Scheme};\n\nexport function parseRange(scale: Scale): VgRange {\n  if (scale.rangeStep) {\n    return {step: scale.rangeStep};\n  } else if (scale.scheme) {\n    const scheme = scale.scheme;\n    if (isExtendedScheme(scheme)) {\n      let r: VgRangeScheme = {scheme: scheme.name};\n      if (scheme.count) {\n        r.count = scheme.count;\n      }\n      if (scheme.extent) {\n        r.extent = scheme.extent;\n      }\n      return r;\n    } else {\n      return { scheme };\n    }\n  }\n  return scale.range;\n}\n\n/**\n * Return mixins that includes one of the range properties (range, rangeStep, scheme).\n */\nexport default function rangeMixins(\n  channel: Channel, scaleType: ScaleType, type: Type, specifiedScale: Scale, config: Config,\n  zero: boolean, mark: Mark, topLevelSize: number | undefined, xyRangeSteps: number[]): RangeMixins {\n\n  let specifiedRangeStepIsNull = false;\n\n  // Check if any of the range properties is specified.\n  // If so, check if it is compatible and make sure that we only output one of the properties\n  for (let property of ['range', 'rangeStep', 'scheme']) {\n    if (specifiedScale[property] !== undefined) {\n      let supportedByScaleType = scaleTypeSupportProperty(scaleType, property);\n      const channelIncompatability = channelScalePropertyIncompatability(channel, property);\n      if (!supportedByScaleType) {\n        log.warn(log.message.scalePropertyNotWorkWithScaleType(scaleType, property, channel));\n      } else if (channelIncompatability) { // channel\n        log.warn(channelIncompatability);\n      } else {\n        switch (property) {\n          case 'range':\n            return {range: specifiedScale[property]};\n          case 'scheme':\n            return {scheme: specifiedScale[property]};\n          case 'rangeStep':\n            if (topLevelSize === undefined) {\n              const stepSize = specifiedScale[property];\n              if (stepSize !== null) {\n                return {rangeStep: stepSize};\n              } else {\n                specifiedRangeStepIsNull = true;\n              }\n            } else {\n              // If top-level size is specified, we ignore specified rangeStep.\n              log.warn(log.message.rangeStepDropped(channel));\n            }\n        }\n      }\n    }\n  }\n\n  switch (channel) {\n    // TODO: revise row/column when facetSpec has top-level width/height\n    case ROW:\n      return {range: 'height'};\n    case COLUMN:\n      return {range: 'width'};\n    case X:\n    case Y:\n      if (topLevelSize === undefined) {\n        if (util.contains(['point', 'band'], scaleType) && !specifiedRangeStepIsNull) { // FIXME isDiscrete blah blah\n          if (channel === X && mark === 'text') {\n            if (config.scale.textXRangeStep) {\n              return {rangeStep: config.scale.textXRangeStep};\n            }\n          } else {\n            if (config.scale.rangeStep) {\n              return {rangeStep: config.scale.rangeStep};\n            }\n          }\n        }\n        // If specified range step is null or the range step config is null.\n        // Use default topLevelSize rule/config\n        topLevelSize = channel === X ? config.cell.width : config.cell.height;\n      }\n      return {range: channel === X ? [0, topLevelSize] : [topLevelSize, 0]};\n\n    case SIZE:\n      // TODO: support custom rangeMin, rangeMax\n      const rangeMin = sizeRangeMin(mark, zero, config);\n      const rangeMax = sizeRangeMax(mark, xyRangeSteps, config);\n      return {range: [rangeMin, rangeMax]};\n    case SHAPE:\n    case COLOR:\n      return {range: defaultRange(channel, scaleType, type, mark)};\n\n\n    case OPACITY:\n      // TODO: support custom rangeMin, rangeMax\n      return {range: [config.mark.minOpacity, config.mark.maxOpacity]};\n  }\n  /* istanbul ignore next: should never reach here */\n  throw new Error(`Scale range undefined for channel ${channel}`);\n}\n\nfunction defaultRange(channel: 'shape' | 'color', scaleType: ScaleType, type: Type, mark: Mark) {\n  switch (channel) {\n    case SHAPE:\n      return 'symbol';\n    case COLOR:\n      if (scaleType === 'ordinal') {\n        // Only nominal data uses ordinal scale by default\n        return type === 'nominal' ? 'category' : 'ordinal';\n      }\n      return mark === 'rect' ? 'heatmap' : 'ramp';\n  }\n}\n\nfunction sizeRangeMin(mark: Mark, zero: boolean, config: Config) {\n  if (zero) {\n    return 0;\n  }\n  switch (mark) {\n    case 'bar':\n      return config.bar.minBandSize !== undefined ? config.bar.minBandSize : config.bar.continuousBandSize;\n    case 'tick':\n      return config.tick.minBandSize;\n    case 'rule':\n      return config.rule.minStrokeWidth;\n    case 'text':\n      return config.text.minFontSize;\n    case 'point':\n      return config.point.minSize;\n    case 'square':\n      return config.square.minSize;\n    case 'circle':\n      return config.circle.minSize;\n  }\n  /* istanbul ignore next: should never reach here */\n  // sizeRangeMin not implemented for the mark\n  throw new Error(log.message.incompatibleChannel('size', mark));\n}\n\nfunction sizeRangeMax(mark: Mark, xyRangeSteps: number[], config: Config) {\n  const scaleConfig = config.scale;\n  // TODO(#1168): make max size scale based on rangeStep / overall plot size\n  switch (mark) {\n    case 'bar':\n      if (config.bar.maxBandSize !== undefined) {\n        return config.bar.maxBandSize;\n      }\n      return minXYRangeStep(xyRangeSteps, config.mark) - 1;\n    case 'tick':\n      if (config.tick.maxBandSize !== undefined) {\n        return config.tick.maxBandSize;\n      }\n      return minXYRangeStep(xyRangeSteps, config.mark) - 1;\n    case 'rule':\n      return config.rule.maxStrokeWidth;\n    case 'text':\n      return config.text.maxFontSize;\n    case 'point':\n    case 'square':\n    case 'circle':\n      if (config[mark].maxSize) {\n        return config[mark].maxSize;\n      }\n\n      // FIXME this case totally should be refactored\n      const pointStep = minXYRangeStep(xyRangeSteps, scaleConfig);\n      return (pointStep - 2) * (pointStep - 2);\n  }\n  /* istanbul ignore next: should never reach here */\n  // sizeRangeMax not implemented for the mark\n  throw new Error(log.message.incompatibleChannel('size', mark));\n}\n\n/**\n * @returns {number} Range step of x or y or minimum between the two if both are ordinal scale.\n */\nfunction minXYRangeStep(xyRangeSteps: number[], scaleConfig: ScaleConfig): number {\n  if (xyRangeSteps.length > 0) {\n    return Math.min.apply(null, xyRangeSteps);\n  }\n  if (scaleConfig.rangeStep) {\n    return scaleConfig.rangeStep;\n  }\n  return 21; // FIXME: re-evaluate the default value here.\n}\n","\nimport {X, Y, Channel} from '../../channel';\nimport {FieldDef} from '../../fielddef';\nimport {Scale, ScaleConfig, ScaleType, NiceTime} from '../../scale';\nimport {smallestUnit} from '../../timeunit';\nimport * as util from '../../util';\n\nexport function nice(scaleType: ScaleType, channel: Channel, fieldDef: FieldDef): boolean | NiceTime {\n  if (util.contains([ScaleType.TIME, ScaleType.UTC], scaleType)) {\n    return smallestUnit(fieldDef.timeUnit) as any;\n  }\n  return util.contains([X, Y], channel); // return true for quantitative X/Y\n}\n\nexport function padding(channel: Channel, scaleType: ScaleType, scaleConfig: ScaleConfig) {\n  if (util.contains([X, Y], channel)) {\n    if (scaleType === ScaleType.POINT) {\n      return scaleConfig.pointPadding;\n    }\n  }\n  return undefined;\n}\n\nexport function paddingInner(padding: number, channel: Channel,  scaleConfig: ScaleConfig) {\n  if (padding !== undefined) {\n    // If user has already manually specified \"padding\", no need to add default paddingInner.\n    return undefined;\n  }\n\n  if (util.contains([X, Y], channel)) {\n    // Padding is only set for X and Y by default.\n    // Basically it doesn't make sense to add padding for color and size.\n\n    // paddingOuter would only be called if it's a band scale, just return the default for bandScale.\n    return scaleConfig.bandPaddingInner;\n  }\n  return undefined;\n}\n\nexport function paddingOuter(padding: number, channel: Channel, scaleType: ScaleType, paddingInner: number, scaleConfig: ScaleConfig) {\n  if (padding !== undefined) {\n    // If user has already manually specified \"padding\", no need to add default paddingOuter.\n    return undefined;\n  }\n\n  if (util.contains([X, Y], channel)) {\n    // Padding is only set for X and Y by default.\n    // Basically it doesn't make sense to add padding for color and size.\n    if (scaleType === ScaleType.BAND) {\n      if (scaleConfig.bandPaddingOuter !== undefined) {\n        return scaleConfig.bandPaddingOuter;\n      }\n      /* By default, paddingOuter is paddingInner / 2. The reason is that\n          size (width/height) = step * (cardinality - paddingInner + 2 * paddingOuter).\n          and we want the width/height to be integer by default.\n          Note that step (by default) and cardinality are integers.) */\n      return paddingInner / 2;\n    }\n  }\n  return undefined;\n}\n\nexport function round(channel: Channel, scaleConfig: ScaleConfig) {\n  if (util.contains(['x', 'y', 'row', 'column'], channel)) {\n    return scaleConfig.round;\n  }\n  return undefined;\n}\n\nexport function zero(specifiedScale: Scale, channel: Channel, fieldDef: FieldDef) {\n  // By default, return true only for the following cases:\n\n  // 1) using quantitative field with size\n  // While this can be either ratio or interval fields, our assumption is that\n  // ratio are more common.\n  if (channel === 'size' && fieldDef.type === 'quantitative') {\n    return true;\n  }\n\n  // 2) non-binned, quantitative x-scale or y-scale if no custom domain is provided.\n  // (For binning, we should not include zero by default because binning are calculated without zero.\n  // Similar, if users explicitly provide a domain range, we should not augment zero as that will be unexpected.)\n  if (!specifiedScale.domain && !fieldDef.bin && util.contains([X, Y], channel)) {\n    return true;\n  }\n  return false;\n}\n","import {VgScale} from '../../vega.schema';\n\n/** Scale suffix for scale used to get drive binned legends. */\nexport const BIN_LEGEND_SUFFIX = '_bin_legend';\n/** Scale suffix for scale for binned field's legend labels, which maps a binned field's quantitative values to range strings. */\nexport const BIN_LEGEND_LABEL_SUFFIX = '_bin_legend_label';\n\n// FIXME: With layer and concat, scaleComponent should decompose between\n// ScaleSignature and ScaleDomain[].\n// Basically, if two unit specs has the same scale, signature for a particular channel,\n// the scale can be unioned by combining the domain.\nexport type ScaleComponent = VgScale;\n\nexport type ScaleComponents = {\n  main: ScaleComponent;\n  binLegend?: ScaleComponent;\n  binLegendLabel?: ScaleComponent;\n};\n","import * as log from '../../log';\n\nimport {Config} from '../../config';\nimport {hasScale, supportScaleType, Channel} from '../../channel';\nimport {FieldDef, ScaleFieldDef} from '../../fielddef';\nimport {Mark} from '../../mark';\nimport {Scale, ScaleType} from '../../scale';\n\nimport * as util from '../../util';\n\n/**\n * Determine if there is a specified scale type and if it is appropriate,\n * or determine default type if type is unspecified or inappropriate.\n */\nexport default function type(fieldDef: ScaleFieldDef, channel: Channel,\n  mark: Mark, topLevelSize: number | undefined, config: Config): ScaleType {\n\n  if (!hasScale(channel)) {\n    // There is no scale for these channels\n    return null;\n  }\n  let specifiedScale = fieldDef.scale || {};\n  const specifiedType = specifiedScale.type;\n  if (specifiedType !== undefined) {\n    // Check if explicitly specified scale type is supported by the channel\n    if (supportScaleType(channel, specifiedType)) {\n      return specifiedType;\n    } else {\n      const newScaleType = defaultType(specifiedScale, fieldDef, channel, mark, topLevelSize, config);\n      log.warn(log.message.scaleTypeNotWorkWithChannel(channel, specifiedType, newScaleType));\n      return newScaleType;\n    }\n  }\n\n  return defaultType(specifiedScale, fieldDef, channel, mark, topLevelSize, config);\n}\n\n/**\n * Determine appropriate default scale type.\n */\nfunction defaultType(specifiedScale: Scale, fieldDef: FieldDef, channel: Channel,\n    mark: Mark, topLevelSize: number | undefined, config: Config): ScaleType {\n\n  if (util.contains(['row', 'column'], channel)) {\n    return ScaleType.BAND;\n  }\n\n  switch (fieldDef.type) {\n    case 'nominal':\n      if (channel === 'color' || channelRangeType(channel) === 'discrete') {\n        return ScaleType.ORDINAL;\n      }\n      return discreteToContinuousType(channel, mark, specifiedScale, topLevelSize, config);\n\n    case 'ordinal':\n      if (channel === 'color') {\n        return ScaleType.ORDINAL;\n      } else if (channelRangeType(channel) === 'discrete') {\n        log.warn(log.message.discreteChannelCannotEncode(channel, 'ordinal'));\n        return ScaleType.ORDINAL;\n      }\n      return discreteToContinuousType(channel, mark, specifiedScale, topLevelSize, config);\n\n    case 'temporal':\n      if (channel === 'color') {\n        // Always use `sequential` as the default color scale for continuous data\n        // since it supports both array range and scheme range.\n        return 'sequential';\n      } else if (channelRangeType(channel) === 'discrete') {\n        log.warn(log.message.discreteChannelCannotEncode(channel, 'temporal'));\n        // TODO: consider using quantize (equivalent to binning) once we have it\n        return ScaleType.ORDINAL;\n      }\n      switch (fieldDef.timeUnit) {\n        // These time unit use discrete scale by default\n        case 'hours':\n        case 'day':\n        case 'month':\n        case 'quarter':\n          return discreteToContinuousType(channel, mark, specifiedScale, topLevelSize, config);\n      }\n      return ScaleType.TIME;\n\n    case 'quantitative':\n      if (channel === 'color') {\n        // Always use `sequential` as the default color scale for continuous data\n        // since it supports both array range and scheme range.\n        return 'sequential';\n      } else if (channelRangeType(channel) === 'discrete') {\n        log.warn(log.message.discreteChannelCannotEncode(channel, 'quantitative'));\n        // TODO: consider using quantize (equivalent to binning) once we have it\n        return ScaleType.ORDINAL;\n      }\n      return ScaleType.LINEAR;\n  }\n\n  /* istanbul ignore next: should never reach this */\n  throw new Error(log.message.invalidFieldType(fieldDef.type));\n}\n\n/**\n * Determines default scale type for nominal/ordinal field.\n * @returns BAND or POINT scale based on channel, mark, and rangeStep\n */\nfunction discreteToContinuousType(channel: Channel, mark: Mark, specifiedScale: Scale, topLevelSize: number | undefined, config: Config): ScaleType {\n  if (util.contains(['x', 'y'], channel)) {\n    if (mark === 'rect') {\n      // The rect mark should fit into a band.\n      return ScaleType.BAND;\n    }\n    if (mark === 'bar') {\n      // For bar, use band only if there is no rangeStep since we need to use band for fit mode.\n      // However, for non-fit mode, point scale provides better center position.\n      if (haveRangeStep(specifiedScale, topLevelSize, config)) {\n        return ScaleType.POINT;\n      }\n      return ScaleType.BAND;\n    }\n  }\n  // Otherwise, use ordinal point scale so we can easily get center positions of the marks.\n  return ScaleType.POINT;\n}\n\nfunction haveRangeStep(specifiedScale: Scale, topLevelSize: number | undefined, config: Config) {\n  if (topLevelSize !== undefined) {\n    // if topLevelSize is provided, rangeStep will be dropped.\n    return false;\n  }\n  if (specifiedScale.rangeStep !== undefined) {\n    return specifiedScale.rangeStep !== null;\n  }\n  return !!config.scale.rangeStep;\n}\n\nexport function channelRangeType(channel: Channel):\n    'continuous' | 'discrete' | 'flexible' | undefined {\n\n  switch (channel) {\n    case 'x':\n    case 'y':\n    case 'row':\n    case 'column':\n    case 'size':\n    case 'opacity':\n      return 'continuous';\n\n    case 'shape':\n      return 'discrete';\n\n    // Color can be either continuous or discrete, depending on scale type.\n    case 'color':\n      return 'flexible';\n\n    // No scale, no range type.\n    case 'x2':\n    case 'y2':\n    case 'detail':\n    case 'text':\n    case 'order':\n      return undefined;\n  }\n  /* istanbul ignore next: should never reach here. */\n  throw new Error('getSupportedRole not implemented for' + channel);\n}\n","import * as log from '../log';\n\nimport {Axis} from '../axis';\nimport {X, Y, X2, Y2, Channel, UNIT_CHANNELS,  UNIT_SCALE_CHANNELS, NONSPATIAL_SCALE_CHANNELS, supportMark} from '../channel';\nimport {defaultConfig, Config, CellConfig} from '../config';\nimport {SOURCE, SUMMARY} from '../data';\nimport {Encoding} from '../encoding';\nimport * as vlEncoding from '../encoding'; // TODO: remove\nimport {ChannelDef, FieldDef, FieldRefOption, field, normalize, isFieldDef, isValueDef} from '../fielddef';\nimport {Legend} from '../legend';\nimport {Mark, TEXT as TEXTMARK, FILL_STROKE_CONFIG} from '../mark';\nimport {Scale, ScaleConfig, hasDiscreteDomain} from '../scale';\nimport {ExtendedUnitSpec} from '../spec';\nimport {duplicate, extend, isArray, mergeDeep, Dict} from '../util';\nimport {VgData} from '../vega.schema';\n\nimport {parseAxisComponent} from './axis/parse';\nimport {applyConfig} from './common';\nimport {initMarkConfig, initTextConfig} from './config';\nimport {assembleData, parseUnitData} from './data/data';\nimport {parseLegendComponent} from './legend/parse';\nimport {assembleLayout, parseUnitLayout} from './layout';\nimport {Model} from './model';\nimport {parseMark} from './mark/mark';\nimport initScale from './scale/init';\nimport parseScaleComponent from './scale/parse';\nimport {stack, StackProperties} from '../stack';\n\n/**\n * Internal model of Vega-Lite specification for the compiler.\n */\nexport class UnitModel extends Model {\n  /**\n   * Fixed width for the unit visualization.\n   * If undefined (e.g., for ordinal scale), the width of the\n   * visualization will be calculated dynamically.\n   */\n  private _width: number;\n\n  /**\n   * Fixed height for the unit visualization.\n   * If undefined (e.g., for ordinal scale), the height of the\n   * visualization will be calculated dynamically.\n   */\n  private _height: number;\n\n  private readonly _mark: Mark;\n  private readonly _encoding: Encoding;\n  private readonly _stack: StackProperties;\n\n  constructor(spec: ExtendedUnitSpec, parent: Model, parentGivenName: string) {\n    super(spec, parent, parentGivenName);\n\n    // use top-level width / height or parent's top-level width / height\n\n    // FIXME: once facet supports width/height, this is no longer correct!\n    const providedWidth = spec.width !== undefined ? spec.width :\n      parent ? parent['width'] : undefined; // only exists if parent is layer\n    const providedHeight = spec.height !== undefined ? spec.height :\n      parent ? parent['height'] : undefined; // only exists if parent is layer\n\n    const mark = this._mark = spec.mark;\n    const encoding = this._encoding = this._initEncoding(mark, spec.encoding || {});\n\n    // TODO?: ideally we should use config only inside this constructor\n    const config = this._config = this._initConfig(spec.config, parent);\n\n    // FIXME move stacked out of config as it's not really a theme.\n    // calculate stack properties\n    this._stack = stack(mark, encoding, config.mark.stacked);\n    this._scale =  this._initScale(mark, encoding, config, providedWidth, providedHeight);\n\n    // TODO?: refactor these to be a part of the model as they are not really just config\n    config.mark = initMarkConfig(mark, encoding, this._scale, this._stack, config);\n    if (mark === 'text') { // FIXME: maybe we should refactor this\n      config.text = initTextConfig(encoding, config);\n    }\n\n    this._axis = this._initAxis(encoding, config);\n    this._legend = this._initLegend(encoding, config);\n\n    // width / height\n    this._initSize(mark, this._scale,\n      providedWidth,\n      providedHeight,\n      config.cell, config.scale\n    );\n  }\n\n  private _initEncoding(mark: Mark, encoding: Encoding) {\n    // clone to prevent side effect to the original spec\n    encoding = duplicate(encoding);\n\n    Object.keys(encoding).forEach((channel: any) => {\n      if (!supportMark(channel, mark)) {\n        // Drop unsupported channel\n\n        log.warn(log.message.incompatibleChannel(channel, mark));\n        delete encoding[channel];\n        return;\n      }\n\n      if (isArray(encoding[channel])) {\n        // Array of fieldDefs for detail channel (or production rule)\n        encoding[channel] = encoding[channel].reduce((channelDefs: ChannelDef[], channelDef: ChannelDef) => {\n          if (!isFieldDef(channelDef) && !isValueDef(channelDef)) { // TODO: datum\n            log.warn(log.message.emptyFieldDef(channelDef, channel));\n          } else {\n            channelDefs.push(normalize(channelDef, channel));\n          }\n          return channelDefs;\n        }, []);\n      } else {\n        const fieldDef = encoding[channel];\n        if (fieldDef.field === undefined && fieldDef.value === undefined) { // TODO: datum\n          log.warn(log.message.emptyFieldDef(fieldDef, channel));\n          delete encoding[channel];\n          return;\n        }\n        normalize(fieldDef, channel);\n      }\n    });\n    return encoding;\n  }\n\n  /**\n   * Init config by merging config from parent and, if applicable, from facet config\n   */\n  private _initConfig(specConfig: Config, parent: Model) {\n    let config = mergeDeep(duplicate(defaultConfig), parent ? parent.config() : {}, specConfig);\n    let hasFacetParent = false;\n    while (parent !== null) {\n      if (parent.isFacet()) {\n        hasFacetParent = true;\n        break;\n      }\n      parent = parent.parent();\n    }\n\n    if (hasFacetParent) {\n      config.cell = extend({}, config.cell, config.facet.cell);\n    }\n    return config;\n  }\n\n  private _initScale(mark: Mark, encoding: Encoding, config: Config, topLevelWidth:number, topLevelHeight: number): Dict<Scale> {\n    const xyRangeSteps: number[] = [];\n\n    return UNIT_SCALE_CHANNELS.reduce(function(_scale, channel) {\n      if (vlEncoding.channelHasField(encoding, channel) ||\n          (channel === X && vlEncoding.channelHasField(encoding, X2)) ||\n          (channel === Y && vlEncoding.channelHasField(encoding, Y2))\n        ) {\n        const scale = _scale[channel] = initScale(\n          channel, encoding[channel], config, mark,\n          channel === X ? topLevelWidth : channel === Y ? topLevelHeight : undefined,\n          xyRangeSteps // for determine point / bar size\n        );\n\n        if (channel === X || channel === Y) {\n          if (scale.rangeStep) {\n            xyRangeSteps.push(scale.rangeStep);\n          }\n        }\n      }\n      return _scale;\n    }, {});\n  }\n\n  // TODO: consolidate this with scale?  Current scale range is in parseScale (later),\n  // but not in initScale because scale range depends on size,\n  // but size depends on scale type and rangeStep\n  private _initSize(mark: Mark, scale: Dict<Scale>, width: number, height: number, cellConfig: CellConfig, scaleConfig: ScaleConfig) {\n    if (width !== undefined) {\n      this._width = width;\n    } else if (scale[X]) {\n      if (!hasDiscreteDomain(scale[X].type) || !scale[X].rangeStep) {\n        this._width = cellConfig.width;\n      } // else: Do nothing, use dynamic width.\n    } else { // No scale X\n      if (mark === TEXTMARK) {\n        // for text table without x/y scale we need wider rangeStep\n        this._width = scaleConfig.textXRangeStep;\n      } else {\n        if (typeof scaleConfig.rangeStep === 'string') {\n          throw new Error('_initSize does not handle string rangeSteps');\n        }\n        this._width = scaleConfig.rangeStep;\n      }\n    }\n\n    if (height !== undefined) {\n      this._height = height;\n    } else if (scale[Y]) {\n      if (!hasDiscreteDomain(scale[Y].type) || !scale[Y].rangeStep) {\n        this._height = cellConfig.height;\n      } // else: Do nothing, use dynamic height .\n    } else {\n      if (typeof scaleConfig.rangeStep === 'string') {\n        throw new Error('_initSize does not handle string rangeSteps');\n      }\n      this._height = scaleConfig.rangeStep;\n    }\n  }\n\n  private _initAxis(encoding: Encoding, config: Config): Dict<Axis> {\n    return [X, Y].reduce(function(_axis, channel) {\n      // Position Axis\n\n      const channelDef = encoding[channel];\n      if (isFieldDef(channelDef) ||\n          (channel === X && isFieldDef(encoding.x2)) ||\n          (channel === Y && isFieldDef(encoding.y2))) {\n\n        const axisSpec = isFieldDef(channelDef) ? channelDef.axis : null;\n\n        // We no longer support false in the schema, but we keep false here for backward compatability.\n        if (axisSpec !== null && axisSpec !== false) {\n          _axis[channel] = extend({},\n            config.axis,\n            axisSpec === true ? {} : axisSpec ||  {}\n          );\n        }\n      }\n      return _axis;\n    }, {});\n  }\n\n  private _initLegend(encoding: Encoding, config: Config): Dict<Legend> {\n    return NONSPATIAL_SCALE_CHANNELS.reduce(function(_legend, channel) {\n      const channelDef = encoding[channel];\n      if (isFieldDef(channelDef)) {\n        const legendSpec = channelDef.legend;\n        // We no longer support false in the schema, but we keep false here for backward compatability.\n        if (legendSpec !== null && legendSpec !== false) {\n          _legend[channel] = extend({}, config.legend,\n            legendSpec === true ? {} : legendSpec ||  {}\n          );\n        }\n      }\n      return _legend;\n    }, {});\n  }\n\n  public children(): Model[] {\n    return [];\n  }\n\n  public get width(): number {\n    return this._width;\n  }\n\n  public get height(): number {\n    return this._height;\n  }\n\n  public parseData() {\n    this.component.data = parseUnitData(this);\n  }\n\n  public parseSelectionData() {\n    // TODO: @arvind can write this\n    // We might need to split this into compileSelectionData and compileSelectionSignals?\n  }\n\n  public parseLayoutData() {\n    this.component.layout = parseUnitLayout(this);\n  }\n\n  public parseScale() {\n    this.component.scale = parseScaleComponent(this);\n  }\n\n  public parseMark() {\n    this.component.mark = parseMark(this);\n  }\n\n  public parseAxis() {\n    this.component.axis = parseAxisComponent(this, [X, Y]);\n  }\n\n  public parseAxisGroup(): void {\n    return null;\n  }\n\n  public parseGridGroup(): void {\n    return null;\n  }\n\n  public parseLegend() {\n    this.component.legend = parseLegendComponent(this);\n  }\n\n  public assembleData(data: VgData[]): VgData[] {\n    return assembleData(this, data);\n  }\n\n  public assembleLayout(layoutData: VgData[]): VgData[] {\n    return assembleLayout(this, layoutData);\n  }\n\n  public assembleMarks() {\n    return this.component.mark;\n  }\n\n  public assembleParentGroupProperties(cellConfig: CellConfig) {\n    return applyConfig({}, cellConfig, FILL_STROKE_CONFIG.concat(['clip']));\n  }\n\n  public channels() {\n    return UNIT_CHANNELS;\n  }\n\n  protected mapping() {\n    return this.encoding();\n  }\n\n  public stack(): StackProperties {\n    return this._stack;\n  }\n\n  public toSpec(excludeConfig?: any, excludeData?: any) {\n    const encoding = duplicate(this._encoding);\n    let spec: any;\n\n    spec = {\n      mark: this._mark,\n      encoding: encoding\n    };\n\n    if (!excludeConfig) {\n      spec.config = duplicate(this._config);\n    }\n\n    if (!excludeData) {\n      spec.data = duplicate(this._data);\n    }\n\n    // remove defaults\n    return spec;\n  }\n\n  public mark(): Mark {\n    return this._mark;\n  }\n\n  public channelHasField(channel: Channel) {\n    return vlEncoding.channelHasField(this._encoding, channel);\n  }\n\n  public encoding() {\n    return this._encoding;\n  }\n\n  public fieldDef(channel: Channel): FieldDef {\n    // TODO: remove this || {}\n    // Currently we have it to prevent null pointer exception.\n    return this._encoding[channel] || {};\n  }\n\n  /** Get \"field\" reference for vega */\n  public field(channel: Channel, opt: FieldRefOption = {}) {\n    const fieldDef = this.fieldDef(channel);\n\n    if (fieldDef.bin) { // bin has default suffix that depends on scaleType\n      opt = extend({\n        binSuffix: hasDiscreteDomain(this.scale(channel).type) ? 'range' : 'start'\n      }, opt);\n    }\n\n    return field(fieldDef, opt);\n  }\n\n  public dataTable() {\n    return this.dataName(vlEncoding.isAggregate(this._encoding) ? SUMMARY : SOURCE);\n  }\n\n  public isUnit() {\n    return true;\n  }\n}\n","import {AxisConfig, defaultAxisConfig, defaultFacetAxisConfig} from './axis';\nimport {LegendConfig, defaultLegendConfig} from './legend';\nimport {MarkConfig, AreaConfig, BarConfig, LineConfig, PointConfig, RectConfig, RuleConfig, SymbolConfig, TextConfig, TickConfig} from './mark';\nimport * as mark from './mark';\nimport {ScaleConfig, defaultScaleConfig} from './scale';\nimport {Padding} from './spec';\n\nexport interface CellConfig {\n  width?: number;\n  height?: number;\n\n  clip?: boolean;\n\n  // FILL_STROKE_CONFIG\n  /**\n   * The fill color.\n   */\n  fill?: string;\n\n  /** The fill opacity (value between [0,1]). */\n  fillOpacity?: number;\n\n  /** The stroke color. */\n  stroke?: string;\n\n  /** The stroke opacity (value between [0,1]). */\n  strokeOpacity?: number;\n\n  /** The stroke width, in pixels. */\n  strokeWidth?: number;\n\n  /** An array of alternating stroke, space lengths for creating dashed or dotted lines. */\n  strokeDash?: number[];\n\n  /** The offset (in pixels) into which to begin drawing with the stroke dash array. */\n  strokeDashOffset?: number;\n}\n\nexport const defaultCellConfig: CellConfig = {\n  width: 200,\n  height: 200\n};\n\nexport const defaultFacetCellConfig: CellConfig = {\n  stroke: '#ccc',\n  strokeWidth: 1\n};\n\nexport interface FacetConfig {\n  /** Facet Axis Config */\n  axis?: AxisConfig;\n\n  /** Facet Grid Config */\n  grid?: FacetGridConfig;\n\n  /** Facet Cell Config */\n  cell?: CellConfig;\n}\n\nexport interface FacetGridConfig {\n  color?: string;\n  opacity?: number;\n  offset?: number;\n}\n\nconst defaultFacetGridConfig: FacetGridConfig = {\n  color: '#000000',\n  opacity: 0.4,\n  offset: 0\n};\n\nexport const defaultFacetConfig: FacetConfig = {\n  axis: defaultFacetAxisConfig,\n  grid: defaultFacetGridConfig,\n  cell: defaultFacetCellConfig\n};\n\n// FIXME refactor this\nexport namespace AreaOverlay {\n  export const LINE: 'line' = 'line';\n  export const LINEPOINT: 'linepoint' = 'linepoint';\n  export const NONE: 'none' = 'none';\n}\nexport type AreaOverlay = typeof AreaOverlay.LINE | typeof AreaOverlay.LINEPOINT | typeof AreaOverlay.NONE;\n\nexport interface OverlayConfig {\n  /**\n   * Whether to overlay line with point.\n   */\n  line?: boolean;\n\n  /**\n   * Type of overlay for area mark (line or linepoint)\n   */\n  area?: AreaOverlay;\n\n  /**\n   * Default style for the overlayed point.\n   */\n  pointStyle?: MarkConfig;\n\n  /**\n   * Default style for the overlayed point.\n   */\n  lineStyle?: MarkConfig;\n}\n\nexport const defaultOverlayConfig: OverlayConfig = {\n  line: false,\n  pointStyle: {filled: true},\n  lineStyle: {}\n};\n\nexport interface Config {\n  // TODO: add this back once we have top-down layout approach\n  // width?: number;\n  // height?: number;\n  // padding?: number|string;\n  /**\n   * The width and height of the on-screen viewport, in pixels. If necessary, clipping and scrolling will be applied.\n   */\n  viewport?: number;\n  /**\n   * CSS color property to use as background of visualization. Default is `\"transparent\"`.\n   */\n  background?: string;\n\n  /**\n   * The default visualization padding, in pixels, from the edge of the visualization canvas to the data rectangle. This can be a single number or an object with `\"top\"`, `\"left\"`, `\"right\"`, `\"bottom\"` properties.\n   *\n   * __Default value__: `5`\n   *\n   * * @minimum 0\n   */\n  padding?: Padding;\n\n  /**\n   * D3 Number format for axis labels and text tables. For example \"s\" for SI units.\n   */\n  numberFormat?: string;\n\n  /**\n   * Default datetime format for axis and legend labels. The format can be set directly on each axis and legend.\n   */\n  timeFormat?: string;\n\n  /**\n   * Default axis and legend title for count fields.\n   * @type {string}\n   */\n  countTitle?: string;\n\n  /** Cell Config */\n  cell?: CellConfig;\n\n  /** Mark Config */\n  mark?: MarkConfig;\n\n  // MARK-SPECIFIC CONFIGS\n  /** Area-Specific Config */\n  area?: AreaConfig;\n\n  /** Bar-Specific Config */\n  bar?: BarConfig;\n\n  /** Circle-Specific Config */\n  circle?: SymbolConfig;\n\n  /** Line-Specific Config */\n  line?: LineConfig;\n\n  /** Point-Specific Config */\n  point?: PointConfig;\n\n  /** Rect-Specific Config */\n  rect?: RectConfig;\n\n  /** Rule-Specific Config */\n  rule?: RuleConfig;\n\n  /** Square-Specific Config */\n  square?: SymbolConfig;\n\n  /** Text-Specific Config */\n  text?: TextConfig;\n\n  /** Tick-Specific Config */\n  tick?: TickConfig;\n\n  // OTHER CONFIG\n\n  // FIXME: move this to line/area\n  /** Mark Overlay Config */\n  overlay?: OverlayConfig;\n\n  /** Scale Config */\n  scale?: ScaleConfig;\n\n  /** Axis Config */\n  axis?: AxisConfig;\n\n  /** Legend Config */\n  legend?: LegendConfig;\n\n  /** Facet Config */\n  facet?: FacetConfig;\n}\n\nexport const defaultConfig: Config = {\n  padding: 5,\n  numberFormat: 's',\n  timeFormat: '%b %d, %Y',\n  countTitle: 'Number of Records',\n\n  cell: defaultCellConfig,\n\n  mark: mark.defaultMarkConfig,\n  area: mark.defaultAreaConfig,\n  bar: mark.defaultBarConfig,\n  circle: mark.defaultCircleConfig,\n  line: mark.defaultLineConfig,\n  point: mark.defaultPointConfig,\n  rect: mark.defaultRectConfig,\n  rule: mark.defaultRuleConfig,\n  square: mark.defaultSquareConfig,\n  text: mark.defaultTextConfig,\n  tick: mark.defaultTickConfig,\n\n  overlay: defaultOverlayConfig,\n  scale: defaultScaleConfig,\n  axis: defaultAxisConfig,\n  legend: defaultLegendConfig,\n\n  facet: defaultFacetConfig,\n};\n","/*\n * Constants and utilities for data.\n */\n\nexport interface DataFormat {\n  /**\n   * Type of input data: `\"json\"`, `\"csv\"`, `\"tsv\"`.\n   * The default format type is determined by the extension of the file url.\n   * If no extension is detected, `\"json\"` will be used by default.\n   */\n  type?: DataFormatType;\n\n  /**\n   * A collection of parsing instructions can be used to define the data types of string-valued attributes in the JSON file. Each instruction is a name-value pair, where the name is the name of the attribute, and the value is the desired data type (one of `\"number\"`, `\"boolean\"` or `\"date\"`). For example, `\"parse\": {\"modified_on\":\"date\"}` ensures that the `modified_on` value in each row of the input data is parsed as a Date value. (See Datalib's [`dl.read.types` method](https://github.com/vega/datalib/wiki/Import#dl_read_types) for more information.)\n   */\n  parse?: any;\n\n  /**\n   * JSON only) The JSON property containing the desired data.\n   * This parameter can be used when the loaded JSON file may have surrounding structure or meta-data.\n   * For example `\"property\": \"values.features\"` is equivalent to retrieving `json.values.features`\n   * from the loaded JSON object.\n   */\n  property?: string;\n\n  /**\n   * The name of the TopoJSON object set to convert to a GeoJSON feature collection.\n   * For example, in a map of the world, there may be an object set named `\"countries\"`.\n   * Using the feature property, we can extract this set and generate a GeoJSON feature object for each country.\n   */\n  feature?: string;\n  /**\n   * The name of the TopoJSON object set to convert to a mesh.\n   * Similar to the `feature` option, `mesh` extracts a named TopoJSON object set.\n   *  Unlike the `feature` option, the corresponding geo data is returned as a single, unified mesh instance, not as individual GeoJSON features.\n   * Extracting a mesh is useful for more efficiently drawing borders or other geographic elements that you do not need to associate with specific regions such as individual countries, states or counties.\n   */\n  mesh?: string;\n}\n\nexport namespace DataFormatType {\n    export const JSON: 'json' = 'json';\n    export const CSV: 'csv' = 'csv';\n    export const TSV: 'tsv' = 'tsv';\n    export const TOPOJSON: 'topojson' = 'topojson';\n}\n\nexport type DataFormatType = typeof DataFormatType.JSON | typeof DataFormatType.CSV | typeof DataFormatType.TSV | typeof DataFormatType.TOPOJSON;\n\nexport type Data = UrlData | InlineData;\n\nexport interface UrlData {\n  /**\n   * An object that specifies the format for the data file or values.\n   */\n  format?: DataFormat;\n\n  /**\n   * A URL from which to load the data set. Use the format.type property\n   * to ensure the loaded data is correctly parsed.\n   */\n  url: string;\n}\n\nexport interface InlineData {\n  /**\n   * Pass array of objects instead of a url to a file.\n   */\n  values: any[];\n}\n\nexport function isUrlData(data: Data): data is UrlData {\n  return !!data['url'];\n}\n\nexport function isInlineData(data: Data): data is InlineData {\n  return !!data['values'];\n}\n\nexport type DataSourceType = 'source' | 'summary' | 'stacked' | 'layout';\n\nexport const SUMMARY: 'summary' = 'summary';\nexport const SOURCE: 'source' = 'source';\nexport const STACKED: 'stacked' = 'stacked';\nexport const LAYOUT: 'layout' = 'layout';\n\n","// DateTime definition object\n\nimport {duplicate, keys, isNumber} from './util';\nimport * as log from './log';\n\n/*\n * A designated year that starts on Sunday.\n */\nconst SUNDAY_YEAR = 2006;\n\n/**\n * @minimum 1\n * @maximum 12\n * @TJS-type integer\n */\nexport type Month = number;\n\n/**\n * @minimum 1\n * @maximum 7\n */\nexport type Day = number;\n\n/**\n * Object for defining datetime in Vega-Lite Filter.\n * If both month and quarter are provided, month has higher precedence.\n * `day` cannot be combined with other date.\n * We accept string for month and day names.\n */\nexport interface DateTime {\n  /**\n   * Integer value representing the year.\n   * @TJS-type integer\n   */\n  year?: number;\n\n  /**\n   * Integer value representing the quarter of the year (from 1-4).\n   * @minimum 1\n   * @maximum 4\n   * @TJS-type integer\n   */\n  quarter?: number;\n\n  /** One of: (1) integer value representing the month from `1`-`12`. `1` represents January;  (2) case-insensitive month name (e.g., `\"January\"`);  (3) case-insensitive, 3-character short month name (e.g., `\"Jan\"`). */\n  month?: Month | string;\n\n  /**\n   * Integer value representing the date from 1-31.\n   * @minimum 1\n   * @maximum 31\n   * @TJS-type integer\n   */\n  date?: number;\n\n  /**\n   * Value representing the day of week.  This can be one of: (1) integer value -- `1` represents Monday; (2) case-insensitive day name (e.g., `\"Monday\"`);  (3) case-insensitive, 3-character short day name (e.g., `\"Mon\"`).   <br/> **Warning:** A DateTime definition object with `day`** should not be combined with `year`, `quarter`, `month`, or `date`.\n   */\n  day?: Day | string;\n\n  /**\n   * Integer value representing the hour of day from 0-23.\n   * @minimum 0\n   * @maximum 23\n   * @TJS-type integer\n   */\n  hours?: number;\n\n  /**\n   * Integer value representing minute segment of a time from 0-59.\n   * @minimum 0\n   * @maximum 59\n   * @TJS-type integer\n   */\n  minutes?: number;\n\n  /**\n   * Integer value representing second segment of a time from 0-59.\n   * @minimum 0\n   * @maximum 59\n   * @TJS-type integer\n   */\n  seconds?: number;\n\n  /**\n   * Integer value representing millisecond segment of a time.\n   * @minimum 0\n   * @maximum 999\n   * @TJS-type integer\n   */\n  milliseconds?: number;\n}\n\n\n/**\n * Internal Object for defining datetime expressions.\n * This is an expression version of DateTime.\n * If both month and quarter are provided, month has higher precedence.\n * `day` cannot be combined with other date.\n */\nexport interface DateTimeExpr {\n  year?: string;\n  quarter?: string;\n  month?: string;\n  date?: string;\n  day?: string;\n  hours?: string;\n  minutes?: string;\n  seconds?: string;\n  milliseconds?: string;\n}\n\nexport function isDateTime(o: any): o is DateTime {\n  return !!o && (!!o.year || !!o.quarter || !!o.month || !!o.date || !!o.day ||\n    !!o.hours || !!o.minutes || !!o.seconds || !!o.milliseconds);\n}\n\nexport const MONTHS = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december'];\nexport const SHORT_MONTHS = MONTHS.map((m) => m.substr(0, 3));\n\nexport const DAYS = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];\nexport const SHORT_DAYS = DAYS.map((d) => d.substr(0,3));\n\nfunction normalizeQuarter(q: number | string) {\n  if (isNumber(q)) {\n    if (q > 4) {\n      log.warn(log.message.invalidTimeUnit('quarter', q));\n    }\n    // We accept 1-based quarter, so need to readjust to 0-based quarter\n    return (q - 1) + '';\n  } else {\n    // Invalid quarter\n    throw new Error(log.message.invalidTimeUnit('quarter', q));\n  }\n}\n\nfunction normalizeMonth(m: string | number) {\n  if (isNumber(m)) {\n    // We accept 1-based month, so need to readjust to 0-based month\n    return (m - 1) + '';\n  } else {\n    const lowerM = m.toLowerCase();\n    const monthIndex = MONTHS.indexOf(lowerM);\n    if (monthIndex !== -1) {\n      return monthIndex + ''; // 0 for january, ...\n    }\n    const shortM = lowerM.substr(0, 3);\n    const shortMonthIndex = SHORT_MONTHS.indexOf(shortM);\n    if (shortMonthIndex !== -1) {\n      return shortMonthIndex + '';\n    }\n    // Invalid month\n    throw new Error(log.message.invalidTimeUnit('month', m));\n  }\n}\n\nfunction normalizeDay(d: string | number) {\n  if (isNumber(d)) {\n    // mod so that this can be both 0-based where 0 = sunday\n    // and 1-based where 7=sunday\n    return (d % 7) + '';\n  } else {\n    const lowerD = d.toLowerCase();\n    const dayIndex = DAYS.indexOf(lowerD);\n    if (dayIndex !== -1) {\n      return dayIndex + ''; // 0 for january, ...\n    }\n    const shortD = lowerD.substr(0, 3);\n    const shortDayIndex = SHORT_DAYS.indexOf(shortD);\n    if (shortDayIndex !== -1) {\n      return shortDayIndex + '';\n    }\n    // Invalid day\n    throw new Error(log.message.invalidTimeUnit('day', d));\n  }\n}\n\nexport function timestamp(d: DateTime, normalize: boolean) {\n  const date = new Date(0, 0, 1, 0, 0, 0, 0); // start with uniform date\n\n  // FIXME support UTC\n\n  if (d.day !== undefined) {\n    if (keys(d).length > 1) {\n      log.warn(log.message.droppedDay(d));\n      d = duplicate(d);\n      delete d.day;\n    } else {\n      // Use a year that has 1/1 as Sunday so we can setDate below\n      date.setFullYear(SUNDAY_YEAR);\n\n      const day = normalize ? normalizeDay(d.day) : d.day;\n      date.setDate(+day + 1); // +1 since date start at 1 in JS\n    }\n  }\n\n  if (d.year !== undefined) {\n    date.setFullYear(d.year);\n  }\n\n  if (d.quarter !== undefined) {\n    const quarter = normalize ? normalizeQuarter(d.quarter) : d.quarter;\n    date.setMonth(+quarter * 3);\n  }\n\n  if (d.month !== undefined) {\n    const month = normalize ? normalizeMonth(d.month) : d.month;\n    date.setMonth(+month);\n  }\n\n  if (d.date !== undefined) {\n    date.setDate(d.date);\n  }\n\n  if (d.hours !== undefined) {\n    date.setHours(d.hours);\n  }\n\n  if (d.minutes !== undefined) {\n    date.setMinutes(d.minutes);\n  }\n\n  if (d.seconds !== undefined) {\n    date.setSeconds(d.seconds);\n  }\n\n  if (d.milliseconds !== undefined) {\n    date.setMilliseconds(d.milliseconds);\n  }\n\n  return date.getTime();\n}\n\n/**\n * Return Vega Expression for a particular date time.\n * @param d\n * @param normalize whether to normalize quarter, month, day.\n */\nexport function dateTimeExpr(d: DateTime | DateTimeExpr, normalize = false) {\n  const units: (string | number)[] = [];\n\n  if (normalize && d.day !== undefined) {\n    if (keys(d).length > 1) {\n      log.warn(log.message.droppedDay(d));\n      d = duplicate(d);\n      delete d.day;\n    }\n  }\n\n  if (d.year !== undefined) {\n    units.push(d.year);\n  } else if (d.day !== undefined) {\n    // Set year to 2006 for working with day since January 1 2006 is a Sunday\n    units.push(SUNDAY_YEAR);\n  } else {\n    units.push(0);\n  }\n\n  if (d.month !== undefined) {\n    const month = normalize ? normalizeMonth(d.month) : d.month;\n    units.push(month);\n  } else if (d.quarter !== undefined) {\n    const quarter = normalize ? normalizeQuarter(d.quarter) : d.quarter;\n    units.push(quarter + '*3');\n  } else {\n    units.push(0); // months start at zero in JS\n  }\n\n  if (d.date !== undefined) {\n    units.push(d.date);\n  } else if (d.day !== undefined) {\n    // HACK: Day only works as a standalone unit\n    // This is only correct because we always set year to 2006 for day\n    const day = normalize ? normalizeDay(d.day) : d.day;\n    units.push(day + '+1');\n  } else {\n    units.push(1); // Date starts at 1 in JS\n  }\n\n  // Note: can't use TimeUnit enum here as importing it will create\n  // circular dependency problem!\n  for (let timeUnit of ['hours', 'minutes', 'seconds', 'milliseconds']) {\n    if (d[timeUnit] !== undefined) {\n      units.push(d[timeUnit]);\n    } else {\n      units.push(0);\n    }\n  }\n\n  return 'datetime(' + units.join(', ') + ')';\n}\n","// utility for encoding mapping\nimport {FieldDef, PositionFieldDef, FacetFieldDef, LegendFieldDef, OrderFieldDef, ValueDef, isFieldDef} from './fielddef';\nimport {Channel, CHANNELS} from './channel';\nimport {isArray, some} from './util';\n\n// TODO: once we decompose facet, rename this to Encoding\nexport interface UnitEncoding {\n  /**\n   * X coordinates for `point`, `circle`, `square`,\n   * `line`, `rule`, `text`, and `tick`\n   * (or to width and height for `bar` and `area` marks).\n   */\n  x?: PositionFieldDef | ValueDef<number>;\n\n  /**\n   * Y coordinates for `point`, `circle`, `square`,\n   * `line`, `rule`, `text`, and `tick`\n   * (or to width and height for `bar` and `area` marks).\n   */\n  y?: PositionFieldDef | ValueDef<number>;\n\n  /**\n   * X2 coordinates for ranged `bar`, `rule`, `area`\n   */\n  x2?: FieldDef | ValueDef<number>;\n\n  /**\n   * Y2 coordinates for ranged `bar`, `rule`, `area`\n   */\n  y2?: FieldDef | ValueDef<number>;\n\n  /**\n   * Color of the marks – either fill or stroke color based on mark type.\n   * (By default, fill color for `area`, `bar`, `tick`, `text`, `circle`, and `square` /\n   * stroke color for `line` and `point`.)\n   */\n  color?: LegendFieldDef | ValueDef<string>;\n\n  /**\n   * Opacity of the marks – either can be a value or in a range.\n   */\n  opacity?: LegendFieldDef | ValueDef<number>;\n\n  /**\n   * Size of the mark.\n   * - For `point`, `square` and `circle`\n   * – the symbol size, or pixel area of the mark.\n   * - For `bar` and `tick` – the bar and tick's size.\n   * - For `text` – the text's font size.\n   * - Size is currently unsupported for `line` and `area`.\n   */\n  size?: LegendFieldDef | ValueDef<number>;\n\n  /**\n   * The symbol's shape (only for `point` marks). The supported values are\n   * `\"circle\"` (default), `\"square\"`, `\"cross\"`, `\"diamond\"`, `\"triangle-up\"`,\n   * or `\"triangle-down\"`, or else a custom SVG path string.\n   */\n  shape?: LegendFieldDef | ValueDef<string>; // TODO: maybe distinguish ordinal-only\n\n  /**\n   * Additional levels of detail for grouping data in aggregate views and\n   * in line and area marks without mapping data to a specific visual channel.\n   */\n  detail?: FieldDef | FieldDef[];\n\n  /**\n   * Text of the `text` mark.\n   */\n  text?: FieldDef | ValueDef<string|number>;\n\n  /**\n   * stack order for stacked marks or order of data points in line marks.\n   */\n  order?: OrderFieldDef | OrderFieldDef[];\n}\n\n// TODO: once we decompose facet, rename this to ExtendedEncoding\nexport interface Encoding extends UnitEncoding {\n  /**\n   * Vertical facets for trellis plots.\n   */\n  row?: FacetFieldDef;\n\n  /**\n   * Horizontal facets for trellis plots.\n   */\n  column?: FacetFieldDef;\n}\n\nexport function channelHasField(encoding: Encoding, channel: Channel): boolean {\n  const channelDef = encoding && encoding[channel];\n  if (channelDef) {\n    if (isArray(channelDef)) {\n      return some(channelDef, (fieldDef) => !!fieldDef.field);\n    } else {\n      return isFieldDef(channelDef);\n    }\n  }\n  return false;\n}\n\nexport function isAggregate(encoding: Encoding) {\n  return some(CHANNELS, (channel) => {\n    if (channelHasField(encoding, channel)) {\n      const channelDef = encoding[channel];\n      if (isArray(channelDef)) {\n        return some(channelDef, (fieldDef) => !!fieldDef.aggregate);\n      } else {\n        return isFieldDef(channelDef) && !!channelDef.aggregate;\n      }\n    }\n    return false;\n  });\n}\n\nexport function isRanged(encoding: Encoding) {\n  return encoding && ((!!encoding.x && !!encoding.x2) || (!!encoding.y && !!encoding.y2));\n}\n\nexport function fieldDefs(encoding: Encoding): FieldDef[] {\n  let arr: FieldDef[] = [];\n  CHANNELS.forEach(function(channel) {\n    if (channelHasField(encoding, channel)) {\n      const channelDef = encoding[channel];\n      (isArray(channelDef) ? channelDef : [channelDef]).forEach((fieldDef) => {\n        arr.push(fieldDef);\n      });\n    }\n  });\n  return arr;\n};\n\nexport function forEach(mapping: any,\n    f: (fd: FieldDef, c: Channel) => void,\n    thisArg?: any) {\n  if (!mapping) {\n    return;\n  }\n\n  Object.keys(mapping).forEach((c: any) => {\n    const channel: Channel = c;\n    if (isArray(mapping[channel])) {\n      mapping[channel].forEach(function(fieldDef: FieldDef) {\n        f.call(thisArg, fieldDef, channel);\n      });\n    } else {\n      f.call(thisArg, mapping[channel], channel);\n    }\n  });\n}\n\nexport function reduce<T>(mapping: any,\n    f: (acc: any, fd: FieldDef, c: Channel) => any,\n    init: T, thisArg?: any) {\n  if (!mapping) {\n    return init;\n  }\n\n  return Object.keys(mapping).reduce((r: T, c: any) => {\n    const channel: Channel = c;\n    if (isArray(mapping[channel])) {\n      return mapping[channel].reduce(function(r1: T, fieldDef: FieldDef) {\n        return f.call(thisArg, r1, fieldDef, channel);\n      }, r);\n    } else {\n      return f.call(thisArg, r, mapping[channel], channel);\n    }\n  }, init);\n}\n","// utility for a field definition object\n\nimport {AggregateOp} from './aggregate';\nimport {Axis} from './axis';\nimport {Bin} from './bin';\nimport {Channel, getSupportedRole} from './channel';\nimport {Config} from './config';\nimport {Legend} from './legend';\nimport * as log from './log';\nimport {Scale} from './scale';\nimport {SortField, SortOrder} from './sort';\nimport {TimeUnit} from './timeunit';\nimport {Type, NOMINAL, ORDINAL, QUANTITATIVE, TEMPORAL, getFullName} from './type';\nimport {contains} from './util';\n\n/**\n * Definition object for a constant value of an encoding channel.\n */\nexport interface ValueDef<T> {\n  /**\n   * A constant value in visual domain.\n   */\n  value?: T;\n}\n\n/**\n *  Definition object for a data field, its type and transformation of an encoding channel.\n */\nexport interface FieldDef {\n  /**\n   * Name of the field from which to pull a data value.\n   */\n  field?: string;\n\n  /**\n   * The encoded field's type of measurement. This can be either a full type\n   * name (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`,  and `\"nominal\"`)\n   * or an initial character of the type name (`\"Q\"`, `\"T\"`, `\"O\"`, `\"N\"`).\n   * This property is case insensitive.\n   */\n  type?: Type;\n\n\n  // function\n\n  /**\n   * Time unit for a `temporal` field  (e.g., `year`, `yearmonth`, `month`, `hour`).\n   */\n  timeUnit?: TimeUnit;\n\n  /**\n   * Flag for binning a `quantitative` field, or a bin property object\n   * for binning parameters.\n   */\n  bin?: boolean | Bin;\n\n  /**\n   * Aggregation function for the field\n   * (e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).\n   */\n  aggregate?: AggregateOp;\n\n  /**\n   * Title for axis or legend.\n   */\n  title?: string;\n}\n\nexport interface ScaleFieldDef extends FieldDef {\n  scale?: Scale;\n  sort?: SortField | SortOrder;\n}\n\nexport interface PositionFieldDef extends ScaleFieldDef {\n  /**\n   * @nullable\n   */\n  axis?: Axis;\n}\nexport interface LegendFieldDef extends ScaleFieldDef {\n   /**\n    * @nullable\n    */\n  legend?: Legend;\n}\n\n// Detail\n\n// Order Path have no scale\n\nexport interface OrderFieldDef extends FieldDef {\n  sort?: SortOrder;\n}\n\nexport type ChannelDef = FieldDef | ValueDef<any>;\n\nexport function isFieldDef(channelDef: ChannelDef): channelDef is FieldDef | PositionFieldDef | LegendFieldDef | OrderFieldDef  {\n  return channelDef && !!channelDef['field'];\n}\n\nexport function isValueDef(channelDef: ChannelDef): channelDef is ValueDef<any> {\n  return channelDef && 'value' in channelDef && channelDef['value'] !== undefined;\n}\n\n// TODO: consider if we want to distinguish ordinalOnlyScale from scale\nexport type FacetFieldDef = PositionFieldDef;\n\nexport interface FieldRefOption {\n  /** exclude bin, aggregate, timeUnit */\n  nofn?: boolean;\n  /** exclude aggregation function */\n  noAggregate?: boolean;\n  /** Wrap the field inside datum[...] per Vega convention */\n  datum?: boolean;\n  /** prepend fn with custom function prefix */\n  prefix?: string;\n  /** append suffix to the field ref for bin (default='start') */\n  binSuffix?: 'start' | 'end' | 'range';\n  /** append suffix to the field ref (general) */\n  suffix?: string;\n}\n\nexport function field(fieldDef: FieldDef, opt: FieldRefOption = {}) {\n  let field = fieldDef.field;\n  let prefix = opt.prefix;\n  let suffix = opt.suffix;\n\n  if (isCount(fieldDef)) {\n    field = 'count_*';\n  } else {\n    let fn: string = undefined;\n\n    if (!opt.nofn) {\n      if (fieldDef.bin) {\n        fn = 'bin';\n        suffix = opt.binSuffix;\n      } else if (!opt.noAggregate && fieldDef.aggregate) {\n        fn = String(fieldDef.aggregate);\n      } else if (fieldDef.timeUnit) {\n        fn = String(fieldDef.timeUnit);\n      }\n    }\n\n    if (!!fn) {\n      field = `${fn}_${field}`;\n    }\n  }\n\n  if (!!suffix) {\n    field = `${field}_${suffix}`;\n  }\n\n  if (!!prefix) {\n    field = `${prefix}_${field}`;\n  }\n\n  if (opt.datum) {\n    field = `datum[\"${field}\"]`;\n  }\n\n  return field;\n}\n\nfunction _isFieldDimension(fieldDef: FieldDef) {\n  if (contains([NOMINAL, ORDINAL], fieldDef.type)) {\n    return true;\n  } else if(!!fieldDef.bin) {\n    return true;\n  } else if (fieldDef.type === TEMPORAL) {\n    return !!fieldDef.timeUnit;\n  }\n  return false;\n}\n\nexport function isDimension(fieldDef: FieldDef) {\n  return fieldDef && isFieldDef(fieldDef) && _isFieldDimension(fieldDef);\n}\n\nexport function isMeasure(fieldDef: FieldDef) {\n  return fieldDef && isFieldDef(fieldDef) && !_isFieldDimension(fieldDef);\n}\n\nexport function count(): FieldDef {\n  return { field: '*', aggregate: AggregateOp.COUNT, type: QUANTITATIVE};\n}\n\nexport function isCount(fieldDef: FieldDef) {\n  return fieldDef.aggregate === AggregateOp.COUNT;\n}\n\nexport function title(fieldDef: FieldDef, config: Config) {\n  if (fieldDef.title != null) {\n    return fieldDef.title;\n  }\n  if (isCount(fieldDef)) {\n    return config.countTitle;\n  }\n  const fn = fieldDef.aggregate || fieldDef.timeUnit || (fieldDef.bin && 'bin');\n  if (fn) {\n    return fn.toString().toUpperCase() + '(' + fieldDef.field + ')';\n  } else {\n    return fieldDef.field;\n  }\n}\n\nexport function defaultType(fieldDef: FieldDef, channel: Channel): Type {\n  if (!!fieldDef.timeUnit) {\n    return 'temporal';\n  }\n  if (!!fieldDef.bin) {\n    return 'quantitative';\n  }\n  const canBeMeasure = getSupportedRole(channel).measure;\n  return canBeMeasure ? 'quantitative' : 'nominal';\n}\n\n/**\n * Convert type to full, lowercase type, or augment the fieldDef with a default type if missing.\n */\nexport function normalize(fieldDef: FieldDef, channel: Channel) {\n  // If a fieldDef contains a field, we need type.\n  if (fieldDef.field) { // TODO: or datum\n    // convert short type to full type\n    const fullType = getFullName(fieldDef.type);\n    if (fullType) {\n      fieldDef.type = fullType;\n    } else {\n      // If type is empty / invalid, then augment with default type\n      const newType = defaultType(fieldDef, channel);\n      log.warn(log.message.emptyOrInvalidFieldType(fieldDef.type, channel, newType));\n      fieldDef.type = newType;\n    }\n  }\n  return fieldDef;\n}\n","import {DateTime, dateTimeExpr, isDateTime} from './datetime';\nimport {field} from './fielddef';\nimport {TimeUnit, fieldExpr as timeUnitFieldExpr, isSingleTimeUnit} from './timeunit';\nimport {isArray, isString} from './util';\n\nexport type Filter = EqualFilter | RangeFilter | OneOfFilter ;\n\n\nexport interface EqualFilter {\n  // TODO: support aggregate\n\n  /**\n   * Time unit for the field to be filtered.\n   */\n  timeUnit?: TimeUnit;\n\n  /**\n   * Field to be filtered.\n   */\n  field: string;\n\n  /**\n   * Value that the field should be equal to.\n   */\n  equal: string | number | boolean | DateTime;\n\n}\n\nexport function isEqualFilter(filter: any): filter is EqualFilter {\n  return filter && !!filter.field && filter.equal!==undefined;\n}\n\nexport interface RangeFilter {\n  // TODO: support aggregate\n\n  /**\n   * time unit for the field to be filtered.\n   */\n  timeUnit?: TimeUnit;\n\n  /**\n   * Field to be filtered\n   */\n  field: string;\n\n  /**\n   * Array of inclusive minimum and maximum values\n   * for a field value of a data item to be included in the filtered data.\n   * @maxItems 2\n   * @minItems 2\n   */\n  range: (number|DateTime)[];\n\n}\n\nexport function isRangeFilter(filter: any): filter is RangeFilter {\n  if (filter && !!filter.field) {\n    if (isArray(filter.range) && filter.range.length === 2) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport interface OneOfFilter {\n  // TODO: support aggregate\n\n  /**\n   * time unit for the field to be filtered.\n   */\n  timeUnit?: TimeUnit;\n\n  /**\n   * Field to be filtered\n   */\n  field: string;\n\n  /**\n   * A set of values that the `field`'s value should be a member of,\n   * for a data item included in the filtered data.\n   */\n  oneOf: (string|number|boolean|DateTime)[];\n\n}\n\nexport function isOneOfFilter(filter: any): filter is OneOfFilter {\n  return filter && !!filter.field && (\n    isArray(filter.oneOf) ||\n    isArray(filter.in) // backward compatibility\n  );\n}\n\nexport function expression(filter: Filter | string) {\n  if (isString(filter)) {\n    return filter as string;\n  } else { // Filter Object\n    const fieldExpr = filter.timeUnit ?\n      // For timeUnit, cast into integer with time() so we can use ===, inrange, indexOf to compare values directly.\n        // TODO: We calculate timeUnit on the fly here. Consider if we would like to consolidate this with timeUnit pipeline\n        // TODO: support utc\n      ('time(' + timeUnitFieldExpr(filter.timeUnit, filter.field) + ')') :\n      field(filter, {datum: true});\n\n    if (isEqualFilter(filter)) {\n      return fieldExpr + '===' + valueExpr(filter.equal, filter.timeUnit);\n    } else if (isOneOfFilter(filter)) {\n      // \"oneOf\" was formerly \"in\" -- so we need to add backward compatibility\n      const oneOf: OneOfFilter[] = filter.oneOf || filter['in'];\n      return 'indexof([' +\n        oneOf.map((v) => valueExpr(v, filter.timeUnit)).join(',') +\n        '], ' + fieldExpr + ') !== -1';\n    } else if (isRangeFilter(filter)) {\n      const lower = filter.range[0];\n      const upper = filter.range[1];\n\n      if (lower !== null &&  upper !== null) {\n        return 'inrange(' + fieldExpr + ', ' +\n          valueExpr(lower, filter.timeUnit) + ', ' +\n          valueExpr(upper, filter.timeUnit) + ')';\n      } else if (lower !== null) {\n        return fieldExpr + ' >= ' + lower;\n      } else if (upper !== null) {\n        return fieldExpr + ' <= ' + upper;\n      }\n    }\n  }\n  return undefined;\n}\n\nfunction valueExpr(v: any, timeUnit: TimeUnit) {\n  if (isDateTime(v)) {\n    const expr = dateTimeExpr(v, true);\n    return 'time(' + expr + ')';\n  }\n  if (isSingleTimeUnit(timeUnit)) {\n    const datetime: DateTime = {};\n    datetime[timeUnit] = v;\n    const expr = dateTimeExpr(datetime, true);\n    return 'time(' + expr + ')';\n  }\n  return JSON.stringify(v);\n}\n","import {DateTime} from './datetime';\nimport {VgLegendEncode} from './vega.schema';\n\nexport interface LegendConfig {\n  /**\n   * The orientation of the legend. One of \"left\" or \"right\". This determines how the legend is positioned within the scene. The default is \"right\".\n   */\n  orient?: string;\n  /**\n   * The offset, in pixels, by which to displace the legend from the edge of the enclosing group or data rectangle.\n   */\n  offset?: number;\n  /**\n   * The padding, in pixels, between the legend and axis.\n   */\n  padding?: number;\n  /**\n   * The margin around the legend, in pixels\n   */\n  margin?: number;\n  /**\n   * The color of the gradient stroke, can be in hex color code or regular color name.\n   */\n  gradientStrokeColor?: string;\n  /**\n   * The width of the gradient stroke, in pixels.\n   * @mimimum 0\n   */\n  gradientStrokeWidth?: number;\n  /**\n   * The height of the gradient, in pixels.\n   * @mimimum 0\n   */\n  gradientHeight?: number;\n  /**\n   * The width of the gradient, in pixels.\n   * @mimimum 0\n   */\n  gradientWidth?: number;\n  /**\n   * The alignment of the legend label, can be left, middle or right.\n   */\n  labelAlign?: string;\n  /**\n   * The position of the baseline of legend label, can be top, middle or bottom.\n   */\n  labelBaseline?: string;\n  /**\n   * The color of the legend label, can be in hex color code or regular color name.\n   */\n  labelColor?: string;\n  /**\n   * The font of the legend label.\n   */\n  labelFont?: string;\n  /**\n   * The font size of legend label.\n   * @mimimum 0\n   */\n  labelFontSize?: number;\n  /**\n   * The offset of the legend label.\n   * @mimimum 0\n   */\n  labelOffset?: number;\n  /**\n   * Whether month names and weekday names should be abbreviated.\n   */\n  shortTimeLabels?: boolean;\n  /**\n   * The color of the legend symbol,\n   */\n  symbolColor?: string;\n  /**\n   * The shape of the legend symbol, can be the 'circle', 'square', 'cross', 'diamond',\n   * 'triangle-up', 'triangle-down', or else a custom SVG path string.\n   */\n  symbolShape?: string;\n  /**\n   * The size of the legend symbol, in pixels.\n   * @mimimum 0\n   */\n  symbolSize?: number;\n  /**\n   * The width of the symbol's stroke.\n   * @minimum 0\n   */\n  symbolStrokeWidth?: number;\n  /**\n   * Optional mark property definitions for custom legend styling.\n   */\n  /**\n   * The color of the legend title, can be in hex color code or regular color name.\n   */\n  titleColor?: string;\n  /**\n   * The font of the legend title.\n   */\n  titleFont?: string;\n  /**\n   * The font size of the legend title.\n   */\n  titleFontSize?: number;\n  /**\n   * The font weight of the legend title.\n   */\n  titleFontWeight?: string | number;\n  /**\n   * Optional mark definitions for custom legend encoding.\n   */\n  encode?: VgLegendEncode;\n}\n\n/**\n * Properties of a legend or boolean flag for determining whether to show it.\n */\nexport interface Legend extends LegendConfig {\n  /**\n   * An optional formatting pattern for legend labels. Vega uses D3\\'s format pattern.\n   */\n  format?: string;\n  /**\n   * A title for the legend. (Shows field name and its function by default.)\n   */\n  title?: string;\n  /**\n   * Explicitly set the visible legend values.\n   */\n  values?: number[] | string[] | DateTime[];\n\n  shape?: string;\n\n  /**\n   * The type of the legend. Use `symbol` to create a discrete legend and `gradient` for a continuous color gradient.\n   */\n  type?: 'symbol' | 'gradient';\n}\n\nexport const defaultLegendConfig: LegendConfig = {\n  orient: undefined, // implicitly \"right\"\n};\n","///<reference path=\"../typings/vega-util.d.ts\" />\n\n/**\n * Vega-Lite's singleton logger utility.\n */\n\nimport {logger, LoggerInterface, Warn} from 'vega-util';\n\nimport {AggregateOp} from './aggregate';\nimport {X, Channel} from './channel';\nimport {DateTime, DateTimeExpr} from './datetime';\nimport {FieldDef} from './fielddef';\nimport {Mark} from './mark';\nimport {TimeUnit} from './timeunit';\nimport {Type} from './type';\nimport {ScaleType} from './scale';\n\nexport {LoggerInterface} from 'vega-util';\n\n/**\n * Main (default) Vega Logger instance for Vega-Lite\n */\nconst main = logger(Warn);\nlet current: LoggerInterface = main;\n\n/**\n * Logger tool for checking if the code throws correct warning\n */\nexport class LocalLogger implements LoggerInterface {\n  public warns: any[] = [];\n  public infos: any[] = [];\n  public debugs: any[] = [];\n\n  public level() {\n    return this;\n  }\n\n  public warn(...args: any[]) {\n    this.warns.push(...args);\n    return this;\n  }\n\n  public info(...args: any[]) {\n    this.infos.push(...args);\n    return this;\n  }\n\n  public debug(...args: any[]) {\n    this.debugs.push(...args);\n    return this;\n  }\n}\n\nexport function runLocalLogger(f: (localLogger: LocalLogger) => void) {\n  const localLogger = current = new LocalLogger();\n  f(localLogger);\n  reset();\n}\n\nexport function wrap(f: (logger: LocalLogger) => void) {\n  return () => {\n    const logger = current = new LocalLogger();\n    f(logger);\n    reset();\n  };\n}\n\n/**\n * Set the singleton logger to be a custom logger\n */\nexport function set(logger: LoggerInterface) {\n  current = logger;\n  return current;\n}\n\n/**\n * Reset the main logger to use the default Vega Logger\n */\nexport function reset() {\n  current = main;\n  return current;\n}\n\nexport function warn(..._: any[]) {\n  current.warn.apply(current, arguments);\n}\n\nexport function info(..._: any[]) {\n  current.info.apply(current, arguments);\n}\n\nexport function debug(..._: any[]) {\n  current.debug.apply(current, arguments);\n}\n\n/**\n * Collection of all Vega-Lite Error Messages\n */\nexport namespace message {\n  export const INVALID_SPEC = 'Invalid spec';\n\n  // DATA\n  export const DEPRECATED_FILTER_NULL = 'filterNull is deprecated. Please use filterInvalid instead.';\n\n  // ENCODING & FACET\n  export function invalidFieldType(type: Type) {\n    return `Invalid field type \"${type}\"`;\n  }\n\n  export function emptyOrInvalidFieldType(type: Type | string, channel: Channel, newType: Type) {\n    return `Invalid field type (${type}) for channel ${channel}, using ${newType} instead.`;\n  }\n\n  export function emptyFieldDef(fieldDef: FieldDef, channel: Channel) {\n    return `Dropping ${JSON.stringify(fieldDef)} from channel ${channel} since it does not contain data field or value.`;\n  }\n\n  export function incompatibleChannel(channel: Channel, markOrFacet: Mark | 'facet') {\n    return `${channel} dropped as it is incompatible with ${markOrFacet}`;\n  }\n\n  export function facetChannelShouldBeDiscrete(channel: string) {\n    return `${channel} encoding should be discrete (ordinal / nominal / binned).`;\n  }\n\n  export function discreteChannelCannotEncode(channel: Channel, type: Type) {\n    return `Using discrete channel ${channel} to encode ${type} field can be misleading as it does not encode ${type === 'ordinal' ? 'order' : 'magnitude'}.`;\n  }\n\n  // Mark\n  export const BAR_WITH_POINT_SCALE_AND_RANGESTEP_NULL = 'Bar mark should not be used with point scale when rangeStep is null. Please use band scale instead.';\n\n  export function unclearOrientContinuous(mark: Mark) {\n    return 'Cannot clearly determine orientation for ' + mark + ' since both x and y channel encode continous fields. In this case, we use vertical by default';\n  }\n\n  export function unclearOrientDiscreteOrEmpty(mark: Mark) {\n    return 'Cannot clearly determine orientation for ' + mark + ' since both x and y channel encode discrete or empty fields.';\n  }\n\n  export function orientOverridden(original: string, actual: string) {\n    return `Specified orient ${original} overridden with ${actual}`;\n  }\n\n  // SCALE\n  export const CANNOT_USE_SCHEME_WITH_NON_COLOR = 'Cannot use scheme with non-color channel.';\n\n  export const CANNOT_USE_RANGE_WITH_POSITION =\n    'Cannot use custom range with x or y channel.  Please customize width, height, padding, or rangeStep instead.';\n\n    export const CANNOT_USE_PADDING_WITH_FACET = 'Cannot use padding with facet\\'s scale.  Please use spacing instead.';\n\n  export function cannotUseRangePropertyWithFacet(propName: string) {\n    return `Cannot use custom ${propName} with row or column channel. Please use width, height, or spacing instead.`;\n  }\n\n  export function rangeStepDropped(channel: Channel) {\n    return `rangeStep for ${channel} is dropped as top-level ${\n      channel === X ? 'width' : 'height'} is provided.`;\n  }\n\n  export function scaleTypeNotWorkWithChannel(channel: Channel, scaleType: ScaleType, newScaleType: ScaleType) {\n    return `Channel ${channel} does not work with ${scaleType} scale. We are using ${newScaleType} scale instead.`;\n  }\n\n  export function scalePropertyNotWorkWithScaleType(scaleType: ScaleType, propName: string, channel: Channel) {\n    return `${channel}-scale's \"${propName}\" is dropped as it does not work with ${scaleType} scale.`;\n  }\n\n  export function scaleTypeNotWorkWithMark(mark: Mark, scaleType: ScaleType) {\n    return `Scale type \"${scaleType}\" does not work with mark ${mark}.`;\n  }\n\n  export const INVAID_DOMAIN = 'Invalid scale domain';\n\n\n  // AXIS\n  export const INVALID_CHANNEL_FOR_AXIS = 'Invalid channel for axis.';\n\n  // STACK\n  export function cannotStackRangedMark(channel: Channel) {\n    return `Cannot stack ${channel} if there is already ${channel}2`;\n  }\n\n  export function cannotStackNonLinearScale(scaleType: ScaleType) {\n    return `Cannot stack non-linear scale (${scaleType})`;\n  }\n\n  export function cannotStackNonSummativeAggregate(aggregate: AggregateOp) {\n    return `Cannot stack when the aggregate function is non-summative (${aggregate})`;\n  }\n\n  // TIMEUNIT\n  export function invalidTimeUnit(unitName: string, value: string | number) {\n    return `Invalid ${unitName}: ${value}`;\n  }\n\n  export function dayReplacedWithDate(fullTimeUnit: TimeUnit) {\n    return `Time unit \"${fullTimeUnit}\" is not supported. We are replacing it with ` +\n      (fullTimeUnit+'').replace('day', 'date') + '.';\n  }\n\n  export function droppedDay(d: DateTime | DateTimeExpr) {\n    return 'Dropping day from datetime ' + JSON.stringify(d) +\n          ' as day cannot be combined with other units.';\n  }\n}\n\n","import {StackOffset} from './stack';\nimport {extend} from './util';\n\nexport namespace Mark {\n  export const AREA: 'area' = 'area';\n  export const BAR: 'bar' = 'bar';\n  export const LINE: 'line' = 'line';\n  export const POINT: 'point' = 'point';\n  export const RECT: 'rect' = 'rect';\n  export const RULE: 'rule' = 'rule';\n  export const TEXT: 'text' = 'text';\n  export const TICK: 'tick' = 'tick';\n  export const CIRCLE: 'circle' = 'circle';\n  export const SQUARE: 'square' = 'square';\n  export const ERRORBAR: 'errorBar' = 'errorBar';\n}\nexport type Mark = typeof Mark.AREA | typeof Mark.BAR | typeof Mark.LINE | typeof Mark.POINT | typeof Mark.TEXT | typeof Mark.TICK | typeof Mark.RECT | typeof Mark.RULE | typeof Mark.CIRCLE | typeof Mark.SQUARE | typeof Mark.ERRORBAR;\n\nexport const AREA = Mark.AREA;\nexport const BAR = Mark.BAR;\nexport const LINE = Mark.LINE;\nexport const POINT = Mark.POINT;\nexport const TEXT = Mark.TEXT;\nexport const TICK = Mark.TICK;\nexport const RECT = Mark.RECT;\nexport const RULE = Mark.RULE;\n\nexport const CIRCLE = Mark.CIRCLE;\nexport const SQUARE = Mark.SQUARE;\n\nexport const ERRORBAR = Mark.ERRORBAR;\nexport const PRIMITIVE_MARKS = [AREA, BAR, LINE, POINT, TEXT, TICK, RULE, CIRCLE, SQUARE];\n\nexport type FontStyle = 'normal' | 'italic';\nexport type FontWeight = 'normal' | 'bold';\n/**\n * @TJS-type integer\n * @minimum 100\n * @maximum 900\n */\nexport type FontWeightNumber = number;\nexport type HorizontalAlign = 'left' | 'right' | 'center';\nexport type Interpolate = 'linear' | 'linear-closed' |\n  'step' | 'step-before' | 'step-after' |\n  'basis' | 'basis-open' | 'basis-closed' |\n  'cardinal' | 'cardinal-open' | 'cardinal-closed' |\n  'bundle' | 'monotone';\nexport type Orient = 'horizontal' | 'vertical';\nexport type VerticalAlign = 'top' | 'middle' | 'bottom';\n\nexport const STROKE_CONFIG = ['stroke', 'strokeWidth',\n  'strokeDash', 'strokeDashOffset', 'strokeOpacity'];\n\nexport const FILL_CONFIG = ['fill', 'fillOpacity'];\n\nexport const FILL_STROKE_CONFIG = [].concat(STROKE_CONFIG, FILL_CONFIG);\n\nexport interface MarkConfig {\n\n  // ---------- Color ----------\n  /**\n   * Whether the shape\\'s color should be used as fill color instead of stroke color.\n   * This is only applicable for \"bar\", \"point\", and \"area\".\n   * All marks except \"point\" marks are filled by default.\n   * See Mark Documentation (http://vega.github.io/vega-lite/docs/marks.html)\n   * for usage example.\n   */\n  filled?: boolean;\n\n  // TODO: remove this once we correctly integrate theme\n  /**\n   * Default color.\n   */\n  color?: string;\n\n  /**\n   * Default Fill Color.  This has higher precedence than config.color\n   */\n  fill?: string;\n\n  /**\n   * Default Stroke Color.  This has higher precedence than config.color\n   */\n  stroke?: string;\n\n  // ---------- Opacity ----------\n  /**\n   * @minimum 0\n   * @maximum 1\n   */\n  opacity?: number;\n\n  /**\n   * Default minimum opacity for mapping a field to opacity.\n   * @minimum 0\n   * @maximum 1\n   */\n  minOpacity?: number;\n\n  /**\n   * Default max opacity for mapping a field to opacity.\n   * @minimum 0\n   * @maximum 1\n   */\n  maxOpacity?: number;\n\n  /**\n   * @minimum 0\n   * @maximum 1\n   */\n  fillOpacity?: number;\n\n  /**\n   * @minimum 0\n   * @maximum 1\n   */\n  strokeOpacity?: number;\n\n  // ---------- Stroke Style ----------\n  /**\n   * @minimum 0\n   */\n  strokeWidth?: number;\n\n  /**\n   * Default minimum strokeWidth for strokeWidth (or rule/line's size) scale with zero=false.\n   * @minimum 0\n   */\n  minStrokeWidth?: number;\n\n  /**\n   * Default max strokeWidth for strokeWidth  (or rule/line's size) scale.\n   * @minimum 0\n   */\n  maxStrokeWidth?: number;\n\n  /**\n   * An array of alternating stroke, space lengths for creating dashed or dotted lines.\n   */\n  strokeDash?: number[];\n\n  /**\n   * The offset (in pixels) into which to begin drawing with the stroke dash array.\n   */\n  strokeDashOffset?: number;\n\n  // FIXME: move this outside mark config\n  // ---------- Stacking: Bar & Area ----------\n  stacked?: StackOffset;\n\n  // ---------- Orientation: Bar, Tick, Line, Area ----------\n  /**\n   * The orientation of a non-stacked bar, tick, area, and line charts.\n   * The value is either horizontal (default) or vertical.\n   * - For bar, rule and tick, this determines whether the size of the bar and tick\n   * should be applied to x or y dimension.\n   * - For area, this property determines the orient property of the Vega output.\n   * - For line, this property determines the sort order of the points in the line\n   * if `config.sortLineBy` is not specified.\n   * For stacked charts, this is always determined by the orientation of the stack;\n   * therefore explicitly specified value will be ignored.\n   */\n  orient?: Orient;\n\n  // ---------- Interpolation: Line / area ----------\n  /**\n   * The line interpolation method to use for line and area marks. One of the following:\n   * - `\"linear\"`: piecewise linear segments, as in a polyline.\n   * - `\"linear-closed\"`: close the linear segments to form a polygon.\n   * - `\"step\"`: alternate between horizontal and vertical segments, as in a step function.\n   * - `\"step-before\"`: alternate between vertical and horizontal segments, as in a step function.\n   * - `\"step-after\"`: alternate between horizontal and vertical segments, as in a step function.\n   * - `\"basis\"`: a B-spline, with control point duplication on the ends.\n   * - `\"basis-open\"`: an open B-spline; may not intersect the start or end.\n   * - `\"basis-closed\"`: a closed B-spline, as in a loop.\n   * - `\"cardinal\"`: a Cardinal spline, with control point duplication on the ends.\n   * - `\"cardinal-open\"`: an open Cardinal spline; may not intersect the start or end, but will intersect other control points.\n   * - `\"cardinal-closed\"`: a closed Cardinal spline, as in a loop.\n   * - `\"bundle\"`: equivalent to basis, except the tension parameter is used to straighten the spline.\n   * - `\"monotone\"`: cubic interpolation that preserves monotonicity in y.\n   */\n  interpolate?: Interpolate;\n  /**\n   * Depending on the interpolation type, sets the tension parameter (for line and area marks).\n   * @minimum 0\n   * @maximum 1\n   */\n  tension?: number;\n}\n\nexport const defaultMarkConfig: MarkConfig = {\n  color: '#4682b4',\n\n  minOpacity: 0.3,\n  maxOpacity: 0.8,\n\n  minStrokeWidth: 1,\n  maxStrokeWidth: 4\n};\n\nexport interface AreaConfig extends MarkConfig {}\n\nexport const defaultAreaConfig: AreaConfig = {\n\n};\n\nexport interface BarConfig extends MarkConfig {\n  /**\n   * Offset between bar for binned field.  Ideal value for this is either 0 (Preferred by statisticians) or 1 (Vega-Lite Default, D3 example style).\n   * @minimum 0\n   */\n  binSpacing?: number;\n  /**\n   * Default size of the bars on continuous scales.\n   * @minimum 0\n   */\n  continuousBandSize?: number;\n\n  /**\n   * The size of the bars.  If unspecified, the default size is  `bandSize-1`,\n   * which provides 1 pixel offset between bars.\n   * @minimum 0\n   */\n  discreteBandSize?: number;\n\n  /**\n   * The default max value for mapping quantitative fields to bar's size/bandSize.\n   * If undefined (default), we will use bandSize - 1.\n   * @minimum 0\n   */\n  maxBandSize?: number;\n\n  /**\n   * The default min value for mapping quantitative fields to bar's size/bandSize scale with zero=false\n   * If undefined (default), we will use the `continuousBandSize` value.\n   * @minimum 0\n   */\n  minBandSize?: number;\n}\n\nexport const defaultBarConfig: BarConfig = {\n  binSpacing: 1,\n  continuousBandSize: 2\n};\n\nexport interface LineConfig extends MarkConfig {}\n\nexport const defaultLineConfig: LineConfig = {\n  strokeWidth: 2\n};\n\nexport interface SymbolConfig extends MarkConfig {\n\n  /**\n   * The pixel area each the point/circle/square.\n   * For example: in the case of circles, the radius is determined in part by the square root of the size value.\n   * @minimum 0\n   */\n  size?: number;\n\n  /**\n   * Default minimum value for point size scale with zero=false.\n   * @minimum 0\n   */\n  minSize?: number;\n\n  /**\n   * Default max value for point size scale.\n   * @minimum 0\n   */\n  maxSize?: number;\n}\n\nexport interface PointConfig extends SymbolConfig {\n  /**\n   * The default symbol shape to use. One of: `\"circle\"` (default), `\"square\"`, `\"cross\"`, `\"diamond\"`, `\"triangle-up\"`, or `\"triangle-down\"`, or a custom SVG path.\n   */\n  shape?: string;\n\n  /**\n   * The default collection of symbol shapes for mapping nominal fields to shapes of point marks (i.e., range of a `shape` scale).\n   * Each value should be one of: `\"circle\"`, `\"square\"`, `\"cross\"`, `\"diamond\"`, `\"triangle-up\"`, or `\"triangle-down\"`, or a custom SVG path.\n   */\n  shapes?: string[];\n}\n\nexport const defaultSymbolConfig: PointConfig = {\n  size: 30,\n\n  // FIXME: revise if these *can* become ratios of rangeStep\n  minSize: 9, // Point size is area. For square point, 9 = 3 pixel ^ 2, not too small!\n  strokeWidth: 2\n};\n\nexport const defaultPointConfig = extend({}, defaultSymbolConfig, {\n  shape: 'circle',\n  shapes: ['circle', 'square', 'cross', 'diamond', 'triangle-up', 'triangle-down'],\n});\n\nexport const defaultCircleConfig: SymbolConfig = defaultSymbolConfig;\nexport const defaultSquareConfig: SymbolConfig = defaultSymbolConfig;\n\nexport interface RectConfig extends MarkConfig {}\n\nexport const defaultRectConfig: RectConfig = {};\n\nexport interface RuleConfig extends MarkConfig {}\n\nexport const defaultRuleConfig: RuleConfig = {\n  strokeWidth: 1\n};\n\nexport interface TextConfig extends MarkConfig {\n  /**\n   * The horizontal alignment of the text. One of left, right, center.\n   */\n  align?: HorizontalAlign;\n  /**\n   * The rotation angle of the text, in degrees.\n   * @minimum 0\n   * @maximum 360\n   */\n  angle?: number;\n  /**\n   * The vertical alignment of the text. One of top, middle, bottom.\n   */\n  baseline?: VerticalAlign;\n  /**\n   * The horizontal offset, in pixels, between the text label and its anchor point. The offset is applied after rotation by the angle property.\n   */\n  dx?: number;\n  /**\n   * The vertical offset, in pixels, between the text label and its anchor point. The offset is applied after rotation by the angle property.\n   */\n  dy?: number;\n  /**\n   * Polar coordinate radial offset, in pixels, of the text label from the origin determined by the x and y properties.\n   * @minimum 0\n   */\n  radius?: number;\n  /**\n   * Polar coordinate angle, in radians, of the text label from the origin determined by the x and y properties. Values for theta follow the same convention of arc mark startAngle and endAngle properties: angles are measured in radians, with 0 indicating \"north\".\n   */\n  theta?: number;\n  /**\n   * The typeface to set the text in (e.g., Helvetica Neue).\n   * @minimum 0\n   */\n  font?: string;\n  /**\n   * The font size, in pixels.\n   * @minimum 0\n   */\n  fontSize?: number;\n\n  /**\n   * The default max value for mapping quantitative fields to text's size/fontSize.\n   * If undefined (default), we will use bandSize - 1.\n   * @minimum 0\n   */\n  maxFontSize?: number;\n\n  /**\n   * The default min value for mapping quantitative fields to tick's size/fontSize scale with zero=false\n   * @minimum 0\n   */\n  minFontSize?: number;\n\n  /**\n   * The font style (e.g., italic).\n   */\n  fontStyle?: FontStyle;\n  /**\n   * The font weight (e.g., `\"normal\"`, `\"bold\"`, `900`).\n   */\n  fontWeight?: FontWeight | FontWeightNumber;\n\n  // Vega-Lite only for text only\n  /**\n   * The formatting pattern for text value. If not defined, this will be determined automatically.\n   */\n  format?: string;\n  /**\n   * Whether month names and weekday names should be abbreviated.\n   */\n  shortTimeLabels?: boolean;\n\n  /**\n   * Placeholder Text\n   */\n  text?: string;\n\n  // FIXME: remove this?\n  /**\n   * Apply color field to background color instead of the text.\n   */\n  applyColorToBackground?: boolean;\n}\n\nexport const defaultTextConfig: TextConfig = {\n  fontSize: 10,\n  minFontSize: 8,\n  maxFontSize: 40,\n  baseline: 'middle',\n  text: 'Abc',\n  applyColorToBackground: false\n};\n\nexport interface TickConfig extends MarkConfig {\n  /**\n   * The width of the ticks.\n   * If this value is undefined (by default,), we use 2/3 of rangeStep by default.\n   * @minimum 0\n   */\n  bandSize?: number;\n\n  /**\n   * The default max value for mapping quantitative fields to tick's size/bandSize.\n   * If undefined (default), we will use bandSize - 1.\n   * @minimum 0\n   */\n  maxBandSize?: number;\n\n  /**\n   * The default min value for mapping quantitative fields to tick's size/bandSize scale with zero=false\n   * If undefined (default), we will use the `continuousBandSize` value.\n   * @minimum 0\n   */\n  minBandSize?: number;\n\n  /**\n   * Thickness of the tick mark.\n   * @minimum 0\n   */\n  thickness?: number;\n}\n\nexport const defaultTickConfig: TickConfig = {\n  // if tickSize = 1, it becomes a dot.\n  // To be consistent, we just use 3 to be somewhat consistent with point, which use area = 9.\n  minBandSize: 3,\n  thickness: 1\n};\n\n// TODO: ErrorBar Config\n","import * as log from './log';\nimport {Channel} from './channel';\nimport {DateTime} from './datetime';\nimport {contains, toSet} from './util';\n\nexport namespace ScaleType {\n  // Continuous - Quantitative\n  export const LINEAR: 'linear' = 'linear';\n  export const LOG: 'log' = 'log';\n  export const POW: 'pow' = 'pow';\n  export const SQRT: 'sqrt' = 'sqrt';\n  // Continuous - Time\n  export const TIME: 'time' = 'time';\n  export const UTC: 'utc'  = 'utc';\n  // sequential\n  export const SEQUENTIAL: 'sequential' = 'sequential';\n\n  // Quantile, Quantize, threshold\n  export const QUANTILE: 'quantile' = 'quantile';\n  export const QUANTIZE: 'quantize' = 'quantize';\n  export const THRESHOLD: 'threshold' = 'threshold';\n\n  export const ORDINAL: 'ordinal' = 'ordinal';\n  export const POINT: 'point' = 'point';\n  export const BAND: 'band' = 'band';\n\n}\n\nexport type ScaleType = typeof ScaleType.LINEAR |\n  typeof ScaleType.LOG | typeof ScaleType.POW | typeof ScaleType.SQRT |\n  typeof ScaleType.TIME | typeof ScaleType.UTC |\n  // TODO: add 'quantize', 'quantile', 'threshold' back when we really support them\n  typeof ScaleType.SEQUENTIAL | // typeof ScaleType.QUANTILE | typeof ScaleType.QUANTIZE | typeof ScaleType.THRESHOLD |\n  typeof ScaleType.ORDINAL | typeof ScaleType.POINT | typeof ScaleType.BAND;\n\nexport const SCALE_TYPES: ScaleType[] = [\n  // Continuous - Quantitative\n  'linear', 'log', 'pow', 'sqrt',\n  // Continuous - Time\n  'time', 'utc',\n  // Sequential\n  'sequential', // TODO: add 'quantile', 'quantize' when we really support them\n  // Discrete\n  'ordinal', 'point', 'band',\n];\n\nexport const CONTINUOUS_TO_CONTINUOUS_SCALES: ScaleType[] = ['linear', 'log', 'pow', 'sqrt', 'time', 'utc'];\nconst CONTINUOUS_TO_CONTINUOUS_INDEX = toSet(CONTINUOUS_TO_CONTINUOUS_SCALES);\n\nexport const CONTINUOUS_DOMAIN_SCALES: ScaleType[] = CONTINUOUS_TO_CONTINUOUS_SCALES.concat(['sequential' /* TODO add 'quantile', 'quantize', 'threshold'*/]);\nconst CONTINUOUS_DOMAIN_INDEX = toSet(CONTINUOUS_DOMAIN_SCALES);\n\nexport const DISCRETE_DOMAIN_SCALES: ScaleType[] = ['ordinal', 'point', 'band'];\nconst DISCRETE_DOMAIN_INDEX = toSet(DISCRETE_DOMAIN_SCALES);\n\nexport const TIME_SCALE_TYPES: ScaleType[] = ['time', 'utc'];\n\nexport function hasDiscreteDomain(type: ScaleType): type is 'ordinal' | 'point' | 'band' {\n  return type in DISCRETE_DOMAIN_INDEX;\n}\n\nexport function hasContinuousDomain(type: ScaleType):\n  type is 'linear' | 'log' | 'pow' | 'sqrt' |  'time' | 'utc'|\n          'sequential' /* TODO add | 'quantile' | 'quantize' | 'threshold' */ {\n  return type in CONTINUOUS_DOMAIN_INDEX;\n}\n\nexport function isContinuousToContinuous(type: ScaleType): type is 'linear' | 'log' | 'pow' | 'sqrt' |  'time' | 'utc' {\n  return type in CONTINUOUS_TO_CONTINUOUS_INDEX;\n}\n\nexport namespace NiceTime {\n  export const SECOND: 'second' = 'second';\n  export const MINUTE: 'minute' = 'minute';\n  export const HOUR: 'hour' = 'hour';\n  export const DAY: 'day' = 'day';\n  export const WEEK: 'week' = 'week';\n  export const MONTH: 'month' = 'month';\n  export const YEAR: 'year' = 'year';\n}\n\nexport type NiceTime = typeof NiceTime.SECOND | typeof NiceTime.MINUTE | typeof NiceTime.HOUR\n  | typeof NiceTime.DAY | typeof NiceTime.WEEK | typeof NiceTime.MONTH | typeof NiceTime.YEAR;\n\nexport interface ScaleConfig {\n  /**\n   * If true, rounds numeric output values to integers.\n   * This can be helpful for snapping to the pixel grid.\n   * (Only available for `x`, `y`, `size`, `row`, and `column` scales.)\n   */\n  round?: boolean;\n\n  /**\n   * If true, values that exceed the data domain are clamped to either the minimum or maximum range value\n   */\n  clamp?: boolean;\n  /**\n   *  Default range step for `x` ordinal scale when is mark is `text`.\n   *  @minimum 0\n   */\n  textXRangeStep?: number; // FIXME: consider if we will rename this \"tableColumnWidth\"\n  /**\n   * Default range step for (1) `y` ordinal scale,\n   * and (2) `x` ordinal scale when the mark is not `text`.\n   *\n   * @minimum 0\n   * @nullable\n   */\n  rangeStep?: number | null;\n\n  /**\n   * Default inner padding for `x` and `y` band-ordinal scales.\n   * @minimum 0\n   * @maximum 1\n   */\n  bandPaddingInner?: number;\n\n  /**\n   * Default outer padding for `x` and `y` band-ordinal scales.\n   * If not specified, by default, band scale's paddingOuter is paddingInner/2.\n   * @minimum 0\n   * @maximum 1\n   */\n  bandPaddingOuter?: number;\n\n  /**\n   * Default outer padding for `x` and `y` point-ordinal scales.\n   * @minimum 0\n   * @maximum 1\n   */\n  pointPadding?: number;\n\n  /**\n   * Default spacing between faceted plots.\n   * @TJS-type integer\n   * @minimum 0\n   */\n  facetSpacing?: number;\n\n  /**\n   * Uses the source data range as scale domain instead of aggregated data for aggregate axis.\n   * This property only works with aggregate functions that produce values within the raw data domain (`\"mean\"`, `\"average\"`, `\"stdev\"`, `\"stdevp\"`, `\"median\"`, `\"q1\"`, `\"q3\"`, `\"min\"`, `\"max\"`). For other aggregations that produce values outside of the raw data domain (e.g. `\"count\"`, `\"sum\"`), this property is ignored.\n   */\n  useRawDomain?: boolean;\n\n  // nice should depends on type (quantitative or temporal), so\n  // let's not make a config.\n}\n\nexport const defaultScaleConfig = {\n  round: true,\n  textXRangeStep: 90,\n  rangeStep: 21,\n  pointPadding: 0.5,\n  bandPaddingInner: 0.1,\n  facetSpacing: 16,\n  useRawDomain: false,\n};\n\nexport interface ExtendedScheme {\n  /**\n   * Color scheme that determines output color of an ordinal/sequential color scale.\n   */\n  name: string;\n\n  // TODO: add docs\n  extent?: number[];\n\n  // TODO: add docs\n  count?: number;\n}\n\nexport type Scheme = string | ExtendedScheme;\nexport type Range = number[] | string[] | string;\n\nexport function isExtendedScheme(scheme: string | ExtendedScheme): scheme is ExtendedScheme {\n  return scheme && !!scheme['name'];\n}\n\nexport interface Scale {\n  type?: ScaleType;\n  /**\n   * The domain of the scale, representing the set of data values. For quantitative data, this can take the form of a two-element array with minimum and maximum values. For ordinal/categorical data, this may be an array of valid input values.\n   */\n  domain?: number[] | string[] | DateTime[];\n\n  /**\n   * The range of the scale, representing the set of visual values. For numeric values, the range can take the form of a two-element array with minimum and maximum values. For ordinal or quantized data, the range may by an array of desired output values, which are mapped to elements in the specified domain.\n   */\n  range?: Range;\n\n  /**\n   * If true, rounds numeric output values to integers. This can be helpful for snapping to the pixel grid.\n   *\n   * __Default Rule:__ `true` for `\"x\"`, `\"y\"`, `\"row\"`, `\"column\"` channels if scale config's `round` is `true`; `false` otherwise.\n   */\n  round?: boolean;\n\n  // ordinal\n  /**\n   * The distance between the starts of adjacent bands or points in band or point scales.\n   * If this value is `null`, this will be determined to fit width (for x) or height (for y) of the plot.\n   * If both width and x-scale's rangeStep is provided, rangeStep will be dropped.  (The same rule is applied for height and y-scale's rangeStep.)\n   *\n   * __Default Rule:__ for `x` ordinal scale of a `text` mark, derived from [scale config](config.html#scale-config)'s `textXRangeStep`. Otherwise, derived from [scale config](config.html#scale-config)'s `rangeStep`.\n   * __Warning:__ If the cardinality of the scale domain is too high, the rangeStep might become less than one pixel and the mark might not appear correctly.\n   * @minimum 0\n   * @nullable\n   */\n  rangeStep?: number | null;\n\n  /**\n   * Range scheme (e.g., color schemes such as \"category10\" or \"viridis\").\n   */\n  scheme?: Scheme;\n\n  /**\n   * (For `row` and `column` only) A pixel value for padding between cells in the trellis plots.\n   * @TJS-type integer\n   */\n  spacing?: number;\n\n  /**\n   * Applies spacing among ordinal elements in the scale range. The actual effect depends on how the scale is configured. If the __points__ parameter is `true`, the padding value is interpreted as a multiple of the spacing between points. A reasonable value is 1.0, such that the first and last point will be offset from the minimum and maximum value by half the distance between points. Otherwise, padding is typically in the range [0, 1] and corresponds to the fraction of space in the range interval to allocate to padding. A value of 0.5 means that the band size will be equal to the padding width. For more, see the [D3 ordinal scale documentation](https://github.com/mbostock/d3/wiki/Ordinal-Scales).\n   * A convenience property for setting the inner and outer padding to the same value.\n   * @minimum 0\n   * @maximum 1\n   */\n  padding?: number;\n\n  /**\n   * The inner padding of a band scale determines the ratio of the range that is reserved for blank space between bands. (For point scale, this property is ignored.)\n   * @minimum 0\n   * @maximum 1\n   */\n  paddingInner?: number;\n\n  /**\n   * The outer padding determines the ratio of the range that is reserved for blank space before the first and after the last bands/points.\n   * @minimum 0\n   * @maximum 1\n   */\n  paddingOuter?: number;\n\n  // typical\n  /**\n   * If true, values that exceed the data domain are clamped to either the minimum or maximum range value\n   */\n  clamp?: boolean;\n  /**\n   * If specified, modifies the scale domain to use a more human-friendly value range. If specified as a true boolean, modifies the scale domain to use a more human-friendly number range (e.g., 7 instead of 6.96). If specified as a string, modifies the scale domain to use a more human-friendly value range. For time and utc scale types only, the nice value should be a string indicating the desired time interval.\n   */\n  nice?: boolean | NiceTime;\n  /**\n   * Sets the exponent of the scale transformation. For pow scale types only, otherwise ignored.\n   */\n  exponent?: number;\n  /**\n   * If `true`, ensures that a zero baseline value is included in the scale domain.\n   * Default value: `true` for `x` and `y` channel if the quantitative field is not binned\n   * and no custom `domain` is provided; `false` otherwise.\n   */\n  zero?: boolean;\n\n  // Vega-Lite only\n  /**\n   * Uses the source data range as scale domain instead of aggregated data for aggregate axis.\n   * This property only works with aggregate functions that produce values within the raw data domain (`\"mean\"`, `\"average\"`, `\"stdev\"`, `\"stdevp\"`, `\"median\"`, `\"q1\"`, `\"q3\"`, `\"min\"`, `\"max\"`). For other aggregations that produce values outside of the raw data domain (e.g. `\"count\"`, `\"sum\"`), this property is ignored.\n   */\n  useRawDomain?: boolean;\n}\n\nexport const SCALE_PROPERTIES = [\n  'type', 'domain', 'range', 'round', 'rangeStep', 'scheme', 'padding', 'clamp', 'nice',\n  'exponent', 'zero',\n  // TODO: add interpolate here\n  // FIXME: determine if 'useRawDomain' should really be included here\n  'useRawDomain'\n];\n\nexport function scaleTypeSupportProperty(scaleType: ScaleType, propName: string) {\n  switch (propName) {\n    case 'type':\n    case 'domain':\n    case 'range':\n    case 'scheme':\n      return true;\n    case 'round':\n      return isContinuousToContinuous(scaleType) || scaleType === 'band' || scaleType === 'point';\n    case 'rangeStep':\n    case 'padding':\n    case 'paddingOuter':\n      return contains(['point', 'band'], scaleType);\n    case 'paddingInner':\n      return scaleType === 'band';\n    case 'clamp':\n      return isContinuousToContinuous(scaleType) || scaleType === 'sequential';\n    case 'nice':\n      return isContinuousToContinuous(scaleType) || scaleType === 'sequential' || scaleType as any === 'quantize';\n    case 'exponent':\n      return scaleType === 'pow';\n    case 'zero':\n      // TODO: what about quantize, threshold?\n      return !hasDiscreteDomain(scaleType) && !contains(['log', 'time', 'utc'], scaleType);\n\n    case 'useRawDomain':\n      // TODO: 'quantize', 'quantile', 'threshold'\n      return isContinuousToContinuous(scaleType) || contains(['quantize', 'quantile', 'threshold'], scaleType);\n  }\n  /* istanbul ignore next: should never reach here*/\n  throw new Error(`Invalid scale property ${propName}.`);\n}\n\n/**\n * Returns undefined if the input channel supports the input scale property name\n */\nexport function channelScalePropertyIncompatability(channel: Channel, propName: string): string {\n  switch (propName) {\n    case 'range':\n      // User should not customize range for position and facet channel directly.\n      if (channel === 'x' || channel === 'y') {\n        return log.message.CANNOT_USE_RANGE_WITH_POSITION;\n      }\n      if (channel === 'row' || channel === 'column') {\n        return log.message.cannotUseRangePropertyWithFacet('range');\n      }\n      return undefined; // GOOD!\n    // band / point\n    case 'rangeStep':\n      if (channel === 'row' || channel === 'column') {\n        return log.message.cannotUseRangePropertyWithFacet('rangeStep');\n      }\n      return undefined; // GOOD!\n    case 'padding':\n    case 'paddingInner':\n    case 'paddingOuter':\n      if (channel === 'row' || channel === 'column') {\n        /*\n         * We do not use d3 scale's padding for row/column because padding there\n         * is a ratio ([0, 1]) and it causes the padding to be decimals.\n         * Therefore, we manually calculate \"spacing\" in the layout by ourselves.\n         */\n        return log.message.CANNOT_USE_PADDING_WITH_FACET;\n      }\n      return undefined; // GOOD!\n    case 'scheme':\n      if (channel !== 'color') {\n        return log.message.CANNOT_USE_SCHEME_WITH_NON_COLOR;\n      }\n      return undefined;\n    case 'type':\n    case 'domain':\n    case 'round':\n    case 'clamp':\n    case 'exponent':\n    case 'nice':\n    case 'zero':\n    case 'useRawDomain':\n      // These channel do not have strict requirement\n      return undefined; // GOOD!\n  }\n  /* istanbul ignore next: it should never reach here */\n  throw new Error('Invalid scale property \"${propName}\".');\n}\n","import {AggregateOp} from './aggregate';\n\nexport namespace SortOrder {\n  export const ASCENDING: 'ascending' = 'ascending';\n  export const DESCENDING: 'descending' = 'descending';\n}\n\nexport type SortOrder = typeof SortOrder.ASCENDING | typeof SortOrder.DESCENDING | null;\n\nexport interface SortField {\n  /**\n   * The field name to aggregate over.\n   */\n  field: string;\n  /**\n   * The sort aggregation operator\n   */\n  op: AggregateOp;\n\n  order?: SortOrder;\n}\n\nexport function isSortField(sort: SortOrder | SortField): sort is SortField {\n  return !!sort && !!sort['field'] && !!sort['op'];\n}\n","/* Package of defining Vega-lite Specification's json schema at its utility functions */\n\nimport {Config, defaultOverlayConfig, AreaOverlay} from './config';\nimport {Data} from './data';\nimport {Encoding, UnitEncoding, channelHasField, isRanged} from './encoding';\nimport {Facet} from './facet';\nimport {FieldDef} from './fielddef';\nimport {Mark, ERRORBAR, TICK, AREA, RULE, LINE, POINT} from './mark';\nimport {stack} from './stack';\nimport {Transform} from './transform';\nimport {ROW, COLUMN, X, Y, X2, Y2} from './channel';\nimport * as vlEncoding from './encoding';\nimport {contains, duplicate, extend, hash, keys, omit, pick, vals} from './util';\n\nexport type Padding = number | {top?: number, bottom?: number, left?: number, right?: number};\n\nexport interface BaseSpec {\n  /**\n   * URL to JSON schema for this Vega-Lite specification.\n   * @format uri\n   */\n  $schema?: string;\n\n  /**\n   * Name of the visualization for later reference.\n   */\n  name?: string;\n\n  /**\n   * An optional description of this mark for commenting purpose.\n   * This property has no effect on the output visualization.\n   */\n  description?: string;\n\n  /**\n   * The default visualization padding, in pixels, from the edge of the visualization canvas to the data rectangle. This can be a single number or an object with `\"top\"`, `\"left\"`, `\"right\"`, `\"bottom\"` properties.\n   *\n   * __Default value__: `5`\n   *\n   * @minimum 0\n   */\n  padding?: Padding;\n\n  /**\n   * An object describing the data source\n   */\n  data?: Data;\n\n  /**\n   * An object describing filter and new field calculation.\n   */\n  transform?: Transform;\n\n  /**\n   * Configuration object\n   */\n  config?: Config;\n}\n\nexport interface UnitSpec extends BaseSpec {\n  // FIXME description for top-level width\n  width?: number;\n\n  // FIXME description for top-level width\n  height?: number;\n\n  /**\n   * The mark type.\n   * One of `\"bar\"`, `\"circle\"`, `\"square\"`, `\"tick\"`, `\"line\"`,\n   * `\"area\"`, `\"point\"`, `\"rule\"`, and `\"text\"`.\n   */\n  mark: Mark;\n\n  /**\n   * A key-value mapping between encoding channels and definition of fields.\n   */\n  encoding?: UnitEncoding;\n}\n\n/**\n * Schema for a unit Vega-Lite specification, with the syntactic sugar extensions:\n * - `row` and `column` are included in the encoding.\n * - (Future) label, box plot\n *\n * Note: the spec could contain facet.\n *\n * @required [\"mark\", \"encoding\"]\n */\nexport interface ExtendedUnitSpec extends BaseSpec {\n  // FIXME description for top-level width\n  width?: number;\n\n  // FIXME description for top-level width\n  height?: number;\n\n  /**\n   * The mark type.\n   * One of `\"bar\"`, `\"circle\"`, `\"square\"`, `\"tick\"`, `\"line\"`,\n   * `\"area\"`, `\"point\"`, `\"rule\"`, and `\"text\"`.\n   */\n  mark?: Mark;\n\n  /**\n   * A key-value mapping between encoding channels and definition of fields.\n   */\n  encoding?: Encoding;\n}\n\nexport interface FacetSpec extends BaseSpec {\n  facet: Facet;\n  spec: LayerSpec | UnitSpec;\n}\n\nexport interface LayerSpec extends BaseSpec {\n  // FIXME description for top-level width\n  width?: number;\n\n  // FIXME description for top-level width\n  height?: number;\n\n  /**\n   * Unit specs that will be layered.\n   */\n  layers: UnitSpec[];\n}\n\n/** This is for the future schema */\nexport interface ExtendedFacetSpec extends BaseSpec {\n  facet: Facet;\n\n  spec: ExtendedUnitSpec | FacetSpec;\n}\n\nexport type ExtendedSpec = ExtendedUnitSpec | FacetSpec | LayerSpec;\nexport type Spec = UnitSpec | FacetSpec | LayerSpec;\n\n/* Custom type guards */\n\nexport function isSomeFacetSpec(spec: ExtendedSpec | ExtendedFacetSpec): spec is FacetSpec | ExtendedFacetSpec {\n  return spec['facet'] !== undefined;\n}\n\nexport function isExtendedUnitSpec(spec: ExtendedSpec): spec is ExtendedUnitSpec {\n  if (isSomeUnitSpec(spec)) {\n    const hasRow = channelHasField(spec.encoding, ROW);\n    const hasColumn = channelHasField(spec.encoding, COLUMN);\n\n    return hasRow || hasColumn;\n  }\n\n  return false;\n}\n\nexport function isUnitSpec(spec: ExtendedSpec): spec is UnitSpec {\n  if (isSomeUnitSpec(spec)) {\n    return !isExtendedUnitSpec(spec);\n  }\n\n  return false;\n}\n\nexport function isSomeUnitSpec(spec: ExtendedSpec): spec is ExtendedUnitSpec | UnitSpec {\n  return spec['mark'] !== undefined;\n}\n\nexport function isLayerSpec(spec: ExtendedSpec | ExtendedFacetSpec): spec is LayerSpec {\n  return spec['layers'] !== undefined;\n}\n\n\n/**\n * Decompose extended unit specs into composition of pure unit specs.\n */\n// TODO: consider moving this to another file.  Maybe vl.spec.normalize or vl.normalize\nexport function normalize(spec: ExtendedSpec): Spec {\n  if (isExtendedUnitSpec(spec)) {\n    return normalizeExtendedUnitSpec(spec);\n  }\n  if (isUnitSpec(spec)) {\n    return normalizeUnitSpec(spec);\n  }\n  return spec;\n}\n\nexport function normalizeExtendedUnitSpec(spec: ExtendedUnitSpec): Spec {\n    const hasRow = channelHasField(spec.encoding, ROW);\n    const hasColumn = channelHasField(spec.encoding, COLUMN);\n\n    // TODO: @arvind please  add interaction syntax here\n    let encoding = duplicate(spec.encoding);\n    delete encoding.column;\n    delete encoding.row;\n\n    return extend(\n      spec.name ? { name: spec.name } : {},\n      spec.description ? { description: spec.description } : {},\n      { data: spec.data },\n      spec.transform ? { transform: spec.transform } : {},\n      {\n        facet: extend(\n          hasRow ? { row: spec.encoding.row } : {},\n          hasColumn ? { column: spec.encoding.column } : {}\n        ),\n        spec: normalizeUnitSpec(extend(\n          spec.width ? { width: spec.width } : {},\n          spec.height ? { height: spec.height } : {},\n          {\n            mark: spec.mark,\n            encoding: encoding\n          },\n          spec.config ? { config: spec.config } : {}\n        ))\n      },\n      spec.config ? { config: spec.config } : {}\n    );\n}\n\nexport function normalizeUnitSpec(spec: UnitSpec): Spec {\n  const config = spec.config;\n  const overlayConfig = config && config.overlay;\n  const overlayWithLine = overlayConfig  && spec.mark === AREA &&\n    contains([AreaOverlay.LINEPOINT, AreaOverlay.LINE], overlayConfig.area);\n  const overlayWithPoint = overlayConfig && (\n    (overlayConfig.line && spec.mark === LINE) ||\n    (overlayConfig.area === AreaOverlay.LINEPOINT && spec.mark === AREA)\n  );\n\n  // TODO: thoroughly test\n  if (spec.mark === ERRORBAR) {\n    return normalizeErrorBarUnitSpec(spec);\n  }\n  // TODO: thoroughly test\n  if (isRanged(spec.encoding)) {\n    return normalizeRangedUnitSpec(spec);\n  }\n\n  if (overlayWithPoint || overlayWithLine) {\n    return normalizeOverlay(spec, overlayWithPoint, overlayWithLine);\n  }\n  return spec;\n}\n\nexport function normalizeRangedUnitSpec(spec: UnitSpec): Spec {\n  if (spec.encoding) {\n    const hasX = channelHasField(spec.encoding, X);\n    const hasY = channelHasField(spec.encoding, Y);\n    const hasX2 = channelHasField(spec.encoding, X2);\n    const hasY2 = channelHasField(spec.encoding, Y2);\n    if ((hasX2 && !hasX) || (hasY2 && !hasY)) {\n      let normalizedSpec = duplicate(spec);\n      if (hasX2 && !hasX) {\n        normalizedSpec.encoding.x = normalizedSpec.encoding.x2;\n        delete normalizedSpec.encoding.x2;\n      }\n      if (hasY2 && !hasY) {\n        normalizedSpec.encoding.y = normalizedSpec.encoding.y2;\n        delete normalizedSpec.encoding.y2;\n      }\n\n      return normalizedSpec;\n    }\n  }\n  return spec;\n}\n\nexport function normalizeErrorBarUnitSpec(spec: UnitSpec): Spec {\n  // FIXME correctly deal with color and opacity\n\n  let layerSpec = extend(spec.name ? {name: spec.name} : {},\n    spec.description ? {description: spec.description} : {},\n    spec.data ? {data: spec.data} : {},\n    spec.transform ? {transform: spec.transform} : {},\n    spec.config ? {config: spec.config} : {}, {layers: []}\n  );\n  if (!spec.encoding) {\n    return layerSpec;\n  }\n  if (spec.mark === ERRORBAR) {\n    const ruleSpec = {\n      mark: RULE,\n      encoding: extend(\n        spec.encoding.x ? {x: duplicate(spec.encoding.x)} : {},\n        spec.encoding.y ? {y: duplicate(spec.encoding.y)} : {},\n        spec.encoding.x2 ? {x2: duplicate(spec.encoding.x2)} : {},\n        spec.encoding.y2 ? {y2: duplicate(spec.encoding.y2)} : {},\n        {})\n    };\n    const lowerTickSpec = {\n      mark: TICK,\n      encoding: extend(\n        spec.encoding.x ? {x: duplicate(spec.encoding.x)} : {},\n        spec.encoding.y ? {y: duplicate(spec.encoding.y)} : {},\n        spec.encoding.size ? {size: duplicate(spec.encoding.size)} : {},\n        {})\n    };\n    const upperTickSpec = {\n      mark: TICK,\n      encoding: extend({\n        x: spec.encoding.x2 ? duplicate(spec.encoding.x2) : duplicate(spec.encoding.x),\n        y: spec.encoding.y2 ? duplicate(spec.encoding.y2) : duplicate(spec.encoding.y)\n      }, spec.encoding.size ? {size: duplicate(spec.encoding.size)} : {})\n    };\n    layerSpec.layers.push(normalizeUnitSpec(ruleSpec));\n    layerSpec.layers.push(normalizeUnitSpec(lowerTickSpec));\n    layerSpec.layers.push(normalizeUnitSpec(upperTickSpec));\n  }\n  return layerSpec;\n}\n\nexport function normalizeOverlay(spec: UnitSpec, overlayWithPoint: boolean, overlayWithLine: boolean): LayerSpec {\n  let outerProps = ['name', 'description', 'data', 'transform'];\n  let baseSpec = omit(spec, outerProps.concat('config'));\n\n  let baseConfig = duplicate(spec.config);\n  delete baseConfig.overlay;\n  // TODO: remove shape, size\n\n  // Need to copy stack config to overlayed layer\n  const stacked = stack(spec.mark,\n    spec.encoding,\n    spec.config && spec.config.mark ? spec.config.mark.stacked : undefined\n  );\n\n  const layerSpec = extend(\n    pick(spec, outerProps),\n    { layers: [baseSpec] },\n    keys(baseConfig).length > 0 ? { config: baseConfig } : {}\n  );\n\n  if (overlayWithLine) {\n    // TODO: add name with suffix\n    let lineSpec = duplicate(baseSpec);\n    lineSpec.mark = LINE;\n    // TODO: remove shape, size\n    let markConfig = extend({},\n      defaultOverlayConfig.lineStyle,\n      spec.config.overlay.lineStyle,\n      stacked ? {stacked: stacked.offset} : null\n    );\n    if (keys(markConfig).length > 0) {\n      lineSpec.config = {mark: markConfig};\n    }\n\n    layerSpec.layers.push(lineSpec);\n  }\n\n  if (overlayWithPoint) {\n    // TODO: add name with suffix\n    let pointSpec = duplicate(baseSpec);\n    pointSpec.mark = POINT;\n\n    let markConfig = extend({},\n      defaultOverlayConfig.pointStyle,\n      spec.config.overlay.pointStyle,\n      stacked ? {stacked: stacked.offset} : null\n    );\n    if (keys(markConfig).length > 0) {\n      pointSpec.config = {mark: markConfig};\n    }\n    layerSpec.layers.push(pointSpec);\n  }\n  return layerSpec;\n}\n\n// TODO: add vl.spec.validate & move stuff from vl.validate to here\n\n/* Accumulate non-duplicate fieldDefs in a dictionary */\nfunction accumulate(dict: any, fieldDefs: FieldDef[]): any {\n  fieldDefs.forEach(function(fieldDef) {\n    // Consider only pure fieldDef properties (ignoring scale, axis, legend)\n    const pureFieldDef = ['field', 'type', 'value', 'timeUnit', 'bin', 'aggregate'].reduce((f, key) => {\n      if (fieldDef[key] !== undefined) {\n        f[key] = fieldDef[key];\n      }\n      return f;\n    }, {});\n    let key = hash(pureFieldDef);\n    dict[key] = dict[key] || fieldDef;\n  });\n  return dict;\n}\n\n/* Recursively get fieldDefs from a spec, returns a dictionary of fieldDefs */\nfunction fieldDefIndex(spec: ExtendedSpec | ExtendedFacetSpec, dict: any = {}): any {\n  // TODO: Support repeat and concat\n  if (isLayerSpec(spec)) {\n    spec.layers.forEach(function(layer) {\n      accumulate(dict, vlEncoding.fieldDefs(layer.encoding));\n    });\n  } else if (isSomeFacetSpec(spec)) {\n    accumulate(dict, vlEncoding.fieldDefs(spec.facet));\n    fieldDefIndex(spec.spec, dict);\n  } else { // Unit Spec\n    accumulate(dict, vlEncoding.fieldDefs(spec.encoding));\n  }\n  return dict;\n}\n\n/* Returns all non-duplicate fieldDefs in a spec in a flat array */\nexport function fieldDefs(spec: ExtendedSpec | ExtendedFacetSpec): FieldDef[] {\n  return vals(fieldDefIndex(spec));\n};\n\nexport function isStacked(spec: ExtendedUnitSpec): boolean {\n  return stack(spec.mark, spec.encoding,\n           (spec.config && spec.config.mark) ? spec.config.mark.stacked : undefined\n         ) !== null;\n}\n","import * as log from './log';\n\nimport {SUM_OPS} from './aggregate';\nimport {Channel, STACK_GROUP_CHANNELS, X, Y, X2, Y2} from './channel';\nimport {Encoding, channelHasField, isAggregate} from './encoding';\nimport {FieldDef, PositionFieldDef, isFieldDef} from './fielddef';\nimport {Mark, BAR, AREA, POINT, CIRCLE, SQUARE, LINE, RULE, TEXT, TICK} from './mark';\nimport {ScaleType} from './scale';\nimport {contains, isArray} from './util';\n\nexport namespace StackOffset {\n  export const ZERO: 'zero' = 'zero';\n  export const CENTER: 'center' = 'center';\n  export const NORMALIZE: 'normalize' = 'normalize';\n  export const NONE: 'none' = 'none';\n}\n\nexport type StackOffset = typeof StackOffset.ZERO | typeof StackOffset.CENTER | typeof StackOffset.NORMALIZE | typeof StackOffset.NONE;\n\nexport interface StackProperties {\n  /** Dimension axis of the stack ('x' or 'y'). */\n  groupbyChannel: Channel;\n\n  /** Measure axis of the stack ('x' or 'y'). */\n  fieldChannel: Channel;\n\n  /** Stack-by fields e.g., color, detail */\n  stackBy: {\n    fieldDef: FieldDef,\n    channel: Channel\n  }[];\n\n  /**\n   * Modes for stacking marks:\n   * - `zero`: stacking with baseline offset at zero value of the scale (for creating typical stacked [bar](mark.html#stacked-bar-chart) and [area](mark.html#stacked-area-chart) chart).\n   * - `normalize` - stacking with normalized domain (for creating normalized stacked [bar](mark.html#normalized-stacked-bar-chart) and [area](mark.html#normalized-stacked-area-chart) chart). <br/>\n   * -`center` - stacking with center baseline (for [streamgraph](mark.html#streamgraph)).\n   * - `none` - No-stacking. This will produce layered [bar](mark.html#layered-bar-chart) and area chart.\n   *\n   * __Default value:__ `zero` for plots with all of the following conditions: (1) `bar` or `area` marks (2) `color`, `opacity`, `size`, or `detail` channel mapped to a group-by field (3) One ordinal or nominal axis, and (4) one quantitative axis with linear scale and summative aggregation function (e.g., `sum`, `count`).\n   */\n  offset: StackOffset;\n}\n\nexport const STACKABLE_MARKS = [BAR, AREA, RULE, POINT, CIRCLE, SQUARE, LINE, TEXT, TICK];\nexport const STACK_BY_DEFAULT_MARKS = [BAR, AREA];\n\nexport function stack(mark: Mark, encoding: Encoding, stacked: StackOffset): StackProperties {\n  // Should not have stack explicitly disabled\n  if (contains<string | boolean>([StackOffset.NONE, null, false], stacked)) {\n    return null;\n  }\n\n  // Should have stackable mark\n  if (!contains(STACKABLE_MARKS, mark)) {\n    return null;\n  }\n\n  // Should be aggregate plot\n  if (!isAggregate(encoding)) {\n    return null;\n  }\n\n  // Should have grouping level of detail\n  const stackBy = STACK_GROUP_CHANNELS.reduce((sc, channel) => {\n    if (channelHasField(encoding, channel)) {\n      const channelDef = encoding[channel];\n      (isArray(channelDef) ? channelDef : [channelDef]).forEach((fieldDef) => {\n        if (isFieldDef(fieldDef) && !fieldDef.aggregate) {\n          sc.push({\n            channel: channel,\n            fieldDef: fieldDef\n          });\n        }\n      });\n    }\n    return sc;\n  }, []);\n\n  if (stackBy.length === 0) {\n    return null;\n  }\n\n  // Has only one aggregate axis\n  const hasXField = isFieldDef(encoding.x);\n  const hasYField = isFieldDef(encoding.y);\n  const xIsAggregate = isFieldDef(encoding.x) && !!encoding.x.aggregate;\n  const yIsAggregate = isFieldDef(encoding.y) && !!encoding.y.aggregate;\n\n  if (xIsAggregate !== yIsAggregate) {\n    const fieldChannel = xIsAggregate ? X : Y;\n    const fieldDef = encoding[fieldChannel] as PositionFieldDef;\n    const fieldChannelAggregate = fieldDef.aggregate;\n    const fieldChannelScale = fieldDef.scale;\n\n    if (contains(STACK_BY_DEFAULT_MARKS, mark)) {\n      // Bar and Area with sum ops are automatically stacked by default\n      stacked = stacked === undefined ? StackOffset.ZERO : stacked;\n    }\n\n    if (!stacked) {\n      return null;\n    }\n\n    // If stacked, check if it qualifies for stacking (and log warning if not qualified.)\n    if (fieldChannelScale && fieldChannelScale.type && fieldChannelScale.type !== ScaleType.LINEAR) {\n      log.warn(log.message.cannotStackNonLinearScale(fieldChannelScale.type));\n      return null;\n    }\n\n    if (channelHasField(encoding, fieldChannel === X ? X2 : Y2)) {\n      log.warn(log.message.cannotStackRangedMark(fieldChannel));\n      return null;\n    }\n\n    if (!contains(SUM_OPS, fieldChannelAggregate)) {\n      log.warn(log.message.cannotStackNonSummativeAggregate(fieldChannelAggregate));\n      return null;\n    }\n\n    return {\n      groupbyChannel: xIsAggregate ? (hasYField ? Y : null) : (hasXField ? X : null),\n      fieldChannel: fieldChannel,\n      stackBy: stackBy,\n      offset: stacked\n    };\n  }\n  return null;\n}\n","import {DateTimeExpr, dateTimeExpr} from './datetime';\nimport {Dict, keys} from './util';\nimport * as log from './log';\n\nexport namespace TimeUnit {\n  export const YEAR: 'year' = 'year';\n  export const MONTH: 'month' = 'month';\n  export const DAY: 'day' = 'day';\n  export const DATE: 'date' = 'date';\n  export const HOURS: 'hours' = 'hours';\n  export const MINUTES: 'minutes' = 'minutes';\n  export const SECONDS: 'seconds' = 'seconds';\n  export const MILLISECONDS: 'milliseconds' = 'milliseconds';\n  export const YEARMONTH: 'yearmonth' = 'yearmonth';\n  export const YEARMONTHDATE: 'yearmonthdate' = 'yearmonthdate';\n  export const YEARMONTHDATEHOURS: 'yearmonthdatehours' = 'yearmonthdatehours';\n  export const YEARMONTHDATEHOURSMINUTES: 'yearmonthdatehoursminutes' = 'yearmonthdatehoursminutes';\n  export const YEARMONTHDATEHOURSMINUTESSECONDS: 'yearmonthdatehoursminutesseconds' = 'yearmonthdatehoursminutesseconds';\n\n  // MONTHDATE always include 29 February since we use year 0th (which is a leap year);\n  export const MONTHDATE: 'monthdate' = 'monthdate';\n  export const HOURSMINUTES: 'hoursminutes' = 'hoursminutes';\n  export const HOURSMINUTESSECONDS: 'hoursminutesseconds' = 'hoursminutesseconds';\n  export const MINUTESSECONDS: 'minutesseconds' = 'minutesseconds';\n  export const SECONDSMILLISECONDS: 'secondsmilliseconds' = 'secondsmilliseconds';\n  export const QUARTER: 'quarter' = 'quarter';\n  export const YEARQUARTER: 'yearquarter' = 'yearquarter';\n  export const QUARTERMONTH: 'quartermonth' = 'quartermonth';\n  export const YEARQUARTERMONTH: 'yearquartermonth' = 'yearquartermonth';\n}\n\nexport type TimeUnit = typeof TimeUnit.YEAR | typeof TimeUnit.MONTH | typeof TimeUnit.DAY | typeof TimeUnit.DATE | typeof TimeUnit.HOURS\n  | typeof TimeUnit.MINUTES | typeof TimeUnit.SECONDS | typeof TimeUnit.MILLISECONDS | typeof TimeUnit.YEARMONTH\n  | typeof TimeUnit.YEARMONTHDATE | typeof TimeUnit.YEARMONTHDATEHOURS | typeof TimeUnit.YEARMONTHDATEHOURSMINUTES\n  | typeof TimeUnit.YEARMONTHDATEHOURSMINUTESSECONDS | typeof TimeUnit.MONTHDATE | typeof TimeUnit.HOURSMINUTES\n  | typeof TimeUnit.HOURSMINUTESSECONDS | typeof TimeUnit.MINUTESSECONDS | typeof TimeUnit.SECONDSMILLISECONDS\n  | typeof TimeUnit.QUARTER | typeof TimeUnit.YEARQUARTER | typeof TimeUnit.QUARTERMONTH | typeof TimeUnit.YEARQUARTERMONTH;\n\n/** Time Unit that only corresponds to only one part of Date objects. */\nexport const SINGLE_TIMEUNITS = [\n  TimeUnit.YEAR,\n  TimeUnit.QUARTER,\n  TimeUnit.MONTH,\n  TimeUnit.DAY,\n  TimeUnit.DATE,\n  TimeUnit.HOURS,\n  TimeUnit.MINUTES,\n  TimeUnit.SECONDS,\n  TimeUnit.MILLISECONDS,\n];\n\nconst SINGLE_TIMEUNIT_INDEX: Dict<boolean> = SINGLE_TIMEUNITS.reduce((d, timeUnit) => {\n  d[timeUnit] = true;\n  return d;\n}, {});\n\nexport function isSingleTimeUnit(timeUnit: TimeUnit) {\n  return !!SINGLE_TIMEUNIT_INDEX[timeUnit];\n}\n\n/**\n * Converts a date to only have the measurements relevant to the specified unit\n * i.e. ('yearmonth', '2000-12-04 07:58:14') -> '2000-12-01 00:00:00'\n * Note: the base date is Jan 01 1900 00:00:00\n */\nexport function convert(unit: TimeUnit, date: Date): Date {\n  const result: Date = new Date(0, 0, 1, 0, 0, 0, 0); // start with uniform date\n  SINGLE_TIMEUNITS.forEach(function(singleUnit) {\n    if (containsTimeUnit(unit, singleUnit)) {\n      switch (singleUnit) {\n        case TimeUnit.DAY:\n          throw new Error('Cannot convert to TimeUnits containing \\'day\\'');\n        case TimeUnit.YEAR:\n          result.setFullYear(date.getFullYear());\n          break;\n        case TimeUnit.QUARTER:\n          // indicate quarter by setting month to be the first of the quarter i.e. may (4) -> april (3)\n          result.setMonth((Math.floor(date.getMonth() / 3)) * 3);\n          break;\n        case TimeUnit.MONTH:\n          result.setMonth(date.getMonth());\n          break;\n        case TimeUnit.DATE:\n          result.setDate(date.getDate());\n          break;\n        case TimeUnit.HOURS:\n          result.setHours(date.getHours());\n          break;\n        case TimeUnit.MINUTES:\n          result.setMinutes(date.getMinutes());\n          break;\n        case TimeUnit.SECONDS:\n          result.setSeconds(date.getSeconds());\n          break;\n        case TimeUnit.MILLISECONDS:\n          result.setMilliseconds(date.getMilliseconds());\n          break;\n      }\n    }\n  });\n\n  return result;\n}\n\nexport const MULTI_TIMEUNITS = [\n  TimeUnit.YEARQUARTER,\n  TimeUnit.YEARQUARTERMONTH,\n  TimeUnit.YEARMONTH,\n  TimeUnit.YEARMONTHDATE,\n  TimeUnit.YEARMONTHDATEHOURS,\n  TimeUnit.YEARMONTHDATEHOURSMINUTES,\n  TimeUnit.YEARMONTHDATEHOURSMINUTESSECONDS,\n  TimeUnit.QUARTERMONTH,\n  TimeUnit.HOURSMINUTES,\n  TimeUnit.HOURSMINUTESSECONDS,\n  TimeUnit.MINUTESSECONDS,\n  TimeUnit.SECONDSMILLISECONDS,\n];\n\nconst MULTI_TIMEUNIT_INDEX: Dict<boolean> = MULTI_TIMEUNITS.reduce((d, timeUnit) => {\n  d[timeUnit] = true;\n  return d;\n}, {});\n\nexport function isMultiTimeUnit(timeUnit: TimeUnit) {\n  return !!MULTI_TIMEUNIT_INDEX[timeUnit];\n}\n\nexport const TIMEUNITS = [\n  TimeUnit.YEAR,\n  TimeUnit.QUARTER,\n  TimeUnit.MONTH,\n  TimeUnit.DAY,\n  TimeUnit.DATE,\n  TimeUnit.HOURS,\n  TimeUnit.MINUTES,\n  TimeUnit.SECONDS,\n  TimeUnit.MILLISECONDS,\n  TimeUnit.YEARQUARTER,\n  TimeUnit.YEARQUARTERMONTH,\n  TimeUnit.YEARMONTH,\n  TimeUnit.YEARMONTHDATE,\n  TimeUnit.YEARMONTHDATEHOURS,\n  TimeUnit.YEARMONTHDATEHOURSMINUTES,\n  TimeUnit.YEARMONTHDATEHOURSMINUTESSECONDS,\n  TimeUnit.QUARTERMONTH,\n  TimeUnit.HOURSMINUTES,\n  TimeUnit.HOURSMINUTESSECONDS,\n  TimeUnit.MINUTESSECONDS,\n  TimeUnit.SECONDSMILLISECONDS\n];\n\n/** Returns true if fullTimeUnit contains the timeUnit, false otherwise. */\nexport function containsTimeUnit(fullTimeUnit: TimeUnit, timeUnit: TimeUnit) {\n  let fullTimeUnitStr = fullTimeUnit.toString();\n  let timeUnitStr = timeUnit.toString();\n  const index = fullTimeUnitStr.indexOf(timeUnitStr);\n  return index > -1 &&\n    (\n      timeUnit !== TimeUnit.SECONDS ||\n      index === 0 ||\n      fullTimeUnitStr.charAt(index-1) !== 'i' // exclude milliseconds\n    );\n}\n\n/**\n * Returns Vega expresssion for a given timeUnit and fieldRef\n */\nexport function fieldExpr(fullTimeUnit: TimeUnit, field: string): string {\n  const fieldRef =  `datum[\"${field}\"]`;\n\n  function func(timeUnit: TimeUnit) {\n    if (timeUnit === TimeUnit.QUARTER) {\n      // quarter starting at 0 (0,3,6,9).\n      return `(quarter(${fieldRef})-1)`;\n    } else {\n      return `${timeUnit}(${fieldRef})`;\n    }\n  }\n\n  let d = SINGLE_TIMEUNITS.reduce((_d: DateTimeExpr, tu: TimeUnit) => {\n    if (containsTimeUnit(fullTimeUnit, tu)) {\n      _d[tu] = func(tu);\n    }\n    return _d;\n  }, {});\n\n  if (d.day && keys(d).length > 1) {\n    log.warn(log.message.dayReplacedWithDate(fullTimeUnit));\n    delete d.day;\n    d.date = func(TimeUnit.DATE);\n  }\n\n  return dateTimeExpr(d);\n}\n\n/** returns the smallest nice unit for scale.nice */\nexport function smallestUnit(timeUnit: TimeUnit): string {\n  if (!timeUnit) {\n    return undefined;\n  }\n\n  if (containsTimeUnit(timeUnit, TimeUnit.SECONDS)) {\n    return 'second';\n  }\n\n  if (containsTimeUnit(timeUnit, TimeUnit.MINUTES)) {\n    return 'minute';\n  }\n\n  if (containsTimeUnit(timeUnit, TimeUnit.HOURS)) {\n    return 'hour';\n  }\n\n  if (containsTimeUnit(timeUnit, TimeUnit.DAY) ||\n      containsTimeUnit(timeUnit, TimeUnit.DATE)) {\n    return 'day';\n  }\n\n  if (containsTimeUnit(timeUnit, TimeUnit.MONTH)) {\n    return 'month';\n  }\n\n  if (containsTimeUnit(timeUnit, TimeUnit.YEAR)) {\n    return 'year';\n  }\n  return undefined;\n}\n\n/** returns the signal expression used for axis labels for a time unit */\nexport function formatExpression(timeUnit: TimeUnit, field: string, shortTimeLabels: boolean): string {\n  if (!timeUnit) {\n    return undefined;\n  }\n\n  let dateComponents: string[] = [];\n  let expression = '';\n  const hasYear = containsTimeUnit(timeUnit, TimeUnit.YEAR);\n\n  if (containsTimeUnit(timeUnit, TimeUnit.QUARTER)) {\n   // special expression for quarter as prefix\n    expression = `'Q' + quarter(${field})`;\n  }\n\n  if (containsTimeUnit(timeUnit, TimeUnit.MONTH)) {\n    // By default use short month name\n    dateComponents.push(shortTimeLabels !== false ? '%b' : '%B');\n  }\n\n  if (containsTimeUnit(timeUnit, TimeUnit.DAY)) {\n    dateComponents.push(shortTimeLabels ? '%a' : '%A');\n  } else if (containsTimeUnit(timeUnit, TimeUnit.DATE)) {\n    dateComponents.push('%d' + (hasYear ? ',' : '')); // add comma if there is year\n  }\n\n  if (hasYear) {\n    dateComponents.push(shortTimeLabels ? '%y' : '%Y');\n  }\n\n  let timeComponents: string[] = [];\n\n  if (containsTimeUnit(timeUnit, TimeUnit.HOURS)) {\n    timeComponents.push('%H');\n  }\n  if (containsTimeUnit(timeUnit, TimeUnit.MINUTES)) {\n    timeComponents.push('%M');\n  }\n  if (containsTimeUnit(timeUnit, TimeUnit.SECONDS)) {\n    timeComponents.push('%S');\n  }\n  if (containsTimeUnit(timeUnit, TimeUnit.MILLISECONDS)) {\n    timeComponents.push('%L');\n  }\n\n  let dateTimeComponents: string[] = [];\n  if (dateComponents.length > 0) {\n    dateTimeComponents.push(dateComponents.join(' '));\n  }\n  if (timeComponents.length > 0) {\n    dateTimeComponents.push(timeComponents.join(':'));\n  }\n\n  if (dateTimeComponents.length > 0) {\n    if (expression) {\n      // Add space between quarter and main time format\n      expression += ` + ' ' + `;\n    }\n    expression += `timeFormat(${field}, '${dateTimeComponents.join(' ')}')`;\n  }\n\n  // If expression is still an empty string, return undefined instead.\n  return expression || undefined;\n}\n","/** Constants and utilities for data type */\n\nexport namespace Type {\n  export const QUANTITATIVE: 'quantitative' = 'quantitative';\n  export const ORDINAL: 'ordinal' = 'ordinal';\n  export const TEMPORAL: 'temporal' = 'temporal';\n  export const NOMINAL: 'nominal' = 'nominal';\n}\nexport type Type = typeof Type.QUANTITATIVE | typeof Type.ORDINAL | typeof Type.TEMPORAL | typeof Type.NOMINAL;\n\nexport const QUANTITATIVE = Type.QUANTITATIVE;\nexport const ORDINAL = Type.ORDINAL;\nexport const TEMPORAL = Type.TEMPORAL;\nexport const NOMINAL = Type.NOMINAL;\n\n/**\n * Get full, lowercase type name for a given type.\n * @param  type\n * @return Full type name.\n */\nexport function getFullName(type: Type|string): Type {\n  if (type) {\n    type = type.toLowerCase();\n    switch (type) {\n      case 'q':\n      case QUANTITATIVE:\n        return 'quantitative';\n      case 't':\n      case TEMPORAL:\n        return 'temporal';\n      case 'o':\n      case ORDINAL:\n        return 'ordinal';\n      case 'n':\n      case NOMINAL:\n        return 'nominal';\n    }\n  }\n  // If we get invalid input, return undefined type.\n  return undefined;\n}\n","import * as stringify from 'json-stable-stringify';\nexport {extend, isArray, isObject, isNumber, isString, truncate, toSet} from 'vega-util';\nimport {isNumber, isString} from 'vega-util';\n\n/**\n * Creates an object composed of the picked object properties.\n *\n * Example:  (from lodash)\n *\n * var object = { 'a': 1, 'b': '2', 'c': 3 };\n * pick(object, ['a', 'c']);\n * // → { 'a': 1, 'c': 3 }\n *\n */\nexport function pick(obj: any, props: string[]) {\n  let copy = {};\n  props.forEach((prop) => {\n    if (obj.hasOwnProperty(prop)) {\n      copy[prop] = obj[prop];\n    }\n  });\n  return copy;\n}\n\n/**\n * The opposite of _.pick; this method creates an object composed of the own\n * and inherited enumerable string keyed properties of object that are not omitted.\n */\nexport function omit(obj: any, props: string[]) {\n  let copy = duplicate(obj);\n  props.forEach((prop) => {\n    delete copy[prop];\n  });\n  return copy;\n}\n\nexport function hash(a: any) {\n  if (isString(a) || isNumber(a) || isBoolean(a)) {\n    return String(a);\n  }\n  return stringify(a);\n}\n\nexport function contains<T>(array: Array<T>, item: T) {\n  return array.indexOf(item) > -1;\n}\n\n/** Returns the array without the elements in item */\nexport function without<T>(array: Array<T>, excludedItems: Array<T>) {\n  return array.filter(item => !contains(excludedItems, item));\n}\n\nexport function union<T>(array: Array<T>, other: Array<T>) {\n  return array.concat(without(other, array));\n}\n\nexport function reduce(obj: any, f: (a: any, i: any, d: any, k: any, o: any) => any, init: any, thisArg?: any) {\n  if (obj.reduce) {\n    return obj.reduce.call(thisArg, f, init);\n  } else {\n    for (let k in obj) {\n      if (obj.hasOwnProperty(k)) {\n        init = f.call(thisArg, init, obj[k], k, obj);\n      }\n    }\n    return init;\n  }\n}\n\nexport function some<T>(arr: Array<T>, f: (d: T, k?: any, i?: any) => boolean) {\n  let i = 0;\n  for (let k = 0; k<arr.length; k++) {\n    if (f(arr[k], k, i++)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function every<T>(arr: Array<T>, f: (d: T, k?: any, i?: any) => boolean) {\n  let i = 0;\n  for (let k = 0; k<arr.length; k++) {\n    if (!f(arr[k], k, i++)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function flatten(arrays: any[]) {\n  return [].concat.apply([], arrays);\n}\n\nexport function mergeDeep(dest: any, ...src: any[]) {\n  for (const s of src) {\n    dest = deepMerge_(dest, s);\n  }\n  return dest;\n};\n\n// recursively merges src into dest\nfunction deepMerge_(dest: any, src: any) {\n  if (typeof src !== 'object' || src === null) {\n    return dest;\n  }\n\n  for (let p in src) {\n    if (!src.hasOwnProperty(p)) {\n      continue;\n    }\n    if (src[p] === undefined) {\n      continue;\n    }\n    if (typeof src[p] !== 'object' || src[p] === null) {\n      dest[p] = src[p];\n    } else if (typeof dest[p] !== 'object' || dest[p] === null) {\n      dest[p] = mergeDeep(src[p].constructor === Array ? [] : {}, src[p]);\n    } else {\n      mergeDeep(dest[p], src[p]);\n    }\n  }\n  return dest;\n}\n\nexport function unique<T>(values: T[], f: (item: T) => string): T[] {\n  let results: any[] = [];\n  let u = {}, v: string;\n  for (const val of values) {\n    v = f(val);\n    if (v in u) {\n      continue;\n    }\n    u[v] = 1;\n    results.push(val);\n  }\n  return results;\n};\n\nexport interface Dict<T> {\n  [key: string]: T;\n}\n\nexport type StringSet = Dict<boolean>;\n\n/**\n * Returns true if the two dictionaries disagree. Applies only to defined values.\n */\nexport function differ<T>(dict: Dict<T>, other: Dict<T>) {\n  for (let key in dict) {\n    if (dict.hasOwnProperty(key)) {\n      if (other[key] && dict[key] && other[key] !== dict[key]) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nexport const keys = Object.keys;\n\nexport function vals(x: any) {\n  let _vals: any[] = [];\n  for (let k in x) {\n    if (x.hasOwnProperty(k)) {\n      _vals.push(x[k]);\n    }\n  }\n  return _vals;\n};\n\nexport function duplicate<T>(obj: T): T {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nexport function isBoolean(b: any): b is boolean {\n  return b === true || b === false;\n}\n","import {ExtendedUnitSpec} from './spec';\n\n// TODO: move to vl.spec.validator?\n\nimport {toSet} from './util';\nimport {BAR} from './mark';\n\nexport interface RequiredChannelMap {\n  [mark: string]: Array<string>;\n}\n\n/**\n * Required Encoding Channels for each mark type\n * @type {Object}\n */\nexport const DEFAULT_REQUIRED_CHANNEL_MAP: RequiredChannelMap = {\n  text: ['text'],\n  line: ['x', 'y'],\n  area: ['x', 'y']\n};\n\nexport interface SupportedChannelMap {\n  [mark: string]: {\n    [channel: string]: number\n  };\n}\n\n/**\n * Supported Encoding Channel for each mark type\n */\nexport const DEFAULT_SUPPORTED_CHANNEL_TYPE: SupportedChannelMap = {\n  bar: toSet(['row', 'column', 'x', 'y', 'size', 'color', 'detail']),\n  line: toSet(['row', 'column', 'x', 'y', 'color', 'detail']), // TODO: add size when Vega supports\n  area: toSet(['row', 'column', 'x', 'y', 'color', 'detail']),\n  tick: toSet(['row', 'column', 'x', 'y', 'color', 'detail']),\n  circle: toSet(['row', 'column', 'x', 'y', 'color', 'size', 'detail']),\n  square: toSet(['row', 'column', 'x', 'y', 'color', 'size', 'detail']),\n  point: toSet(['row', 'column', 'x', 'y', 'color', 'size', 'detail', 'shape']),\n  text: toSet(['row', 'column', 'size', 'color', 'text']) // TODO(#724) revise\n};\n\n// TODO: consider if we should add validate method and\n// requires ZSchema in the main vega-lite repo\n\n/**\n * Further check if encoding mapping of a spec is invalid and\n * return error if it is invalid.\n *\n * This checks if\n * (1) all the required encoding channels for the mark type are specified\n * (2) all the specified encoding channels are supported by the mark type\n * @param  {[type]} spec [description]\n * @param  {RequiredChannelMap  = DefaultRequiredChannelMap}  requiredChannelMap\n * @param  {SupportedChannelMap = DefaultSupportedChannelMap} supportedChannelMap\n * @return {String} Return one reason why the encoding is invalid,\n *                  or null if the encoding is valid.\n */\nexport function getEncodingMappingError(spec: ExtendedUnitSpec,\n  requiredChannelMap: RequiredChannelMap = DEFAULT_REQUIRED_CHANNEL_MAP,\n  supportedChannelMap: SupportedChannelMap = DEFAULT_SUPPORTED_CHANNEL_TYPE\n  ) {\n  let mark = spec.mark;\n  let encoding = spec.encoding;\n  let requiredChannels = requiredChannelMap[mark];\n  let supportedChannels = supportedChannelMap[mark];\n\n  for (let i in requiredChannels) { // all required channels are in encoding`\n    if (!(requiredChannels[i] in encoding)) {\n      return 'Missing encoding channel \\\"' + requiredChannels[i] +\n        '\\\" for mark \\\"' + mark + '\\\"';\n    }\n  }\n\n  for (let channel in encoding) { // all channels in encoding are supported\n    if (!supportedChannels[channel]) {\n      return 'Encoding channel \\\"' + channel +\n        '\\\" is not supported by mark type \\\"' + mark + '\\\"';\n    }\n  }\n\n  if (mark === BAR && !encoding.x && !encoding.y) {\n    return 'Missing both x and y for bar';\n  }\n\n  return null;\n}\n","import {StackOffset} from './stack';\nimport {ScaleType, NiceTime} from './scale';\nimport {isArray} from './util';\n\nexport interface VgData {\n  name: string;\n  source?: string;\n  values?: any;\n  format?: any;\n  url?: any;\n  transform?: any;\n}\n\nexport type VgParentRef = {\n  parent: string\n};\n\nexport type VgFieldRef = string | VgParentRef | VgParentRef[];\n\nexport type VgSortField = boolean | {\n  field: VgFieldRef,\n  op: string\n};\n\nexport type VgDataRef = {\n  data: string,\n  field: VgFieldRef,\n  sort?: VgSortField\n};\n\n// TODO: add type of value (Make it VgValueRef<T> { value?:T ... })\nexport type VgValueRef = {\n  value?: number | string | boolean,\n  field?: string | {\n    datum?: string,\n    group?: string,\n    parent?: string\n  },\n  signal?: string;\n  scale?: string, // TODO: object\n  mult?: number,\n  offset?: number | VgValueRef,\n  band?: boolean | number\n};\n\n// TODO: add vg prefix\nexport type DataRefUnionDomain = {\n  fields: (any[] | VgDataRef)[],\n  sort?: boolean | {\n    op: 'count'\n  }\n};\n\n// TODO: add vg prefix\nexport type FieldRefUnionDomain = {\n  data: string,\n  fields: VgFieldRef[],\n  sort?: boolean | {\n    op: 'count'\n  }\n};\n\nexport type VgRangeScheme = {scheme: string, extent?: number[], count?: number};\nexport type VgRange = string | VgDataRef | (number|string|VgDataRef)[] | VgRangeScheme | {step: number};\n\nexport type VgDomain = any[] | VgDataRef | DataRefUnionDomain | FieldRefUnionDomain;\n\nexport type VgScale = {\n  name: string,\n  type: ScaleType,\n  domain: VgDomain,\n  range: VgRange,\n\n  clamp?: boolean,\n  exponent?: number,\n  nice?: boolean | NiceTime,\n  padding?: number,\n  paddingInner?: number,\n  paddingOuter?: number,\n  reverse?: boolean,\n  round?: boolean,\n  zero?: boolean\n};\n\nexport function isDataRefUnionedDomain(domain: VgDomain): domain is DataRefUnionDomain {\n  if (!isArray(domain)) {\n    return 'fields' in domain && !('data' in domain);\n  }\n  return false;\n}\n\nexport function isFieldRefUnionDomain(domain: VgDomain): domain is FieldRefUnionDomain {\n  if (!isArray(domain)) {\n    return 'fields' in domain && 'data' in domain;\n  }\n  return false;\n}\n\nexport function isDataRefDomain(domain: VgDomain): domain is VgDataRef {\n  if (!isArray(domain)) {\n    return !('fields' in domain);\n  }\n  return false;\n}\n\nexport type VgEncodeEntry = any;\n// TODO: make export interface VgEncodeEntry {\n//   x?: VgValueRef<number>\n//   y?: VgValueRef<number>\n//  ...\n//   color?: VgValueRef<string>\n//  ...\n// }\n\nexport type VgAxis = any;\nexport type VgLegend = any;\n\nexport interface VgBinTransform {\n  type: 'bin';\n  field: string;\n  as: string;\n  extent?: {signal: string};\n  // TODO: add other properties\n}\n\nexport interface VgExtentTransform {\n  type: 'extent';\n  field: string;\n  signal: string;\n}\n\nexport interface VgFormulaTransform {\n  type: 'formula';\n  as: string;\n  expr: string;\n}\n\nexport interface VgAxisEncode {\n  ticks?: VgGuideEncode;\n  labels?: VgGuideEncode;\n  title?: VgGuideEncode;\n  grid?: VgGuideEncode;\n  domain?: VgGuideEncode;\n}\n\nexport interface VgLegendEncode {\n  title?: VgGuideEncode;\n  labels?: VgGuideEncode;\n  legend?: VgGuideEncode;\n  symbols?: VgGuideEncode;\n  gradient?: VgGuideEncode;\n}\n\nexport type VgGuideEncode = any; // TODO: replace this (See guideEncode in Vega Schema)\n\nexport type VgTransform = VgBinTransform | VgExtentTransform | VgFormulaTransform | any;\n\nexport interface VgStackTransform {\n  type: 'stack';\n  offset?: StackOffset;\n  groupby: string[];\n  field: string;\n  sort: VgSort;\n  as: string[];\n}\n\nexport type VgSort = {\n  field: string;\n  order: 'ascending' | 'descending';\n} | {\n  field: string[];\n  order: ('ascending' | 'descending')[];\n};\n\nexport interface VgImputeTransform {\n  type: 'impute';\n  groupby?: string[];\n  field: string;\n  orderby?: string[];\n  method?: 'value' | 'median' | 'max' | 'min' | 'mean';\n  value?: any;\n}\n","export import axis = require('./axis');\nexport import aggregate = require('./aggregate');\nexport import bin = require('./bin');\nexport import channel = require('./channel');\nexport {compile}  from './compile/compile';\nexport import config = require('./config');\nexport import data = require('./data');\nexport import datetime = require('./datetime');\nexport import encoding = require('./encoding');\nexport import facet = require('./facet');\nexport import fieldDef = require('./fielddef');\nexport import legend = require('./legend');\nexport import mark = require('./mark');\nexport import scale = require('./scale');\nexport import sort = require('./sort');\nexport import spec = require('./spec');\nexport import stack = require('./stack');\nexport import timeUnit = require('./timeunit');\nexport import transform = require('./transform');\nexport import type = require('./type');\nexport import util = require('./util');\nexport import validate = require('./validate');\n\nexport const version: string = require('../package.json').version;\n"]}