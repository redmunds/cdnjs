{"version":3,"sources":["handler/legacy.js"],"names":["definition","path","Failure","handlerModule","isObject","onPostConfigure","options","settings","finalize","deferred","result","self","this","probe","process","call","pledge","isPending","provide","reject","demand","on","matchType","onPreRequest","dependencies","apply","catch","arguments","mock","onPostRequest","resolve","bind","then"],"mappings":";CAYC,WACA,YAEA,SAASA,GAAWC,EAAMC,EAASC,EAAeC,GAGjD,QAASC,GAAgBC,GACxBC,EAAWH,EAASE,GAAWA,KAKhC,QAASE,KACR,GAECC,GAAUC,EAFPC,EAAQC,KACXC,EAAQN,EAASI,EAAKV,OAASM,EAASI,EAAKV,MAAMY,KAGpDV,GAAcW,QAAQC,KAAKJ,GAExBE,IACFJ,EAAWE,EAAKF,SAEbA,EAASO,OAAOC,eACfP,EAASG,KACXK,QAAQ,WAAa,MAAOR,KAE5BD,EAASU,OAAO,GAAIjB,GAAQ,gBAAiBS,EAAKV,SAtBtD,GAAIM,EA4BJ,OAtBAa,QAAOC,GAAG,iBAAmBpB,EAAMI,IAuBlCiB,UAAenB,EAAcmB,UAC7BC,aAAe,WACd,GAAIZ,GAAeC,KAClBH,EAAeE,EAAKF,SACpBe,EAAejB,EAASI,EAAKV,OAASM,EAASI,EAAKV,MAAMuB,YAExDA,KACFb,EAAKa,aAAeA,EAAeJ,OAAOK,MAAM,KAAMD,GAAcE,MACnE,WACCjB,EAASU,OAAO,GAAIjB,GAAQ,kBAAmBS,EAAKV,KAAM0B,eAK1DH,GAAgBb,EAAKiB,OACvBjB,EAAKiB,KAAKJ,aAAeA,GAG1BrB,EAAcoB,aAAaR,KAAKH,OAEjCiB,cAAe1B,EAAc0B,cAC7Bf,QAAS,WACR,GAAIH,GAAUC,KACbkB,EAAUtB,EAASuB,KAAKpB,EAEtBA,GAAKa,aACPb,EAAKa,aAAaQ,KACjBF,EACAnB,EAAKF,SAASU,QAGfW,MAMJZ,SAAU,OAAQ,kBAAmB,yBAA0B,8BAAgClB","file":"legacy.js","sourcesContent":["/**\n * Qoopido.demand handler/legacy\n *\n * Copyright (c) 2016 Dirk Lueth\n *\n * Dual licensed under the MIT and GPL licenses.\n *  - http://www.opensource.org/licenses/mit-license.php\n *  - http://www.gnu.org/copyleft/gpl.html\n *\n * @author Dirk Lueth <info@qoopido.com>\n */\n\n(function() {\n\t'use strict';\n\n\tfunction definition(path, Failure, handlerModule, isObject) {\n\t\tvar settings;\n\t\t\n\t\tfunction onPostConfigure(options) {\n\t\t\tsettings = isObject(options) ? options : {};\n\t\t}\n\t\t\n\t\tdemand.on('postConfigure:' + path, onPostConfigure);\n\t\t\n\t\tfunction finalize() {\n\t\t\tvar self  = this,\n\t\t\t\tprobe = settings[self.path] && settings[self.path].probe,\n\t\t\t\tdeferred, result;\n\n\t\t\thandlerModule.process.call(self);\n\n\t\t\tif(probe) {\n\t\t\t\tdeferred = self.deferred;\n\n\t\t\t\tif(deferred.pledge.isPending()) {\n\t\t\t\t\tif(result = probe()) {\n\t\t\t\t\t\tprovide(function() { return result; });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdeferred.reject(new Failure('error probing', self.path));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tmatchType:     handlerModule.matchType,\n\t\t\tonPreRequest:  function() {\n\t\t\t\tvar self         = this,\n\t\t\t\t\tdeferred     = self.deferred,\n\t\t\t\t\tdependencies = settings[self.path] && settings[self.path].dependencies;\n\n\t\t\t\tif(dependencies) {\n\t\t\t\t\tself.dependencies = dependencies = demand.apply(null, dependencies).catch(\n\t\t\t\t\t\tfunction() {\n\t\t\t\t\t\t\tdeferred.reject(new Failure('error resolving', self.path, arguments));\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif(dependencies && self.mock) {\n\t\t\t\t\tself.mock.dependencies = dependencies;\n\t\t\t\t}\n\n\t\t\t\thandlerModule.onPreRequest.call(this);\n\t\t\t},\n\t\t\tonPostRequest: handlerModule.onPostRequest,\n\t\t\tprocess: function() {\n\t\t\t\tvar self    = this,\n\t\t\t\t\tresolve = finalize.bind(self);\n\t\t\t\t\n\t\t\t\tif(self.dependencies) {\n\t\t\t\t\tself.dependencies.then(\n\t\t\t\t\t\tresolve,\n\t\t\t\t\t\tself.deferred.reject\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\tprovide([ 'path', '/demand/failure', '/demand/handler/module', '/demand/validator/isObject' ], definition);\n}());"]}