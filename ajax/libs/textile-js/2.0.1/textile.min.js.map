{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///textile.min.js","webpack:///webpack/bootstrap c3fdea779de427360583","webpack:///./src/index.js","webpack:///./src/merge.js","webpack:///./src/jsonml.js","webpack:///./src/html.js","webpack:///./src/re.js","webpack:///./src/ribbon.js","webpack:///./src/textile/flow.js","webpack:///./src/builder.js","webpack:///./src/fixlinks.js","webpack:///./src/textile/phrase.js","webpack:///./src/textile/attr.js","webpack:///./src/textile/glyph.js","webpack:///./src/textile/re_ext.js","webpack:///./src/textile/list.js","webpack:///./src/textile/deflist.js","webpack:///./src/textile/table.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","textile","txt","opt","merge","defaults","parseFlow","map","toHTML","join","_require","_require2","_require3","parseHtml","breaks","setOptions","setoptions","parse","convert","html_parser","jsonml","concat","serialize","a","b","k","reIndent","ml","shiftBy","s","test","slice","i","Array","isArray","escape","text","escapeQuotes","replace","tag","shift","attributes","tagAttrs","content","length","_typeof","push","String","singletons","Symbol","iterator","obj","constructor","allowAll","testComment","src","reComment","exec","testOpenTagBlock","reHtmlTagBlock","testOpenTag","reTag","testCloseTag","reEndTag","parseHtmlAttr","attrSrc","attr","reAttr","whitelistTags","list","_stack","oktag","ribbon","advance","head","splice","single","tail","element","valueOf","re","pattern","html_id","html_attr","compile","br","hr","img","link","meta","wbr","area","param","input","option","base","col","_cache","punct","space","collapse","expandPatterns","ex","Error","isRegExp","r","Object","prototype","toString","flags","arguments","global","ignoreCase","multiline","source","ckey","rx","RegExp","feed","org","slot","pos","save","load","$","n","lookbehind","nchars","startsWith","substring","paragraph","pba","linebreak","options","out","split","forEach","bit","trim","parsePhrase","builder","linkRefs","reLinkRef","reBlock","blockType","parseAttr","extended","reBlockGlob","reBlockExtended","reBlockNormal","inner","cite","par","copyAttr","add","subPba","reFootnoteDef","fnid","href","allowedBlocktags","code","reRuler","testList","parseList","testDefList","parseDefList","testTable","parseTable","undefined","fixLinks","get","_require4","_require5","_require6","_require7","txblocks","txlisthd","txattr","ul","ol","li","div","pre","object","script","noscript","blockquote","notextile","initArr","arr","node","filter","l","dict","behind","boundary","rePhrase","tok","fence","phraseType","phraseConvert","mMid","mEnd","t1","charAt","reImage","reImageFenced","alt","title","reFootnote","class","reCaps","caps","reLink","reLinkFenced","match","reLinkTitle","parseGlyph","ucaps","txcite","*","**","??","_","__","-","%","+","~","^","@","blacklist","d","testBlock","name","endToken","st","o","style","remaining","isBlock","isImg","isList","isPhrase","reAlign","reAlignImg","reAlignBlock","reStyles","reCSS","reLang","rm","reClassid","_rm","bits","rePaddingL","rePaddingR","align","pbaAlignLookup","reVAlign","reColSpan","reRowSpan","pbaVAlignLookup","v","<","=",">","<>","reApostrophe","reArrow","reClosingDQuote","reClosingSQuote","reCopyright","reDimsign","reDoublePrime","reEllipsis","reEmdash","reEndash","reOpenDQuote","reOpenSQuote","reRegistered","reSinglePrime","reTrademark","attr_class","attr_style","attr_lang","attr_align","attr_pad","listPad","reList","stack","currIndex","lastIndex","_lst","itemIndex","listAttr","reItem","item","destLevel","type","substr","newLi","lst","isFinite","parseInt","att","pop","start","apply","reDeflist","deflist","terms","def","parseColgroup","colgroup","isCol","span","width","reTable","rowgroups","caption","tAttr","tCurr","row","more","setRowGroup","reHead","summary","reCaption","reColgroup","reRowgroup","charToTag","reRow","th","cell","mx","table","tbody"],"mappings":"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","file":"textile.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"textile\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"textile\"] = factory();\n\telse\n\t\troot[\"textile\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"textile\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"textile\"] = factory();\n\telse\n\t\troot[\"textile\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/*\n\t** Textile parser for JavaScript\n\t**\n\t** Copyright (c) 2012 Borgar Þorsteinsson (MIT License).\n\t**\n\t*/\n\t\n\tvar merge = __webpack_require__(1);\n\t\n\tvar _require = __webpack_require__(2);\n\t\n\tvar toHTML = _require.toHTML;\n\t\n\tvar _require2 = __webpack_require__(6);\n\t\n\tvar parseFlow = _require2.parseFlow;\n\t\n\tvar _require3 = __webpack_require__(3);\n\t\n\tvar parseHtml = _require3.parseHtml;\n\t\n\t\n\tfunction textile(txt, opt) {\n\t  // get a throw-away copy of options\n\t  opt = merge(merge({}, textile.defaults), opt || {});\n\t  // run the converter\n\t  return parseFlow(txt, opt).map(toHTML).join('');\n\t};\n\tmodule.exports = textile;\n\t\n\t// options\n\ttextile.defaults = {\n\t  // single-line linebreaks are converted to <br> by default\n\t  'breaks': true\n\t};\n\ttextile.setOptions = textile.setoptions = function (opt) {\n\t  merge(textile.defaults, opt);\n\t  return this;\n\t};\n\t\n\ttextile.parse = textile.convert = textile;\n\ttextile.html_parser = parseHtml;\n\t\n\ttextile.jsonml = function (txt, opt) {\n\t  // get a throw-away copy of options\n\t  opt = merge(merge({}, textile.defaults), opt || {});\n\t  // parse and return tree\n\t  return ['html'].concat(parseFlow(txt, opt));\n\t};\n\ttextile.serialize = toHTML;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\t// merge object b properties into object a\n\tmodule.exports = function merge(a, b) {\n\t  if (b) {\n\t    for (var k in b) {\n\t      a[k] = b[k];\n\t    }\n\t  }\n\t  return a;\n\t};\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\t/*\n\t** JSONML helper methods - http://www.jsonml.org/\n\t**\n\t** This provides the `JSONML` object, which contains helper\n\t** methods for rendering JSONML to HTML.\n\t**\n\t** Note that the tag ! is taken to mean comment, this is however\n\t** not specified in the JSONML spec.\n\t*/\n\t\n\tvar singletons = __webpack_require__(3).singletons;\n\t\n\t// drop or add tab levels to JsonML tree\n\tfunction reIndent(ml, shiftBy) {\n\t  // a bit obsessive, but there we are...\n\t  if (!shiftBy) {\n\t    return ml;\n\t  }\n\t  return ml.map(function (s) {\n\t    if (/^\\n\\t+/.test(s)) {\n\t      if (shiftBy < 0) {\n\t        s = s.slice(0, shiftBy);\n\t      } else {\n\t        for (var i = 0; i < shiftBy; i++) {\n\t          s += '\\t';\n\t        }\n\t      }\n\t    } else if (Array.isArray(s)) {\n\t      return reIndent(s, shiftBy);\n\t    }\n\t    return s;\n\t  });\n\t}\n\t\n\tfunction escape(text, escapeQuotes) {\n\t  return text.replace(/&(?!(#\\d{2,}|#x[\\da-fA-F]{2,}|[a-zA-Z][a-zA-Z1-4]{1,6});)/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, escapeQuotes ? '&quot;' : '\"').replace(/'/g, escapeQuotes ? '&#39;' : \"'\");\n\t}\n\t\n\tfunction toHTML(jsonml) {\n\t  jsonml = jsonml.concat();\n\t\n\t  // basic case\n\t  if (typeof jsonml === 'string') {\n\t    return escape(jsonml);\n\t  }\n\t\n\t  var tag = jsonml.shift();\n\t  var attributes = {};\n\t  var tagAttrs = '';\n\t  var content = [];\n\t\n\t  if (jsonml.length && _typeof(jsonml[0]) === 'object' && !Array.isArray(jsonml[0])) {\n\t    attributes = jsonml.shift();\n\t  }\n\t\n\t  while (jsonml.length) {\n\t    content.push(toHTML(jsonml.shift()));\n\t  }\n\t\n\t  for (var a in attributes) {\n\t    tagAttrs += attributes[a] == null ? ' ' + a : ' ' + a + '=\"' + escape(String(attributes[a]), true) + '\"';\n\t  }\n\t\n\t  // be careful about adding whitespace here for inline elements\n\t  if (tag === '!') {\n\t    return '<!--' + content.join('') + '-->';\n\t  } else if (tag in singletons) {\n\t    return '<' + tag + tagAttrs + ' />';\n\t  } else {\n\t    return '<' + tag + tagAttrs + '>' + content.join('') + '</' + tag + '>';\n\t  }\n\t}\n\t\n\tmodule.exports = {\n\t  reIndent: reIndent,\n\t  toHTML: toHTML,\n\t  escape: escape\n\t};\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar re = __webpack_require__(4);\n\tvar ribbon = __webpack_require__(5);\n\t\n\tre.pattern.html_id = '[a-zA-Z][a-zA-Z\\\\d:]*';\n\tre.pattern.html_attr = '(?:\"[^\"]+\"|\\'[^\\']+\\'|[^>\\\\s]+)';\n\t\n\tvar reAttr = re.compile(/^\\s*([^=\\s]+)(?:\\s*=\\s*(\"[^\"]+\"|'[^']+'|[^>\\s]+))?/);\n\tvar reComment = re.compile(/^<!--(.+?)-->/, 's');\n\tvar reEndTag = re.compile(/^<\\/([:html_id:])([^>]*)>/);\n\tvar reTag = re.compile(/^<([:html_id:])((?:\\s[^=\\s\\/]+(?:\\s*=\\s*[:html_attr:])?)+)?\\s*(\\/?)>(\\n*)/);\n\tvar reHtmlTagBlock = re.compile(/^\\s*<([:html_id:](?::[a-zA-Z\\d]+)*)((?:\\s[^=\\s\\/]+(?:\\s*=\\s*[:html_attr:])?)+)?\\s*(\\/?)>(\\n*)/);\n\t\n\t// area, base, basefont, bgsound, br, col, command, embed, frame, hr,\n\t// img, input, keygen, link, meta, param, source, track or wbr\n\tvar singletons = {\n\t  br: 1,\n\t  hr: 1,\n\t  img: 1,\n\t  link: 1,\n\t  meta: 1,\n\t  wbr: 1,\n\t  area: 1,\n\t  param: 1,\n\t  input: 1,\n\t  option: 1,\n\t  base: 1,\n\t  col: 1\n\t};\n\t\n\tfunction allowAll() {\n\t  return true;\n\t}\n\t\n\tfunction testComment(src) {\n\t  return reComment.exec(src);\n\t}\n\t\n\tfunction testOpenTagBlock(src) {\n\t  return reHtmlTagBlock.exec(src);\n\t}\n\t\n\tfunction testOpenTag(src) {\n\t  return reTag.exec(src);\n\t}\n\t\n\tfunction testCloseTag(src) {\n\t  return reEndTag.exec(src);\n\t}\n\t\n\tfunction parseHtmlAttr(attrSrc) {\n\t  // parse ATTR and add to element\n\t  var attr = {};\n\t  var m = void 0;\n\t  while (m = reAttr.exec(attrSrc)) {\n\t    attr[m[1]] = typeof m[2] === 'string' ? m[2].replace(/^([\"'])(.*)\\1$/, '$2') : null;\n\t    attrSrc = attrSrc.slice(m[0].length);\n\t  }\n\t  return attr;\n\t}\n\t\n\t// This \"indesciminately\" parses HTML text into a list of JSON-ML element\n\t// No steps are taken however to prevent things like <table><p><td> - user can still create nonsensical but \"well-formed\" markup\n\tfunction parseHtml(src, whitelistTags) {\n\t  var root = [];\n\t  var list = root;\n\t  var _stack = [];\n\t  var oktag = whitelistTags ? function (tag) {\n\t    return tag in whitelistTags;\n\t  } : allowAll;\n\t  var m = void 0;\n\t  var tag = void 0;\n\t\n\t  src = typeof src === 'string' ? ribbon(src) : src;\n\t  // loop\n\t  do {\n\t    // comment\n\t    if ((m = testComment(src)) && oktag('!')) {\n\t      src.advance(m[0]);\n\t      list.push(['!', m[1]]);\n\t    }\n\t\n\t    // end tag\n\t    else if ((m = testCloseTag(src)) && oktag(m[1])) {\n\t        tag = m[1];\n\t        if (_stack.length) {\n\t          for (var i = _stack.length - 1; i >= 0; i--) {\n\t            var head = _stack[i];\n\t            if (head[0] === tag) {\n\t              _stack.splice(i);\n\t              list = _stack[_stack.length - 1] || root;\n\t              break;\n\t            }\n\t          }\n\t        }\n\t        src.advance(m[0]);\n\t      }\n\t\n\t      // open/void tag\n\t      else if ((m = testOpenTag(src)) && oktag(m[1])) {\n\t          src.advance(m[0]);\n\t          tag = m[1];\n\t          var single = m[3] || m[1] in singletons;\n\t          var tail = m[4];\n\t          var element = [tag];\n\t\n\t          // attributes\n\t          if (m[2]) {\n\t            element.push(parseHtmlAttr(m[2]));\n\t          }\n\t\n\t          // single tag\n\t          if (single) {\n\t            // let us add the element and continue our quest...\n\t            list.push(element);\n\t            if (tail) {\n\t              list.push(tail);\n\t            }\n\t          }\n\t          // open tag\n\t          else {\n\t              if (tail) {\n\t                element.push(tail);\n\t              }\n\t\n\t              // TODO: some things auto close other things: <td>, <li>, <p>, <table>\n\t              // if ( tag === 'p' && _stack.length ) {\n\t              //   var seek = /^(p)$/;\n\t              //   for (var i=_stack.length-1; i>=0; i--) {\n\t              //     var head = _stack[i];\n\t              //     if ( seek.test( head[0] ) /* === tag */ ) {\n\t              //       //src.advance( m[0] );\n\t              //       _stack.splice( i );\n\t              //       list = _stack[i] || root;\n\t              //     }\n\t              //   }\n\t              // }\n\t\n\t              // TODO: some elements can move parser into \"text\" mode\n\t              // style, xmp, iframe, noembed, noframe, textarea, title, script, noscript, plaintext\n\t              // if ( /^(script)$/.test( tag ) ) { }\n\t\n\t              _stack.push(element);\n\t              list.push(element);\n\t              list = element;\n\t            }\n\t        }\n\t        // text content\n\t        else {\n\t            // no match, move by all \"uninteresting\" chars\n\t            m = /([^<]+|[^\\0])/.exec(src);\n\t            if (m) {\n\t              list.push(m[0]);\n\t            }\n\t            src.advance(m ? m[0].length || 1 : 1);\n\t          }\n\t  } while (src.valueOf());\n\t\n\t  return root;\n\t}\n\t\n\tmodule.exports = {\n\t  singletons: singletons,\n\t  parseHtml: parseHtml,\n\t  parseHtmlAttr: parseHtmlAttr,\n\t  testCloseTag: testCloseTag,\n\t  testOpenTagBlock: testOpenTagBlock,\n\t  testOpenTag: testOpenTag,\n\t  testComment: testComment\n\t};\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/*\n\t** Regular Expression helper methods\n\t**\n\t** This provides the `re` object, which contains several helper\n\t** methods for working with big regular expressions (soup).\n\t**\n\t*/\n\t\n\tvar _cache = {};\n\t\n\tvar re = module.exports = {\n\t\n\t  pattern: {\n\t    'punct': '[!-/:-@\\\\[\\\\\\\\\\\\]-`{-~]',\n\t    'space': '\\\\s'\n\t  },\n\t\n\t  escape: function escape(src) {\n\t    return src.replace(/[\\-\\[\\]\\{\\}\\(\\)\\*\\+\\?\\.,\\\\\\^\\$\\|#\\s]/g, '\\\\$&');\n\t  },\n\t\n\t  collapse: function collapse(src) {\n\t    return src.replace(/(?:#.*?(?:\\n|$))/g, '').replace(/\\s+/g, '');\n\t  },\n\t\n\t  expandPatterns: function expandPatterns(src) {\n\t    // TODO: provide escape for patterns: \\[:pattern:] ?\n\t    return src.replace(/\\[:\\s*(\\w+)\\s*:\\]/g, function (m, k) {\n\t      var ex = re.pattern[k];\n\t      if (ex) {\n\t        return re.expandPatterns(ex);\n\t      } else {\n\t        throw new Error('Pattern ' + m + ' not found in ' + src);\n\t      }\n\t    });\n\t  },\n\t\n\t  isRegExp: function isRegExp(r) {\n\t    return Object.prototype.toString.call(r) === '[object RegExp]';\n\t  },\n\t\n\t  compile: function compile(src, flags) {\n\t    if (re.isRegExp(src)) {\n\t      if (arguments.length === 1) {\n\t        // no flags arg provided, use the RegExp one\n\t        flags = (src.global ? 'g' : '') + (src.ignoreCase ? 'i' : '') + (src.multiline ? 'm' : '');\n\t      }\n\t      src = src.source;\n\t    }\n\t    // don't do the same thing twice\n\t    var ckey = src + (flags || '');\n\t    if (ckey in _cache) {\n\t      return _cache[ckey];\n\t    }\n\t    // allow classes\n\t    var rx = re.expandPatterns(src);\n\t    // allow verbose expressions\n\t    if (flags && /x/.test(flags)) {\n\t      rx = re.collapse(rx);\n\t    }\n\t    // allow dotall expressions\n\t    if (flags && /s/.test(flags)) {\n\t      rx = rx.replace(/([^\\\\])\\./g, '$1[^\\\\0]');\n\t    }\n\t    // TODO: test if MSIE and add replace \\s with [\\s\\u00a0] if it is?\n\t    // clean flags and output new regexp\n\t    flags = (flags || '').replace(/[^gim]/g, '');\n\t    return _cache[ckey] = new RegExp(rx, flags);\n\t  }\n\t\n\t};\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = function ribbon(feed) {\n\t  var org = String(feed);\n\t  var slot = null;\n\t  var pos = 0;\n\t\n\t  return {\n\t\n\t    save: function save() {\n\t      slot = pos;\n\t    },\n\t\n\t    load: function load() {\n\t      pos = slot;\n\t      feed = org.slice(pos);\n\t      this.$ = feed;\n\t    },\n\t\n\t    advance: function advance(n) {\n\t      pos += typeof n === 'string' ? n.length : n;\n\t      feed = org.slice(pos);\n\t      this.$ = feed;\n\t      return feed;\n\t    },\n\t\n\t    lookbehind: function lookbehind(nchars) {\n\t      nchars = nchars == null ? 1 : nchars;\n\t      return org.slice(pos - nchars, pos);\n\t    },\n\t\n\t    startsWith: function startsWith(s) {\n\t      return feed.substring(0, s.length) === s;\n\t    },\n\t\n\t    valueOf: function valueOf() {\n\t      this.$ = feed;\n\t      return feed;\n\t    },\n\t\n\t    toString: function toString() {\n\t      this.$ = feed;\n\t      return feed;\n\t    }\n\t\n\t  };\n\t};\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/*\n\t** textile flow content parser\n\t*/\n\tvar builder = __webpack_require__(7);\n\tvar ribbon = __webpack_require__(5);\n\tvar re = __webpack_require__(4);\n\tvar fixLinks = __webpack_require__(8);\n\t\n\tvar _require = __webpack_require__(3);\n\t\n\tvar parseHtml = _require.parseHtml;\n\tvar parseHtmlAttr = _require.parseHtmlAttr;\n\tvar singletons = _require.singletons;\n\tvar testComment = _require.testComment;\n\tvar testOpenTagBlock = _require.testOpenTagBlock;\n\t\n\tvar _require2 = __webpack_require__(9);\n\t\n\tvar parsePhrase = _require2.parsePhrase;\n\t\n\tvar _require3 = __webpack_require__(10);\n\t\n\tvar copyAttr = _require3.copyAttr;\n\tvar parseAttr = _require3.parseAttr;\n\t\n\tvar _require4 = __webpack_require__(13);\n\t\n\tvar testList = _require4.testList;\n\tvar parseList = _require4.parseList;\n\t\n\tvar _require5 = __webpack_require__(14);\n\t\n\tvar testDefList = _require5.testDefList;\n\tvar parseDefList = _require5.parseDefList;\n\t\n\tvar _require6 = __webpack_require__(15);\n\t\n\tvar testTable = _require6.testTable;\n\tvar parseTable = _require6.parseTable;\n\t\n\tvar _require7 = __webpack_require__(12);\n\t\n\tvar txblocks = _require7.txblocks;\n\tvar txlisthd = _require7.txlisthd;\n\tvar txattr = _require7.txattr;\n\t\n\tre.pattern.txblocks = txblocks;\n\tre.pattern.txlisthd = txlisthd;\n\tre.pattern.txattr = txattr;\n\t\n\t// HTML tags allowed in the document (root) level that trigger HTML parsing\n\tvar allowedBlocktags = {\n\t  'p': 0,\n\t  'hr': 0,\n\t  'ul': 1,\n\t  'ol': 0,\n\t  'li': 0,\n\t  'div': 1,\n\t  'pre': 0,\n\t  'object': 1,\n\t  'script': 0,\n\t  'noscript': 0,\n\t  'blockquote': 1,\n\t  'notextile': 1\n\t};\n\t\n\tvar reBlock = re.compile(/^([:txblocks:])/);\n\t// const reBlockSE = re.compile( /^[:txblocks:]$/ );\n\tvar reBlockNormal = re.compile(/^(.*?)($|\\r?\\n(?=[:txlisthd:])|\\r?\\n(?:\\s*\\n|$)+)/, 's');\n\tvar reBlockExtended = re.compile(/^(.*?)($|\\r?\\n(?=[:txlisthd:])|\\r?\\n+(?=[:txblocks:][:txattr:]\\.))/, 's');\n\tvar reRuler = /^(\\-\\-\\-+|\\*\\*\\*+|___+)(\\r?\\n\\s+|$)/;\n\tvar reLinkRef = re.compile(/^\\[([^\\]]+)\\]((?:https?:\\/\\/|\\/)\\S+)(?:\\s*\\n|$)/);\n\tvar reFootnoteDef = /^fn\\d+$/;\n\t\n\tfunction paragraph(s, tag, pba, linebreak, options) {\n\t  tag = tag || 'p';\n\t  var out = [];\n\t  s.split(/(?:\\r?\\n){2,}/).forEach(function (bit, i) {\n\t    if (tag === 'p' && /^\\s/.test(bit)) {\n\t      // no-paragraphs\n\t      // WTF?: Why does Textile not allow linebreaks in spaced lines\n\t      bit = bit.replace(/\\r?\\n[\\t ]/g, ' ').trim();\n\t      out = out.concat(parsePhrase(bit, options));\n\t    } else {\n\t      if (linebreak && i) {\n\t        out.push(linebreak);\n\t      }\n\t      out.push(pba ? [tag, pba].concat(parsePhrase(bit, options)) : [tag].concat(parsePhrase(bit, options)));\n\t    }\n\t  });\n\t  return out;\n\t};\n\t\n\tfunction parseFlow(src, options) {\n\t  var list = builder();\n\t\n\t  var linkRefs = void 0;\n\t  var m = void 0;\n\t\n\t  src = ribbon(src.replace(/^( *\\r?\\n)+/, ''));\n\t\n\t  // loop\n\t  while (src.valueOf()) {\n\t    src.save();\n\t\n\t    // link_ref -- this goes first because it shouldn't trigger a linebreak\n\t    if (m = reLinkRef.exec(src)) {\n\t      if (!linkRefs) {\n\t        linkRefs = {};\n\t      }\n\t      src.advance(m[0]);\n\t      linkRefs[m[1]] = m[2];\n\t      continue;\n\t    }\n\t\n\t    // add linebreak\n\t    list.linebreak();\n\t\n\t    // named block\n\t    if (m = reBlock.exec(src)) {\n\t      src.advance(m[0]);\n\t      var blockType = m[0];\n\t      var pba = parseAttr(src, blockType);\n\t\n\t      if (pba) {\n\t        src.advance(pba[0]);\n\t        pba = pba[1];\n\t      }\n\t      if (m = /^\\.(\\.?)(?:\\s|(?=:))/.exec(src)) {\n\t        // FIXME: this whole copyAttr seems rather strange?\n\t        // slurp rest of block\n\t        var extended = !!m[1];\n\t        var reBlockGlob = extended ? reBlockExtended : reBlockNormal;\n\t        m = reBlockGlob.exec(src.advance(m[0]));\n\t        src.advance(m[0]);\n\t        // bq | bc | notextile | pre | h# | fn# | p | ###\n\t        if (blockType === 'bq') {\n\t          var inner = m[1];\n\t          if (m = /^:(\\S+)\\s+/.exec(inner)) {\n\t            if (!pba) {\n\t              pba = {};\n\t            }\n\t            pba.cite = m[1];\n\t            inner = inner.slice(m[0].length);\n\t          }\n\t          // RedCloth adds all attr to both: this is bad because it produces duplicate IDs\n\t          var par = paragraph(inner, 'p', copyAttr(pba, { 'cite': 1, 'id': 1 }), '\\n', options);\n\t          list.add(['blockquote', pba, '\\n'].concat(par).concat(['\\n']));\n\t          // FIXME: looks like .linebreak can work here\n\t        } else if (blockType === 'bc') {\n\t          var subPba = pba ? copyAttr(pba, { 'id': 1 }) : null;\n\t          list.add(['pre', pba, subPba ? ['code', subPba, m[1]] : ['code', m[1]]]);\n\t        } else if (blockType === 'notextile') {\n\t          list.merge(parseHtml(m[1]));\n\t        } else if (blockType === '###') {\n\t          // ignore the insides\n\t        } else if (blockType === 'pre') {\n\t          // I disagree with RedCloth, but agree with PHP here:\n\t          // \"pre(foo#bar).. line1\\n\\nline2\" prevents multiline preformat blocks\n\t          // ...which seems like the whole point of having an extended pre block?\n\t          list.add(['pre', pba, m[1]]);\n\t        } else if (reFootnoteDef.test(blockType)) {\n\t          // footnote\n\t          // Need to be careful: RedCloth fails \"fn1(foo#m). footnote\" -- it confuses the ID\n\t          var fnid = blockType.replace(/\\D+/g, '');\n\t          if (!pba) {\n\t            pba = {};\n\t          }\n\t          pba.class = (pba['class'] ? pba['class'] + ' ' : '') + 'footnote';\n\t          pba.id = 'fn' + fnid;\n\t          list.add(['p', pba, ['a', { 'href': '#fnr' + fnid }, ['sup', fnid]], ' '].concat(parsePhrase(m[1], options)));\n\t        } else {\n\t          // heading | paragraph\n\t          list.merge(paragraph(m[1], blockType, pba, '\\n', options));\n\t        }\n\t        continue;\n\t      } else {\n\t        src.load();\n\t      }\n\t    }\n\t\n\t    // HTML comment\n\t    if (m = testComment(src)) {\n\t      src.advance(m[0] + (/(?:\\s*\\n+)+/.exec(src) || [])[0]);\n\t      list.add(['!', m[1]]);\n\t      continue;\n\t    }\n\t\n\t    // block HTML\n\t    if (m = testOpenTagBlock(src)) {\n\t      var tag = m[1];\n\t      var single = m[3] || tag in singletons;\n\t      var tail = m[4];\n\t\n\t      // Unsurprisingly, all Textile implementations I have tested have trouble parsing simple HTML:\n\t      //\n\t      //    \"<div>a\\n<div>b\\n</div>c\\n</div>d\"\n\t      //\n\t      // I simply match them here as there is no way anyone is using nested HTML today, or if they\n\t      // are, then this will at least output less broken HTML as redundant tags will get quoted.\n\t\n\t      // Is block tag? ...\n\t      if (tag in allowedBlocktags) {\n\t        src.advance(m[0]);\n\t\n\t        var element = [tag];\n\t\n\t        if (m[2]) {\n\t          element.push(parseHtmlAttr(m[2]));\n\t        }\n\t\n\t        // single tag\n\t        if (single) {\n\t          // let us add the element and continue our quest...\n\t          list.add(element);\n\t          continue;\n\t        }\n\t        // block\n\t        else {\n\t            // gulp up the rest of this block...\n\t            var reEndTag = re.compile('^(.*?)(\\\\s*)(</' + tag + '\\\\s*>)(\\\\s*)', 's');\n\t            if (m = reEndTag.exec(src)) {\n\t              src.advance(m[0]);\n\t              if (tag === 'pre') {\n\t                element.push(tail);\n\t                element = element.concat(parseHtml(m[1].replace(/(\\r?\\n)+$/, ''), { 'code': 1 }));\n\t                if (m[2]) {\n\t                  element.push(m[2]);\n\t                }\n\t                list.add(element);\n\t              } else if (tag === 'notextile') {\n\t                element = parseHtml(m[1].trim());\n\t                list.merge(element);\n\t              } else if (tag === 'script' || tag === 'noscript') {\n\t                element.push(tail + m[1]);\n\t                list.add(element);\n\t              } else {\n\t                // These strange (and unnecessary) linebreak tests are here to get the\n\t                // tests working perfectly. In reality, this doesn't matter one bit.\n\t                if (/\\n/.test(tail)) {\n\t                  element.push('\\n');\n\t                }\n\t                if (/\\n/.test(m[1])) {\n\t                  element = element.concat(parseFlow(m[1], options));\n\t                } else {\n\t                  element = element.concat(parsePhrase(m[1].replace(/^ +/, ''), options));\n\t                }\n\t                if (/\\n/.test(m[2])) {\n\t                  element.push('\\n');\n\t                }\n\t\n\t                list.add(element);\n\t              }\n\t              continue;\n\t            }\n\t          }\n\t      }\n\t      src.load();\n\t    }\n\t\n\t    // ruler\n\t    if (m = reRuler.exec(src)) {\n\t      src.advance(m[0]);\n\t      list.add(['hr']);\n\t      continue;\n\t    }\n\t\n\t    // list\n\t    if (m = testList(src)) {\n\t      src.advance(m[0]);\n\t      list.add(parseList(m[0], options));\n\t      continue;\n\t    }\n\t\n\t    // definition list\n\t    if (m = testDefList(src)) {\n\t      src.advance(m[0]);\n\t      list.add(parseDefList(m[0], options));\n\t      continue;\n\t    }\n\t\n\t    // table\n\t    if (m = testTable(src)) {\n\t      src.advance(m[0]);\n\t      list.add(parseTable(m[1], options));\n\t      continue;\n\t    }\n\t\n\t    // paragraph\n\t    m = reBlockNormal.exec(src);\n\t    list.merge(paragraph(m[1], 'p', undefined, '\\n', options));\n\t    src.advance(m[0]);\n\t  }\n\t\n\t  return linkRefs ? fixLinks(list.get(), linkRefs) : list.get();\n\t}\n\t\n\texports.parseFlow = parseFlow;\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = function builder(initArr) {\n\t  var arr = Array.isArray(initArr) ? initArr : [];\n\t\n\t  return {\n\t    add: function add(node) {\n\t      if (typeof node === 'string' && typeof arr[arr.length - 1] === 'string') {\n\t        // join if possible\n\t        arr[arr.length - 1] += node;\n\t      } else if (Array.isArray(node)) {\n\t        arr.push(node.filter(function (s) {\n\t          return s !== undefined;\n\t        }));\n\t      } else if (node) {\n\t        arr.push(node);\n\t      }\n\t      return this;\n\t    },\n\t\n\t    merge: function merge(arr) {\n\t      for (var i = 0, l = arr.length; i < l; i++) {\n\t        this.add(arr[i]);\n\t      }\n\t      return this;\n\t    },\n\t\n\t    linebreak: function linebreak() {\n\t      if (arr.length) {\n\t        this.add('\\n');\n\t      }\n\t    },\n\t\n\t    get: function get() {\n\t      return arr;\n\t    }\n\t  };\n\t};\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\t// recurse the tree and swap out any \"href\" attributes\n\t// this uses the context as the replace dictionary so it can be fed to Array#map\n\tmodule.exports = function fixLinks(ml, dict) {\n\t  if (Array.isArray(ml)) {\n\t    if (ml[0] === 'a') {\n\t      // found a link\n\t      var attr = ml[1];\n\t      if ((typeof attr === 'undefined' ? 'undefined' : _typeof(attr)) === 'object' && 'href' in attr && attr.href in dict) {\n\t        attr.href = dict[attr.href];\n\t      }\n\t    }\n\t    for (var i = 0, l = ml.length; i < l; i++) {\n\t      if (Array.isArray(ml[i])) {\n\t        fixLinks(ml[i], dict);\n\t      }\n\t    }\n\t  }\n\t  return ml;\n\t};\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/* textile inline parser */\n\t\n\tvar ribbon = __webpack_require__(5);\n\tvar builder = __webpack_require__(7);\n\tvar re = __webpack_require__(4);\n\t\n\tvar _require = __webpack_require__(10);\n\t\n\tvar parseAttr = _require.parseAttr;\n\t\n\tvar _require2 = __webpack_require__(11);\n\t\n\tvar parseGlyph = _require2.parseGlyph;\n\t\n\tvar _require3 = __webpack_require__(3);\n\t\n\tvar parseHtmlAttr = _require3.parseHtmlAttr;\n\tvar singletons = _require3.singletons;\n\tvar testComment = _require3.testComment;\n\tvar testOpenTag = _require3.testOpenTag;\n\t\n\tvar _require4 = __webpack_require__(12);\n\t\n\tvar ucaps = _require4.ucaps;\n\tvar txattr = _require4.txattr;\n\tvar txcite = _require4.txcite;\n\t\n\tre.pattern.txattr = txattr;\n\tre.pattern.txcite = txcite;\n\tre.pattern.ucaps = ucaps;\n\t\n\tvar phraseConvert = {\n\t  '*': 'strong',\n\t  '**': 'b',\n\t  '??': 'cite',\n\t  '_': 'em',\n\t  '__': 'i',\n\t  '-': 'del',\n\t  '%': 'span',\n\t  '+': 'ins',\n\t  '~': 'sub',\n\t  '^': 'sup',\n\t  '@': 'code'\n\t};\n\t\n\tvar rePhrase = /^([\\[\\{]?)(__?|\\*\\*?|\\?\\?|[\\-\\+\\^~@%])/;\n\tvar reImage = re.compile(/^!(?!\\s)([:txattr:](?:\\.[^\\n\\S]|\\.(?:[^\\.\\/]))?)([^!\\s]+?) ?(?:\\(((?:[^\\(\\)]|\\([^\\(\\)]+\\))+)\\))?!(?::([^\\s]+?(?=[!-\\.:-@\\[\\\\\\]-`{-~](?:$|\\s)|\\s|$)))?/);\n\tvar reImageFenced = re.compile(/^\\[!(?!\\s)([:txattr:](?:\\.[^\\n\\S]|\\.(?:[^\\.\\/]))?)([^!\\s]+?) ?(?:\\(((?:[^\\(\\)]|\\([^\\(\\)]+\\))+)\\))?!(?::([^\\s]+?(?=[!-\\.:-@\\[\\\\\\]-`{-~](?:$|\\s)|\\s|$)))?\\]/);\n\t// NB: there is an exception in here to prevent matching \"TM)\"\n\tvar reCaps = re.compile(/^((?!TM\\)|tm\\))[[:ucaps:]](?:[[:ucaps:]\\d]{1,}(?=\\()|[[:ucaps:]\\d]{2,}))(?:\\((.*?)\\))?(?=\\W|$)/);\n\tvar reLink = re.compile(/^\"(?!\\s)((?:[^\\n\"]|\"(?![\\s:])[^\\n\"]+\"(?!:))+)\"[:txcite:]/);\n\tvar reLinkFenced = /^\\[\"([^\\n]+?)\":((?:\\[[a-z0-9]*\\]|[^\\]])+)\\]/;\n\tvar reLinkTitle = /\\s*\\(((?:\\([^\\(\\)]*\\)|[^\\(\\)])+)\\)$/;\n\tvar reFootnote = /^\\[(\\d+)(!?)\\]/;\n\t\n\tfunction parsePhrase(src, options) {\n\t  src = ribbon(src);\n\t\n\t  var list = builder();\n\t  var m = void 0;\n\t  var pba = void 0;\n\t\n\t  // loop\n\t  do {\n\t    src.save();\n\t\n\t    // linebreak -- having this first keeps it from messing to much with other phrases\n\t    if (src.startsWith('\\r\\n')) {\n\t      src.advance(1); // skip cartridge returns\n\t    }\n\t    if (src.startsWith('\\n')) {\n\t      src.advance(1);\n\t      if (options.breaks) {\n\t        list.add(['br']);\n\t      }\n\t      list.add('\\n');\n\t      continue;\n\t    }\n\t\n\t    // inline notextile\n\t    if (m = /^==(.*?)==/.exec(src)) {\n\t      src.advance(m[0]);\n\t      list.add(m[1]);\n\t      continue;\n\t    }\n\t\n\t    // lookbehind => /([\\s>.,\"'?!;:])$/\n\t    var behind = src.lookbehind(1);\n\t    var boundary = !behind || /^[\\s>.,\"'?!;:()]$/.test(behind);\n\t    // FIXME: need to test right boundary for phrases as well\n\t    if ((m = rePhrase.exec(src)) && (boundary || m[1])) {\n\t      src.advance(m[0]);\n\t      var tok = m[2];\n\t      var fence = m[1];\n\t      var phraseType = phraseConvert[tok];\n\t      var code = phraseType === 'code';\n\t\n\t      if (pba = !code && parseAttr(src, phraseType, tok)) {\n\t        src.advance(pba[0]);\n\t        pba = pba[1];\n\t      }\n\t      // FIXME: if we can't match the fence on the end, we should output fence-prefix as normal text\n\t      // seek end\n\t      var mMid = void 0;\n\t      var mEnd = void 0;\n\t      if (fence === '[') {\n\t        mMid = '^(.*?)';\n\t        mEnd = '(?:])';\n\t      } else if (fence === '{') {\n\t        mMid = '^(.*?)';\n\t        mEnd = '(?:})';\n\t      } else {\n\t        var t1 = re.escape(tok.charAt(0));\n\t        mMid = code ? '^(\\\\S+|\\\\S+.*?\\\\S)' : '^([^\\\\s' + t1 + ']+|[^\\\\s' + t1 + '].*?\\\\S(' + t1 + '*))';\n\t        mEnd = '(?=$|[\\\\s.,\"\\'!?;:()«»„“”‚‘’])';\n\t      }\n\t      var rx = re.compile(mMid + '(' + re.escape(tok) + ')' + mEnd);\n\t      if ((m = rx.exec(src)) && m[1]) {\n\t        src.advance(m[0]);\n\t        if (code) {\n\t          list.add([phraseType, m[1]]);\n\t        } else {\n\t          list.add([phraseType, pba].concat(parsePhrase(m[1], options)));\n\t        }\n\t        continue;\n\t      }\n\t      // else\n\t      src.load();\n\t    }\n\t\n\t    // image\n\t    if ((m = reImage.exec(src)) || (m = reImageFenced.exec(src))) {\n\t      src.advance(m[0]);\n\t\n\t      pba = m[1] && parseAttr(m[1], 'img');\n\t      var attr = pba ? pba[1] : { 'src': '' };\n\t      var img = ['img', attr];\n\t      attr.src = m[2];\n\t      attr.alt = m[3] ? attr.title = m[3] : '';\n\t\n\t      if (m[4]) {\n\t        // +cite causes image to be wraped with a link (or link_ref)?\n\t        // TODO: support link_ref for image cite\n\t        img = ['a', { 'href': m[4] }, img];\n\t      }\n\t      list.add(img);\n\t      continue;\n\t    }\n\t\n\t    // html comment\n\t    if (m = testComment(src)) {\n\t      src.advance(m[0]);\n\t      list.add(['!', m[1]]);\n\t      continue;\n\t    }\n\t    // html tag\n\t    // TODO: this seems to have a lot of overlap with block tags... DRY?\n\t    if (m = testOpenTag(src)) {\n\t      src.advance(m[0]);\n\t      var tag = m[1];\n\t      var single = m[3] || m[1] in singletons;\n\t      var element = [tag];\n\t      var tail = m[4];\n\t      if (m[2]) {\n\t        element.push(parseHtmlAttr(m[2]));\n\t      }\n\t      if (single) {\n\t        // single tag\n\t        list.add(element).add(tail);\n\t        continue;\n\t      } else {\n\t        // need terminator\n\t        // gulp up the rest of this block...\n\t        var reEndTag = re.compile('^(.*?)(</' + tag + '\\\\s*>)', 's');\n\t        if (m = reEndTag.exec(src)) {\n\t          src.advance(m[0]);\n\t          if (tag === 'code') {\n\t            element.push(tail, m[1]);\n\t          } else if (tag === 'notextile') {\n\t            list.merge(parsePhrase(m[1], options));\n\t            continue;\n\t          } else {\n\t            element = element.concat(parsePhrase(m[1], options));\n\t          }\n\t          list.add(element);\n\t          continue;\n\t        }\n\t        // end tag is missing, treat tag as normal text...\n\t      }\n\t      src.load();\n\t    }\n\t\n\t    // footnote\n\t    if ((m = reFootnote.exec(src)) && /\\S/.test(behind)) {\n\t      src.advance(m[0]);\n\t      list.add(['sup', { 'class': 'footnote', 'id': 'fnr' + m[1] }, m[2] === '!' ? m[1] // \"!\" suppresses the link\n\t      : ['a', { href: '#fn' + m[1] }, m[1]]]);\n\t      continue;\n\t    }\n\t\n\t    // caps / abbr\n\t    if (m = reCaps.exec(src)) {\n\t      src.advance(m[0]);\n\t      var caps = ['span', { 'class': 'caps' }, m[1]];\n\t      if (m[2]) {\n\t        // FIXME: use <abbr>, not acronym!\n\t        caps = ['acronym', { 'title': m[2] }, caps];\n\t      }\n\t      list.add(caps);\n\t      continue;\n\t    }\n\t\n\t    // links\n\t    if (boundary && (m = reLink.exec(src)) || (m = reLinkFenced.exec(src))) {\n\t      src.advance(m[0]);\n\t      var title = m[1].match(reLinkTitle);\n\t      var inner = title ? m[1].slice(0, m[1].length - title[0].length) : m[1];\n\t      if (pba = parseAttr(inner, 'a')) {\n\t        inner = inner.slice(pba[0]);\n\t        pba = pba[1];\n\t      } else {\n\t        pba = {};\n\t      }\n\t      if (title && !inner) {\n\t        inner = title[0];\n\t        title = '';\n\t      }\n\t      pba.href = m[2];\n\t      if (title) {\n\t        pba.title = title[1];\n\t      }\n\t      list.add(['a', pba].concat(parsePhrase(inner.replace(/^(\\.?\\s*)/, ''), options)));\n\t      continue;\n\t    }\n\t\n\t    // no match, move by all \"uninteresting\" chars\n\t    m = /([a-zA-Z0-9,.':]+|[ \\f\\r\\t\\v\\xA0\\u2028\\u2029]+|[^\\0])/.exec(src);\n\t    if (m) {\n\t      list.add(m[0]);\n\t    }\n\t    src.advance(m ? m[0].length || 1 : 1);\n\t  } while (src.valueOf());\n\t\n\t  return list.get().map(parseGlyph);\n\t}\n\t\n\texports.parsePhrase = parsePhrase;\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar reClassid = /^\\(([^\\(\\)\\n]+)\\)/;\n\tvar rePaddingL = /^(\\(+)/;\n\tvar rePaddingR = /^(\\)+)/;\n\tvar reAlignBlock = /^(<>|<|>|=)/;\n\tvar reAlignImg = /^(<|>|=)/;\n\tvar reVAlign = /^(~|\\^|\\-)/;\n\tvar reColSpan = /^\\\\(\\d+)/;\n\tvar reRowSpan = /^\\/(\\d+)/;\n\tvar reStyles = /^\\{([^\\}]*)\\}/;\n\tvar reCSS = /^\\s*([^:\\s]+)\\s*:\\s*(.+)\\s*$/;\n\tvar reLang = /^\\[([^\\[\\]\\n]+)\\]/;\n\t\n\tvar pbaAlignLookup = {\n\t  '<': 'left',\n\t  '=': 'center',\n\t  '>': 'right',\n\t  '<>': 'justify'\n\t};\n\t\n\tvar pbaVAlignLookup = {\n\t  '~': 'bottom',\n\t  '^': 'top',\n\t  '-': 'middle'\n\t};\n\t\n\tfunction copyAttr(s, blacklist) {\n\t  if (!s) {\n\t    return undefined;\n\t  }\n\t  var d = {};\n\t  for (var k in s) {\n\t    if (k in s && (!blacklist || !(k in blacklist))) {\n\t      d[k] = s[k];\n\t    }\n\t  }\n\t  return d;\n\t}\n\t\n\tfunction testBlock(name) {\n\t  // \"in\" test would be better but what about fn#.?\n\t  return (/^(?:table|t[dh]|t(?:foot|head|body)|b[qc]|div|notextile|pre|h[1-6]|fn\\\\d+|p|###)$/.test(name)\n\t  );\n\t}\n\t\n\t/*\n\t  The attr bit causes massive problems for span elements when parentheses are used.\n\t  Parentheses are a total mess and, unsurprisingly, cause trip-ups:\n\t\n\t   RC: `_{display:block}(span) span (span)_` -> `<em style=\"display:block;\" class=\"span\">(span) span (span)</em>`\n\t   PHP: `_{display:block}(span) span (span)_` -> `<em style=\"display:block;\">(span) span (span)</em>`\n\t\n\t  PHP and RC seem to mostly solve this by not parsing a final attr parens on spans if the\n\t  following character is a non-space. I've duplicated that: Class/ID is not matched on spans\n\t  if it is followed by `endToken` or <space>.\n\t\n\t  Lang is not matched here if it is followed by the end token. Theoretically I could limit the lang\n\t  attribute to /^\\[[a-z]{2+}(\\-[a-zA-Z0-9]+)*\\]/ because Textile is layered on top of HTML which\n\t  only accepts valid BCP 47 language tags, but who knows what atrocities are being preformed\n\t  out there in the real world. So this attempts to emulate the other libraries.\n\t*/\n\tfunction parseAttr(input, element, endToken) {\n\t  input = String(input);\n\t  if (!input || element === 'notextile') {\n\t    return undefined;\n\t  }\n\t\n\t  var m = void 0;\n\t  var st = {};\n\t  var o = { 'style': st };\n\t  var remaining = input;\n\t\n\t  var isBlock = testBlock(element);\n\t  var isImg = element === 'img';\n\t  var isList = element === 'li';\n\t  var isPhrase = !isBlock && !isImg && element !== 'a';\n\t  var reAlign = isImg ? reAlignImg : reAlignBlock;\n\t\n\t  do {\n\t    if (m = reStyles.exec(remaining)) {\n\t      m[1].split(';').forEach(function (p) {\n\t        var d = p.match(reCSS);\n\t        if (d) {\n\t          st[d[1]] = d[2];\n\t        }\n\t      });\n\t      remaining = remaining.slice(m[0].length);\n\t      continue;\n\t    }\n\t\n\t    if (m = reLang.exec(remaining)) {\n\t      var rm = remaining.slice(m[0].length);\n\t      if (!rm && isPhrase || endToken && endToken === rm.slice(0, endToken.length)) {\n\t        m = null;\n\t      } else {\n\t        o['lang'] = m[1];\n\t        remaining = remaining.slice(m[0].length);\n\t      }\n\t      continue;\n\t    }\n\t\n\t    if (m = reClassid.exec(remaining)) {\n\t      var _rm = remaining.slice(m[0].length);\n\t      if (!_rm && isPhrase || endToken && (_rm[0] === ' ' || endToken === _rm.slice(0, endToken.length))) {\n\t        m = null;\n\t      } else {\n\t        var bits = m[1].split('#');\n\t        if (bits[0]) {\n\t          o.class = bits[0];\n\t        }\n\t        if (bits[1]) {\n\t          o.id = bits[1];\n\t        }\n\t        remaining = _rm;\n\t      }\n\t      continue;\n\t    }\n\t\n\t    if (isBlock || isList) {\n\t      if (m = rePaddingL.exec(remaining)) {\n\t        st['padding-left'] = m[1].length + 'em';\n\t        remaining = remaining.slice(m[0].length);\n\t        continue;\n\t      }\n\t      if (m = rePaddingR.exec(remaining)) {\n\t        st['padding-right'] = m[1].length + 'em';\n\t        remaining = remaining.slice(m[0].length);\n\t        continue;\n\t      }\n\t    }\n\t\n\t    // only for blocks:\n\t    if (isImg || isBlock || isList) {\n\t      if (m = reAlign.exec(remaining)) {\n\t        var align = pbaAlignLookup[m[1]];\n\t        if (isImg) {\n\t          o['align'] = align;\n\t        } else {\n\t          st['text-align'] = align;\n\t        }\n\t        remaining = remaining.slice(m[0].length);\n\t        continue;\n\t      }\n\t    }\n\t\n\t    // only for table cells\n\t    if (element === 'td' || element === 'tr') {\n\t      if (m = reVAlign.exec(remaining)) {\n\t        st['vertical-align'] = pbaVAlignLookup[m[1]];\n\t        remaining = remaining.slice(m[0].length);\n\t        continue;\n\t      }\n\t    }\n\t    if (element === 'td') {\n\t      if (m = reColSpan.exec(remaining)) {\n\t        o['colspan'] = m[1];\n\t        remaining = remaining.slice(m[0].length);\n\t        continue;\n\t      }\n\t      if (m = reRowSpan.exec(remaining)) {\n\t        o['rowspan'] = m[1];\n\t        remaining = remaining.slice(m[0].length);\n\t        continue;\n\t      }\n\t    }\n\t  } while (m);\n\t\n\t  // collapse styles\n\t  var s = [];\n\t  for (var v in st) {\n\t    s.push(v + ':' + st[v]);\n\t  }\n\t  if (s.length) {\n\t    o.style = s.join(';');\n\t  } else {\n\t    delete o.style;\n\t  }\n\t\n\t  return remaining === input ? undefined : [input.length - remaining.length, o];\n\t}\n\t\n\tmodule.exports = {\n\t  copyAttr: copyAttr,\n\t  parseAttr: parseAttr\n\t};\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/* textile glyph parser */\n\t\n\tvar re = __webpack_require__(4);\n\t\n\tvar reApostrophe = /(\\w)'(\\w)/g;\n\tvar reArrow = /([^\\-]|^)->/;\n\tvar reClosingDQuote = re.compile(/([^\\s\\[\\(])\"(?=$|\\s|[:punct:])/g);\n\tvar reClosingSQuote = re.compile(/([^\\s\\[\\(])'(?=$|\\s|[:punct:])/g);\n\tvar reCopyright = /(\\b ?|\\s|^)(?:\\(C\\)|\\[C\\])/gi;\n\tvar reDimsign = /([\\d\\.,]+['\"]? ?)x( ?)(?=[\\d\\.,]['\"]?)/g;\n\tvar reDoublePrime = re.compile(/(\\d*[\\.,]?\\d+)\"(?=\\s|$|[:punct:])/g);\n\tvar reEllipsis = /([^.]?)\\.{3}/g;\n\tvar reEmdash = /(^|[\\s\\w])--([\\s\\w]|$)/g;\n\tvar reEndash = / - /g;\n\tvar reOpenDQuote = /\"/g;\n\tvar reOpenSQuote = /'/g;\n\tvar reRegistered = /(\\b ?|\\s|^)(?:\\(R\\)|\\[R\\])/gi;\n\tvar reSinglePrime = re.compile(/(\\d*[\\.,]?\\d+)'(?=\\s|$|[:punct:])/g);\n\tvar reTrademark = /(\\b ?|\\s|^)(?:\\((?:TM|tm)\\)|\\[(?:TM|tm)\\])/g;\n\t\n\texports.parseGlyph = function parseGlyph(src) {\n\t  if (typeof src !== 'string') {\n\t    return src;\n\t  }\n\t  // NB: order is important here ...\n\t  return src.replace(reArrow, '$1&#8594;').replace(reDimsign, '$1&#215;$2').replace(reEllipsis, '$1&#8230;').replace(reEmdash, '$1&#8212;$2').replace(reEndash, ' &#8211; ').replace(reTrademark, '$1&#8482;').replace(reRegistered, '$1&#174;').replace(reCopyright, '$1&#169;')\n\t  // double quotes\n\t  .replace(reDoublePrime, '$1&#8243;').replace(reClosingDQuote, '$1&#8221;').replace(reOpenDQuote, '&#8220;')\n\t  // single quotes\n\t  .replace(reSinglePrime, '$1&#8242;').replace(reApostrophe, '$1&#8217;$2').replace(reClosingSQuote, '$1&#8217;').replace(reOpenSQuote, '&#8216;')\n\t  // fractions and degrees\n\t  .replace(/[\\(\\[]1\\/4[\\]\\)]/, '&#188;').replace(/[\\(\\[]1\\/2[\\]\\)]/, '&#189;').replace(/[\\(\\[]3\\/4[\\]\\)]/, '&#190;').replace(/[\\(\\[]o[\\]\\)]/, '&#176;').replace(/[\\(\\[]\\+\\/\\-[\\]\\)]/, '&#177;');\n\t};\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/* eslint camelcase: 0 */\n\t\n\texports.txblocks = '(?:b[qc]|div|notextile|pre|h[1-6]|fn\\\\d+|p|###)';\n\t\n\texports.ucaps = 'A-Z' +\n\t// Latin extended À-Þ\n\t'À-ÖØ-Þ' +\n\t// Latin caps with embelishments and ligatures...\n\t'ĀĂĄĆĈĊČĎĐĒĔĖĘĚĜĞĠĢĤĦĨĪĬĮİĲĴĶĹĻĽĿ' + 'ŁŃŅŇŊŌŎŐŒŔŖŘŚŜŞŠŢŤŦŨŪŬŮŰŲŴŶŸŹŻŽ' + 'ƁƂƄƆƇƉ-ƋƎ-ƑƓƔƖ-ƘƜƝƟƠƢƤƦƧƩƬƮƯƱ-ƳƵƷƸƼ' + 'ǄǇǊǍǏǑǓǕǗǙǛǞǠǢǤǦǨǪǬǮǱǴǶ-ǸǺǼǾ' + 'ȀȂȄȆȈȊȌȎȐȒȔȖȘȚȜȞȠȢȤȦȨȪȬȮȰȲȺȻȽȾ' + 'ɁɃ-ɆɈɊɌɎ' + 'ḀḂḄḆḈḊḌḎḐḒḔḖḘḚḜḞḠḢḤḦḨḪḬḮḰḲḴḶḸḺḼḾṀ' + 'ṂṄṆṈṊṌṎṐṒṔṖṘṚṜṞṠṢṤṦṨṪṬṮṰṲṴṶṸṺṼṾ' + 'ẀẂẄẆẈẊẌẎẐẒẔẞẠẢẤẦẨẪẬẮẰẲẴẶẸẺẼẾ' + 'ỀỂỄỆỈỊỌỎỐỒỔỖỘỚỜỞỠỢỤỦỨỪỬỮỰỲỴỶỸỺỼỾ' + 'ⱠⱢ-ⱤⱧⱩⱫⱭ-ⱰⱲⱵⱾⱿ' + 'ꜢꜤꜦꜨꜪꜬꜮꜲꜴꜶꜸꜺꜼꜾ' + 'ꝀꝂꝄꝆꝈꝊꝌꝎꝐꝒꝔꝖꝘꝚꝜꝞꝠꝢꝤꝦꝨꝪꝬꝮꝹꝻꝽꝾ' + 'ꞀꞂꞄꞆꞋꞍꞐꞒꞠꞢꞤꞦꞨꞪ';\n\t\n\texports.txcite = ':((?:[^\\\\s()]|\\\\([^\\\\s()]+\\\\)|[()])+?)(?=[!-\\\\.:-@\\\\[\\\\\\\\\\\\]-`{-~]+(?:$|\\\\s)|$|\\\\s)';\n\t\n\tvar attr_class = exports.attr_class = '\\\\([^\\\\)]+\\\\)';\n\tvar attr_style = exports.attr_style = '\\\\{[^\\\\}]+\\\\}';\n\tvar attr_lang = exports.attr_lang = '\\\\[[^\\\\[\\\\]]+\\\\]';\n\tvar attr_align = exports.attr_align = '(?:<>|<|>|=)';\n\tvar attr_pad = exports.attr_pad = '[\\\\(\\\\)]+';\n\t\n\tvar txattr = exports.txattr = '(?:' + attr_class + '|' + attr_style + '|' + attr_lang + '|' + attr_align + '|' + attr_pad + ')*';\n\t\n\texports.txlisthd = '[\\\\t ]*[\\\\#\\\\*]*(\\\\*|\\\\#(?:_|\\\\d+)?)' + txattr + '(?: \\\\S|\\\\.\\\\s*(?=\\\\S|\\\\n))';\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/* textile list parser */\n\tvar ribbon = __webpack_require__(5);\n\tvar re = __webpack_require__(4);\n\tvar merge = __webpack_require__(1);\n\t\n\tvar _require = __webpack_require__(10);\n\t\n\tvar parseAttr = _require.parseAttr;\n\t\n\tvar _require2 = __webpack_require__(9);\n\t\n\tvar parsePhrase = _require2.parsePhrase;\n\t\n\tvar _require3 = __webpack_require__(12);\n\t\n\tvar txlisthd = _require3.txlisthd;\n\t\n\tre.pattern.txlisthd = txlisthd;\n\tvar reList = re.compile(/^((?:[:txlisthd:][^\\0]*?(?:\\r?\\n|$))+)(\\s*\\n|$)/, 's');\n\tvar reItem = re.compile(/^([#\\*]+)([^\\0]+?)(\\n(?=[:txlisthd:])|$)/, 's');\n\t\n\tfunction listPad(n) {\n\t  var s = '\\n';\n\t  while (n--) {\n\t    s += '\\t';\n\t  }\n\t  return s;\n\t}\n\t\n\tfunction testList(src) {\n\t  return reList.exec(src);\n\t}\n\t\n\tfunction parseList(src, options) {\n\t  src = ribbon(src.replace(/(^|\\r?\\n)[\\t ]+/, '$1'));\n\t\n\t  var stack = [];\n\t  var currIndex = {};\n\t  var lastIndex = options._lst || {};\n\t  var itemIndex = 0;\n\t  var listAttr = void 0;\n\t  var m = void 0;\n\t  var n = void 0;\n\t  var s = void 0;\n\t\n\t  while (m = reItem.exec(src)) {\n\t    var item = ['li'];\n\t    var destLevel = m[1].length;\n\t    var type = m[1].substr(-1) === '#' ? 'ol' : 'ul';\n\t    var newLi = null;\n\t    var lst = void 0;\n\t    var par = void 0;\n\t    var pba = void 0;\n\t    var r = void 0;\n\t\n\t    // list starts and continuations\n\t    if (n = /^(_|\\d+)/.exec(m[2])) {\n\t      itemIndex = isFinite(n[1]) ? parseInt(n[1], 10) : lastIndex[destLevel] || currIndex[destLevel] || 1;\n\t      m[2] = m[2].slice(n[1].length);\n\t    }\n\t\n\t    if (pba = parseAttr(m[2], 'li')) {\n\t      m[2] = m[2].slice(pba[0]);\n\t      pba = pba[1];\n\t    }\n\t\n\t    // list control\n\t    if (/^\\.\\s*$/.test(m[2])) {\n\t      listAttr = pba || {};\n\t      src.advance(m[0]);\n\t      continue;\n\t    }\n\t\n\t    // create nesting until we have correct level\n\t    while (stack.length < destLevel) {\n\t      // list always has an attribute object, this simplifies first-pba resolution\n\t      lst = [type, {}, listPad(stack.length + 1), newLi = ['li']];\n\t      par = stack[stack.length - 1];\n\t      if (par) {\n\t        par.li.push(listPad(stack.length));\n\t        par.li.push(lst);\n\t      }\n\t      stack.push({\n\t        ul: lst,\n\t        li: newLi,\n\t        // count attributes's found per list\n\t        att: 0\n\t      });\n\t      currIndex[stack.length] = 1;\n\t    }\n\t\n\t    // remove nesting until we have correct level\n\t    while (stack.length > destLevel) {\n\t      r = stack.pop();\n\t      r.ul.push(listPad(stack.length));\n\t      // lists have a predictable structure - move pba from listitem to list\n\t      if (r.att === 1 && !r.ul[3][1].substr) {\n\t        merge(r.ul[1], r.ul[3].splice(1, 1)[0]);\n\t      }\n\t    }\n\t\n\t    // parent list\n\t    par = stack[stack.length - 1];\n\t\n\t    if (itemIndex) {\n\t      par.ul[1].start = itemIndex;\n\t      currIndex[destLevel] = itemIndex;\n\t      // falsy prevents this from fireing until it is set again\n\t      itemIndex = 0;\n\t    }\n\t    if (listAttr) {\n\t      // \"more than 1\" prevent attribute transfers on list close\n\t      par.att = 9;\n\t      merge(par.ul[1], listAttr);\n\t      listAttr = null;\n\t    }\n\t\n\t    if (!newLi) {\n\t      par.ul.push(listPad(stack.length), item);\n\t      par.li = item;\n\t    }\n\t    if (pba) {\n\t      par.li.push(pba);\n\t      par.att++;\n\t    }\n\t    Array.prototype.push.apply(par.li, parsePhrase(m[2].trim(), options));\n\t\n\t    src.advance(m[0]);\n\t    currIndex[destLevel] = (currIndex[destLevel] || 0) + 1;\n\t  }\n\t\n\t  // remember indexes for continuations next time\n\t  options._lst = currIndex;\n\t\n\t  while (stack.length) {\n\t    s = stack.pop();\n\t    s.ul.push(listPad(stack.length));\n\t    // lists have a predictable structure - move pba from listitem to list\n\t    if (s.att === 1 && !s.ul[3][1].substr) {\n\t      merge(s.ul[1], s.ul[3].splice(1, 1)[0]);\n\t    }\n\t  }\n\t\n\t  return s.ul;\n\t}\n\t\n\tmodule.exports = {\n\t  testList: testList,\n\t  parseList: parseList\n\t};\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/* definitions list parser */\n\t\n\tvar ribbon = __webpack_require__(5);\n\t\n\tvar reDeflist = /^((?:- (?:[^\\n]\\n?)+?)+:=(?: *\\n[^\\0]+?=:(?:\\n|$)|(?:[^\\0]+?(?:$|\\n(?=\\n|- )))))+/;\n\tvar reItem = /^((?:- (?:[^\\n]\\n?)+?)+):=( *\\n[^\\0]+?=:\\s*(?:\\n|$)|(?:[^\\0]+?(?:$|\\n(?=\\n|- ))))/;\n\t\n\tfunction testDefList(src) {\n\t  return reDeflist.exec(src);\n\t}\n\t\n\tfunction parseDefList(src, options) {\n\t  src = ribbon(src.trim());\n\t\n\t  // late loading to get around the lack of non-circular-dependency support in RequireJS\n\t  var parsePhrase = __webpack_require__(9).parsePhrase;\n\t  var parseFlow = __webpack_require__(6).parseFlow;\n\t\n\t  var deflist = ['dl', '\\n'];\n\t  var terms = void 0;\n\t  var def = void 0;\n\t  var m = void 0;\n\t\n\t  while (m = reItem.exec(src)) {\n\t    // add terms\n\t    terms = m[1].split(/(?:^|\\n)\\- /).slice(1);\n\t    while (terms.length) {\n\t      deflist.push('\\t', ['dt'].concat(parsePhrase(terms.shift().trim(), options)), '\\n');\n\t    }\n\t    // add definitions\n\t    def = m[2].trim();\n\t    deflist.push('\\t', ['dd'].concat(/=:$/.test(def) ? parseFlow(def.slice(0, -2).trim(), options) : parsePhrase(def, options)), '\\n');\n\t    src.advance(m[0]);\n\t  }\n\t  return deflist;\n\t}\n\t\n\texports.testDefList = testDefList;\n\texports.parseDefList = parseDefList;\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/* textile table parser */\n\t\n\tvar re = __webpack_require__(4);\n\tvar merge = __webpack_require__(1);\n\tvar ribbon = __webpack_require__(5);\n\t\n\tvar _require = __webpack_require__(10);\n\t\n\tvar parseAttr = _require.parseAttr;\n\t\n\tvar _require2 = __webpack_require__(9);\n\t\n\tvar parsePhrase = _require2.parsePhrase;\n\t\n\tvar _require3 = __webpack_require__(2);\n\t\n\tvar reIndent = _require3.reIndent;\n\t\n\tvar _require4 = __webpack_require__(12);\n\t\n\tvar txattr = _require4.txattr;\n\t\n\tre.pattern.txattr = txattr;\n\t\n\tvar reTable = re.compile(/^((?:table[:txattr:]\\.(?:\\s(.+?))\\s*\\n)?(?:(?:[:txattr:]\\.[^\\n\\S]*)?\\|.*?\\|[^\\n\\S]*(?:\\n|$))+)([^\\n\\S]*\\n)?/, 's');\n\tvar reHead = /^table(_?)([^\\n]*?)\\.(?:[ \\t](.+?))?\\s*\\n/;\n\tvar reRow = re.compile(/^(?:\\|([~\\^\\-][:txattr:])\\.\\s*\\n)?([:txattr:]\\.[^\\n\\S]*)?\\|(.*?)\\|[^\\n\\S]*(\\n|$)/, 's');\n\tvar reCaption = /^\\|=([^\\n+]*)\\n/;\n\tvar reColgroup = /^\\|:([^\\n+]*)\\|[\\r\\t ]*\\n/;\n\tvar reRowgroup = /^\\|([\\^\\-~])([^\\n+]*)\\.[ \\t\\r]*\\n/;\n\t\n\tvar charToTag = {\n\t  '^': 'thead',\n\t  '~': 'tfoot',\n\t  '-': 'tbody'\n\t};\n\t\n\tfunction parseColgroup(src) {\n\t  var colgroup = ['colgroup', {}];\n\t  src.split('|').forEach(function (s, isCol) {\n\t    var col = isCol ? {} : colgroup[1];\n\t    var d = s.trim();\n\t    var m = void 0;\n\t    if (d) {\n\t      if (m = /^\\\\(\\d+)/.exec(d)) {\n\t        col.span = +m[1];\n\t        d = d.slice(m[0].length);\n\t      }\n\t      if (m = parseAttr(d, 'col')) {\n\t        merge(col, m[1]);\n\t        d = d.slice(m[0]);\n\t      }\n\t      if (m = /\\b\\d+\\b/.exec(d)) {\n\t        col.width = +m[0];\n\t      }\n\t    }\n\t    if (isCol) {\n\t      colgroup.push('\\n\\t\\t', ['col', col]);\n\t    }\n\t  });\n\t  return colgroup.concat(['\\n\\t']);\n\t}\n\t\n\tfunction testTable(src) {\n\t  return reTable.exec(src);\n\t}\n\t\n\tfunction parseTable(src, options) {\n\t  src = ribbon(src.trim());\n\t\n\t  var rowgroups = [];\n\t  var colgroup = void 0;\n\t  var caption = void 0;\n\t  var tAttr = {};\n\t  var tCurr = void 0;\n\t  var row = void 0;\n\t  var inner = void 0;\n\t  var pba = void 0;\n\t  var more = void 0;\n\t  var m = void 0;\n\t  var extended = 0;\n\t\n\t  var setRowGroup = function setRowGroup(type, pba) {\n\t    tCurr = [type, pba || {}];\n\t    rowgroups.push(tCurr);\n\t  };\n\t\n\t  if (m = reHead.exec(src)) {\n\t    // parse and apply table attr\n\t    src.advance(m[0]);\n\t    pba = parseAttr(m[2], 'table');\n\t    if (pba) {\n\t      merge(tAttr, pba[1]);\n\t    }\n\t    if (m[3]) {\n\t      tAttr.summary = m[3];\n\t    }\n\t  }\n\t\n\t  // caption\n\t  if (m = reCaption.exec(src)) {\n\t    caption = ['caption'];\n\t    if (pba = parseAttr(m[1], 'caption')) {\n\t      caption.push(pba[1]);\n\t      m[1] = m[1].slice(pba[0]);\n\t    }\n\t    if (/\\./.test(m[1])) {\n\t      // mandatory \".\"\n\t      caption.push(m[1].slice(1).replace(/\\|\\s*$/, '').trim());\n\t      extended++;\n\t      src.advance(m[0]);\n\t    } else {\n\t      caption = null;\n\t    }\n\t  }\n\t\n\t  do {\n\t    // colgroup\n\t    if (m = reColgroup.exec(src)) {\n\t      colgroup = parseColgroup(m[1]);\n\t      extended++;\n\t    }\n\t    // \"rowgroup\" (tbody, thead, tfoot)\n\t    else if (m = reRowgroup.exec(src)) {\n\t        // PHP allows any amount of these in any order\n\t        // and simply translates them straight through\n\t        // the same is done here.\n\t        var tag = charToTag[m[1]] || 'tbody';\n\t        pba = parseAttr(m[2] + ' ', tag);\n\t        setRowGroup(tag, pba && pba[1]);\n\t        extended++;\n\t      }\n\t      // row\n\t      else if (m = reRow.exec(src)) {\n\t          if (!tCurr) {\n\t            setRowGroup('tbody');\n\t          }\n\t\n\t          row = ['tr'];\n\t\n\t          if (m[2] && (pba = parseAttr(m[2], 'tr'))) {\n\t            // FIXME: requires \"\\.\\s?\" -- else what ?\n\t            row.push(pba[1]);\n\t          }\n\t\n\t          tCurr.push('\\n\\t\\t', row);\n\t          inner = ribbon(m[3]);\n\t\n\t          do {\n\t            inner.save();\n\t\n\t            // cell loop\n\t            var th = inner.startsWith('_');\n\t            var cell = [th ? 'th' : 'td'];\n\t            if (th) {\n\t              inner.advance(1);\n\t            }\n\t\n\t            pba = parseAttr(inner, 'td');\n\t            if (pba) {\n\t              inner.advance(pba[0]);\n\t              cell.push(pba[1]); // FIXME: don't do this if next text fails\n\t            }\n\t\n\t            if (pba || th) {\n\t              var p = /^\\.\\s*/.exec(inner);\n\t              if (p) {\n\t                inner.advance(p[0]);\n\t              } else {\n\t                cell = ['td'];\n\t                inner.load();\n\t              }\n\t            }\n\t\n\t            var mx = /^(==.*?==|[^\\|])*/.exec(inner);\n\t            cell = cell.concat(parsePhrase(mx[0], options));\n\t            row.push('\\n\\t\\t\\t', cell);\n\t            more = inner.valueOf().charAt(mx[0].length) === '|';\n\t            inner.advance(mx[0].length + 1);\n\t          } while (more);\n\t\n\t          row.push('\\n\\t\\t');\n\t        }\n\t    //\n\t    if (m) {\n\t      src.advance(m[0]);\n\t    }\n\t  } while (m);\n\t\n\t  // assemble table\n\t  var table = ['table', tAttr];\n\t  if (extended) {\n\t    if (caption) {\n\t      table.push('\\n\\t', caption);\n\t    }\n\t    if (colgroup) {\n\t      table.push('\\n\\t', colgroup);\n\t    }\n\t    rowgroups.forEach(function (tbody) {\n\t      table.push('\\n\\t', tbody.concat(['\\n\\t']));\n\t    });\n\t  } else {\n\t    table = table.concat(reIndent(rowgroups[0].slice(2), -1));\n\t  }\n\t\n\t  table.push('\\n');\n\t  return table;\n\t}\n\t\n\tmodule.exports = {\n\t  parseColgroup: parseColgroup,\n\t  parseTable: parseTable,\n\t  testTable: testTable\n\t};\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** textile.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap c3fdea779de427360583\n **/","/*\n** Textile parser for JavaScript\n**\n** Copyright (c) 2012 Borgar Þorsteinsson (MIT License).\n**\n*/\n\nconst merge = require( './merge' );\nconst { toHTML } = require( './jsonml' );\nconst { parseFlow } = require( './textile/flow' );\nconst { parseHtml } = require( './html' );\n\nfunction textile ( txt, opt ) {\n  // get a throw-away copy of options\n  opt = merge( merge({}, textile.defaults ), opt || {});\n  // run the converter\n  return parseFlow( txt, opt ).map( toHTML ).join( '' );\n};\nmodule.exports = textile;\n\n// options\ntextile.defaults = {\n  // single-line linebreaks are converted to <br> by default\n  'breaks': true\n};\ntextile.setOptions = textile.setoptions = function ( opt ) {\n  merge( textile.defaults, opt );\n  return this;\n};\n\ntextile.parse = textile.convert = textile;\ntextile.html_parser = parseHtml;\n\ntextile.jsonml = function ( txt, opt ) {\n  // get a throw-away copy of options\n  opt = merge( merge({}, textile.defaults ), opt || {});\n  // parse and return tree\n  return [ 'html' ].concat( parseFlow( txt, opt ) );\n};\ntextile.serialize = toHTML;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","// merge object b properties into object a\nmodule.exports = function merge ( a, b ) {\n  if ( b ) {\n    for ( const k in b ) {\n      a[ k ] = b[ k ];\n    }\n  }\n  return a;\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/merge.js\n **/","/*\n** JSONML helper methods - http://www.jsonml.org/\n**\n** This provides the `JSONML` object, which contains helper\n** methods for rendering JSONML to HTML.\n**\n** Note that the tag ! is taken to mean comment, this is however\n** not specified in the JSONML spec.\n*/\n\nconst singletons = require( './html' ).singletons;\n\n// drop or add tab levels to JsonML tree\nfunction reIndent ( ml, shiftBy ) {\n  // a bit obsessive, but there we are...\n  if ( !shiftBy ) {\n    return ml;\n  }\n  return ml.map( function ( s ) {\n    if ( /^\\n\\t+/.test( s ) ) {\n      if ( shiftBy < 0 ) {\n        s = s.slice( 0, shiftBy );\n      }\n      else {\n        for ( let i = 0; i < shiftBy; i++ ) {\n          s += '\\t';\n        }\n      }\n    }\n    else if ( Array.isArray( s ) ) {\n      return reIndent( s, shiftBy );\n    }\n    return s;\n  });\n}\n\nfunction escape ( text, escapeQuotes ) {\n  return text.replace( /&(?!(#\\d{2,}|#x[\\da-fA-F]{2,}|[a-zA-Z][a-zA-Z1-4]{1,6});)/g, '&amp;' )\n             .replace( /</g, '&lt;' )\n             .replace( />/g, '&gt;' )\n             .replace( /\"/g, escapeQuotes ? '&quot;' : '\"' )\n             .replace( /'/g, escapeQuotes ? '&#39;' : \"'\" );\n}\n\nfunction toHTML ( jsonml ) {\n  jsonml = jsonml.concat();\n\n  // basic case\n  if ( typeof jsonml === 'string' ) {\n    return escape( jsonml );\n  }\n\n  const tag = jsonml.shift();\n  let attributes = {};\n  let tagAttrs = '';\n  const content = [];\n\n  if ( jsonml.length && typeof jsonml[0] === 'object' && !Array.isArray( jsonml[0] ) ) {\n    attributes = jsonml.shift();\n  }\n\n  while ( jsonml.length ) {\n    content.push( toHTML( jsonml.shift() ) );\n  }\n\n  for ( const a in attributes ) {\n    tagAttrs += ( attributes[a] == null )\n            ? ` ${ a }`\n            : ` ${ a }=\"${ escape( String( attributes[a] ), true ) }\"`;\n  }\n\n  // be careful about adding whitespace here for inline elements\n  if ( tag === '!' ) {\n    return `<!--${ content.join( '' ) }-->`;\n  }\n  else if ( tag in singletons ) {\n    return `<${ tag }${ tagAttrs } />`;\n  }\n  else {\n    return `<${ tag }${ tagAttrs }>${ content.join( '' ) }</${ tag }>`;\n  }\n}\n\nmodule.exports = {\n  reIndent: reIndent,\n  toHTML: toHTML,\n  escape: escape\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/jsonml.js\n **/","const re = require( './re' );\nconst ribbon = require( './ribbon' );\n\nre.pattern.html_id = '[a-zA-Z][a-zA-Z\\\\d:]*';\nre.pattern.html_attr = '(?:\"[^\"]+\"|\\'[^\\']+\\'|[^>\\\\s]+)';\n\nconst reAttr = re.compile( /^\\s*([^=\\s]+)(?:\\s*=\\s*(\"[^\"]+\"|'[^']+'|[^>\\s]+))?/ );\nconst reComment = re.compile( /^<!--(.+?)-->/, 's' );\nconst reEndTag = re.compile( /^<\\/([:html_id:])([^>]*)>/ );\nconst reTag = re.compile( /^<([:html_id:])((?:\\s[^=\\s\\/]+(?:\\s*=\\s*[:html_attr:])?)+)?\\s*(\\/?)>(\\n*)/ );\nconst reHtmlTagBlock = re.compile( /^\\s*<([:html_id:](?::[a-zA-Z\\d]+)*)((?:\\s[^=\\s\\/]+(?:\\s*=\\s*[:html_attr:])?)+)?\\s*(\\/?)>(\\n*)/ );\n\n// area, base, basefont, bgsound, br, col, command, embed, frame, hr,\n// img, input, keygen, link, meta, param, source, track or wbr\nconst singletons = {\n  br: 1,\n  hr: 1,\n  img: 1,\n  link: 1,\n  meta: 1,\n  wbr: 1,\n  area: 1,\n  param: 1,\n  input: 1,\n  option: 1,\n  base: 1,\n  col: 1\n};\n\nfunction allowAll () {\n  return true;\n}\n\nfunction testComment ( src ) {\n  return reComment.exec( src );\n}\n\nfunction testOpenTagBlock ( src ) {\n  return reHtmlTagBlock.exec( src );\n}\n\nfunction testOpenTag ( src ) {\n  return reTag.exec( src );\n}\n\nfunction testCloseTag ( src ) {\n  return reEndTag.exec( src );\n}\n\nfunction parseHtmlAttr ( attrSrc ) {\n  // parse ATTR and add to element\n  const attr = {};\n  let m;\n  while ( ( m = reAttr.exec( attrSrc ) ) ) {\n    attr[ m[1] ] = ( typeof m[2] === 'string' ) ? m[2].replace( /^([\"'])(.*)\\1$/, '$2' ) : null;\n    attrSrc = attrSrc.slice( m[0].length );\n  }\n  return attr;\n}\n\n// This \"indesciminately\" parses HTML text into a list of JSON-ML element\n// No steps are taken however to prevent things like <table><p><td> - user can still create nonsensical but \"well-formed\" markup\nfunction parseHtml ( src, whitelistTags ) {\n  const root = [];\n  let list = root;\n  const _stack = [];\n  const oktag = whitelistTags ? function ( tag ) { return tag in whitelistTags; } : allowAll;\n  let m;\n  let tag;\n\n  src = ( typeof src === 'string' ) ? ribbon( src ) : src;\n  // loop\n  do {\n    // comment\n    if ( ( m = testComment( src ) ) && oktag( '!' ) ) {\n      src.advance( m[0] );\n      list.push( [ '!', m[1] ] );\n    }\n\n    // end tag\n    else if ( ( m = testCloseTag( src ) ) && oktag( m[1] ) ) {\n      tag = m[1];\n      if ( _stack.length ) {\n        for ( let i = _stack.length - 1; i >= 0; i-- ) {\n          const head = _stack[i];\n          if ( head[0] === tag ) {\n            _stack.splice( i );\n            list = _stack[_stack.length - 1] || root;\n            break;\n          }\n        }\n      }\n      src.advance( m[0] );\n    }\n\n    // open/void tag\n    else if ( ( m = testOpenTag( src ) ) && oktag( m[1] ) ) {\n      src.advance( m[0] );\n      tag = m[1];\n      const single = m[3] || m[1] in singletons;\n      const tail = m[4];\n      const element = [ tag ];\n\n      // attributes\n      if ( m[2] ) {\n        element.push( parseHtmlAttr( m[2] ) );\n      }\n\n      // single tag\n      if ( single ) {\n        // let us add the element and continue our quest...\n        list.push( element );\n        if ( tail ) {\n          list.push( tail );\n        }\n      }\n      // open tag\n      else {\n        if ( tail ) {\n          element.push( tail );\n        }\n\n        // TODO: some things auto close other things: <td>, <li>, <p>, <table>\n        // if ( tag === 'p' && _stack.length ) {\n        //   var seek = /^(p)$/;\n        //   for (var i=_stack.length-1; i>=0; i--) {\n        //     var head = _stack[i];\n        //     if ( seek.test( head[0] ) /* === tag */ ) {\n        //       //src.advance( m[0] );\n        //       _stack.splice( i );\n        //       list = _stack[i] || root;\n        //     }\n        //   }\n        // }\n\n        // TODO: some elements can move parser into \"text\" mode\n        // style, xmp, iframe, noembed, noframe, textarea, title, script, noscript, plaintext\n        // if ( /^(script)$/.test( tag ) ) { }\n\n        _stack.push( element );\n        list.push( element );\n        list = element;\n      }\n    }\n    // text content\n    else {\n      // no match, move by all \"uninteresting\" chars\n      m = /([^<]+|[^\\0])/.exec( src );\n      if ( m ) {\n        list.push( m[0] );\n      }\n      src.advance( m ? m[0].length || 1 : 1 );\n    }\n  }\n  while ( src.valueOf() );\n\n  return root;\n}\n\nmodule.exports = {\n  singletons: singletons,\n  parseHtml: parseHtml,\n  parseHtmlAttr: parseHtmlAttr,\n  testCloseTag: testCloseTag,\n  testOpenTagBlock: testOpenTagBlock,\n  testOpenTag: testOpenTag,\n  testComment: testComment\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/html.js\n **/","/*\n** Regular Expression helper methods\n**\n** This provides the `re` object, which contains several helper\n** methods for working with big regular expressions (soup).\n**\n*/\n\nconst _cache = {};\n\nconst re = module.exports = {\n\n  pattern: {\n    'punct': '[!-/:-@\\\\[\\\\\\\\\\\\]-`{-~]',\n    'space': '\\\\s'\n  },\n\n  escape: function ( src ) {\n    return src.replace( /[\\-\\[\\]\\{\\}\\(\\)\\*\\+\\?\\.,\\\\\\^\\$\\|#\\s]/g, '\\\\$&' );\n  },\n\n  collapse: function ( src ) {\n    return src.replace( /(?:#.*?(?:\\n|$))/g, '' )\n              .replace( /\\s+/g, '' );\n  },\n\n  expandPatterns: function ( src ) {\n    // TODO: provide escape for patterns: \\[:pattern:] ?\n    return src.replace( /\\[:\\s*(\\w+)\\s*:\\]/g, function ( m, k ) {\n      const ex = re.pattern[k];\n      if ( ex ) {\n        return re.expandPatterns( ex );\n      }\n      else {\n        throw new Error( 'Pattern ' + m + ' not found in ' + src );\n      }\n    });\n  },\n\n  isRegExp: function ( r ) {\n    return Object.prototype.toString.call( r ) === '[object RegExp]';\n  },\n\n  compile: function ( src, flags ) {\n    if ( re.isRegExp( src ) ) {\n      if ( arguments.length === 1 ) { // no flags arg provided, use the RegExp one\n        flags = ( src.global ? 'g' : '' ) +\n                ( src.ignoreCase ? 'i' : '' ) +\n                ( src.multiline ? 'm' : '' );\n      }\n      src = src.source;\n    }\n    // don't do the same thing twice\n    const ckey = src + ( flags || '' );\n    if ( ckey in _cache ) {\n      return _cache[ ckey ];\n    }\n    // allow classes\n    let rx = re.expandPatterns( src );\n    // allow verbose expressions\n    if ( flags && /x/.test( flags ) ) {\n      rx = re.collapse( rx );\n    }\n    // allow dotall expressions\n    if ( flags && /s/.test( flags ) ) {\n      rx = rx.replace( /([^\\\\])\\./g, '$1[^\\\\0]' );\n    }\n    // TODO: test if MSIE and add replace \\s with [\\s\\u00a0] if it is?\n    // clean flags and output new regexp\n    flags = ( flags || '' ).replace( /[^gim]/g, '' );\n    return ( _cache[ ckey ] = new RegExp( rx, flags ) );\n  }\n\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/re.js\n **/","module.exports = function ribbon ( feed ) {\n  const org = String( feed );\n  let slot = null;\n  let pos = 0;\n\n  return {\n\n    save: function () {\n      slot = pos;\n    },\n\n    load: function () {\n      pos = slot;\n      feed = org.slice( pos );\n      this.$ = feed;\n    },\n\n    advance: function ( n ) {\n      pos += ( typeof n === 'string' ) ? n.length : n;\n      feed = org.slice( pos );\n      this.$ = feed;\n      return feed;\n    },\n\n    lookbehind: function ( nchars ) {\n      nchars = nchars == null ? 1 : nchars;\n      return org.slice( pos - nchars, pos );\n    },\n\n    startsWith: function ( s ) {\n      return feed.substring( 0, s.length ) === s;\n    },\n\n    valueOf: function () {\n      this.$ = feed;\n      return feed;\n    },\n\n    toString: function () {\n      this.$ = feed;\n      return feed;\n    }\n\n  };\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/ribbon.js\n **/","/*\n** textile flow content parser\n*/\nconst builder = require( '../builder' );\nconst ribbon = require( '../ribbon' );\nconst re = require( '../re' );\nconst fixLinks = require( '../fixlinks' );\n\nconst { parseHtml, parseHtmlAttr, singletons, testComment, testOpenTagBlock } = require( '../html' );\n\nconst { parsePhrase } = require( './phrase' );\nconst { copyAttr, parseAttr } = require( './attr' );\nconst { testList, parseList } = require( './list' );\nconst { testDefList, parseDefList } = require( './deflist' );\nconst { testTable, parseTable } = require( './table' );\n\nconst { txblocks, txlisthd, txattr } = require( './re_ext' );\nre.pattern.txblocks = txblocks;\nre.pattern.txlisthd = txlisthd;\nre.pattern.txattr = txattr;\n\n// HTML tags allowed in the document (root) level that trigger HTML parsing\nconst allowedBlocktags = {\n  'p': 0,\n  'hr': 0,\n  'ul': 1,\n  'ol': 0,\n  'li': 0,\n  'div': 1,\n  'pre': 0,\n  'object': 1,\n  'script': 0,\n  'noscript': 0,\n  'blockquote': 1,\n  'notextile': 1\n};\n\nconst reBlock = re.compile( /^([:txblocks:])/ );\n// const reBlockSE = re.compile( /^[:txblocks:]$/ );\nconst reBlockNormal = re.compile( /^(.*?)($|\\r?\\n(?=[:txlisthd:])|\\r?\\n(?:\\s*\\n|$)+)/, 's' );\nconst reBlockExtended = re.compile( /^(.*?)($|\\r?\\n(?=[:txlisthd:])|\\r?\\n+(?=[:txblocks:][:txattr:]\\.))/, 's' );\nconst reRuler = /^(\\-\\-\\-+|\\*\\*\\*+|___+)(\\r?\\n\\s+|$)/;\nconst reLinkRef = re.compile( /^\\[([^\\]]+)\\]((?:https?:\\/\\/|\\/)\\S+)(?:\\s*\\n|$)/ );\nconst reFootnoteDef = /^fn\\d+$/;\n\nfunction paragraph ( s, tag, pba, linebreak, options ) {\n  tag = tag || 'p';\n  let out = [];\n  s.split( /(?:\\r?\\n){2,}/ ).forEach( function ( bit, i ) {\n    if ( tag === 'p' && /^\\s/.test( bit ) ) {\n      // no-paragraphs\n      // WTF?: Why does Textile not allow linebreaks in spaced lines\n      bit = bit.replace( /\\r?\\n[\\t ]/g, ' ' ).trim();\n      out = out.concat( parsePhrase( bit, options ) );\n    }\n    else {\n      if ( linebreak && i ) { out.push( linebreak ); }\n      out.push( pba ? [ tag, pba ].concat( parsePhrase( bit, options ) )\n                    : [ tag ].concat( parsePhrase( bit, options ) ) );\n    }\n  });\n  return out;\n};\n\nfunction parseFlow ( src, options ) {\n  const list = builder();\n\n  let linkRefs;\n  let m;\n\n  src = ribbon( src.replace( /^( *\\r?\\n)+/, '' ) );\n\n  // loop\n  while ( src.valueOf() ) {\n    src.save();\n\n    // link_ref -- this goes first because it shouldn't trigger a linebreak\n    if ( ( m = reLinkRef.exec( src ) ) ) {\n      if ( !linkRefs ) { linkRefs = {}; }\n      src.advance( m[0] );\n      linkRefs[m[1]] = m[2];\n      continue;\n    }\n\n    // add linebreak\n    list.linebreak();\n\n    // named block\n    if ( ( m = reBlock.exec( src ) ) ) {\n      src.advance( m[0] );\n      const blockType = m[0];\n      let pba = parseAttr( src, blockType );\n\n      if ( pba ) {\n        src.advance( pba[0] );\n        pba = pba[1];\n      }\n      if ( ( m = /^\\.(\\.?)(?:\\s|(?=:))/.exec( src ) ) ) {\n        // FIXME: this whole copyAttr seems rather strange?\n        // slurp rest of block\n        const extended = !!m[1];\n        const reBlockGlob = ( extended ? reBlockExtended : reBlockNormal );\n        m = reBlockGlob.exec( src.advance( m[0] ) );\n        src.advance( m[0] );\n        // bq | bc | notextile | pre | h# | fn# | p | ###\n        if ( blockType === 'bq' ) {\n          let inner = m[1];\n          if ( ( m = /^:(\\S+)\\s+/.exec( inner ) ) ) {\n            if ( !pba ) { pba = {}; }\n            pba.cite = m[1];\n            inner = inner.slice( m[0].length );\n          }\n          // RedCloth adds all attr to both: this is bad because it produces duplicate IDs\n          const par = paragraph( inner, 'p', copyAttr( pba, { 'cite': 1, 'id': 1 }), '\\n', options );\n          list.add( [ 'blockquote', pba, '\\n' ].concat( par ).concat( [ '\\n' ] ) );\n          // FIXME: looks like .linebreak can work here\n        }\n        else if ( blockType === 'bc' ) {\n          const subPba = ( pba ) ? copyAttr( pba, { 'id': 1 }) : null;\n          list.add( [ 'pre', pba, ( subPba ? [ 'code', subPba, m[1] ] : [ 'code', m[1] ] ) ] );\n        }\n        else if ( blockType === 'notextile' ) {\n          list.merge( parseHtml( m[1] ) );\n        }\n        else if ( blockType === '###' ) {\n          // ignore the insides\n        }\n        else if ( blockType === 'pre' ) {\n          // I disagree with RedCloth, but agree with PHP here:\n          // \"pre(foo#bar).. line1\\n\\nline2\" prevents multiline preformat blocks\n          // ...which seems like the whole point of having an extended pre block?\n          list.add( [ 'pre', pba, m[1] ] );\n        }\n        else if ( reFootnoteDef.test( blockType ) ) { // footnote\n          // Need to be careful: RedCloth fails \"fn1(foo#m). footnote\" -- it confuses the ID\n          const fnid = blockType.replace( /\\D+/g, '' );\n          if ( !pba ) { pba = {}; }\n          pba.class = ( pba['class'] ? pba['class'] + ' ' : '' ) + 'footnote';\n          pba.id = 'fn' + fnid;\n          list.add( [ 'p', pba, [ 'a', { 'href': '#fnr' + fnid }, [ 'sup', fnid ] ], ' ' ]\n                      .concat( parsePhrase( m[1], options ) ) );\n        }\n        else { // heading | paragraph\n          list.merge( paragraph( m[1], blockType, pba, '\\n', options ) );\n        }\n        continue;\n      }\n      else {\n        src.load();\n      }\n    }\n\n    // HTML comment\n    if ( ( m = testComment( src ) ) ) {\n      src.advance( m[0] + ( /(?:\\s*\\n+)+/.exec( src ) || [] )[0] );\n      list.add( [ '!', m[1] ] );\n      continue;\n    }\n\n    // block HTML\n    if ( ( m = testOpenTagBlock( src ) ) ) {\n      const tag = m[1];\n      const single = m[3] || tag in singletons;\n      const tail = m[4];\n\n      // Unsurprisingly, all Textile implementations I have tested have trouble parsing simple HTML:\n      //\n      //    \"<div>a\\n<div>b\\n</div>c\\n</div>d\"\n      //\n      // I simply match them here as there is no way anyone is using nested HTML today, or if they\n      // are, then this will at least output less broken HTML as redundant tags will get quoted.\n\n      // Is block tag? ...\n      if ( tag in allowedBlocktags ) {\n        src.advance( m[0] );\n\n        let element = [ tag ];\n\n        if ( m[2] ) {\n          element.push( parseHtmlAttr( m[2] ) );\n        }\n\n        // single tag\n        if ( single ) {\n          // let us add the element and continue our quest...\n          list.add( element );\n          continue;\n        }\n        // block\n        else {\n          // gulp up the rest of this block...\n          const reEndTag = re.compile( `^(.*?)(\\\\s*)(</${ tag }\\\\s*>)(\\\\s*)`, 's' );\n          if ( ( m = reEndTag.exec( src ) ) ) {\n            src.advance( m[0] );\n            if ( tag === 'pre' ) {\n              element.push( tail );\n              element = element.concat( parseHtml( m[1].replace( /(\\r?\\n)+$/, '' ), { 'code': 1 }) );\n              if ( m[2] ) { element.push( m[2] ); }\n              list.add( element );\n            }\n            else if ( tag === 'notextile' ) {\n              element = parseHtml( m[1].trim() );\n              list.merge( element );\n            }\n            else if ( tag === 'script' || tag === 'noscript' ) {\n              element.push( tail + m[1] );\n              list.add( element );\n            }\n            else {\n              // These strange (and unnecessary) linebreak tests are here to get the\n              // tests working perfectly. In reality, this doesn't matter one bit.\n              if ( /\\n/.test( tail ) ) { element.push( '\\n' ); }\n              if ( /\\n/.test( m[1] ) ) {\n                element = element.concat( parseFlow( m[1], options ) );\n              }\n              else {\n                element = element.concat( parsePhrase( m[1].replace( /^ +/, '' ), options ) );\n              }\n              if ( /\\n/.test( m[2] ) ) { element.push( '\\n' ); }\n\n              list.add( element );\n            }\n            continue;\n          }\n        }\n      }\n      src.load();\n    }\n\n    // ruler\n    if ( ( m = reRuler.exec( src ) ) ) {\n      src.advance( m[0] );\n      list.add( [ 'hr' ] );\n      continue;\n    }\n\n    // list\n    if ( ( m = testList( src ) ) ) {\n      src.advance( m[0] );\n      list.add( parseList( m[0], options ) );\n      continue;\n    }\n\n    // definition list\n    if ( ( m = testDefList( src ) ) ) {\n      src.advance( m[0] );\n      list.add( parseDefList( m[0], options ) );\n      continue;\n    }\n\n    // table\n    if ( ( m = testTable( src ) ) ) {\n      src.advance( m[0] );\n      list.add( parseTable( m[1], options ) );\n      continue;\n    }\n\n    // paragraph\n    m = reBlockNormal.exec( src );\n    list.merge( paragraph( m[1], 'p', undefined, '\\n', options ) );\n    src.advance( m[0] );\n  }\n\n  return linkRefs ? fixLinks( list.get(), linkRefs ) : list.get();\n}\n\nexports.parseFlow = parseFlow;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/textile/flow.js\n **/","module.exports = function builder ( initArr ) {\n  const arr = Array.isArray( initArr ) ? initArr : [];\n\n  return {\n    add: function ( node ) {\n      if ( typeof node === 'string' &&\n           typeof arr[ arr.length - 1 ] === 'string' ) {\n        // join if possible\n        arr[ arr.length - 1 ] += node;\n      }\n      else if ( Array.isArray( node ) ) {\n        arr.push( node.filter( s => s !== undefined ) );\n      }\n      else if ( node ) {\n        arr.push( node );\n      }\n      return this;\n    },\n\n    merge: function ( arr ) {\n      for ( let i = 0, l = arr.length; i < l; i++ ) {\n        this.add( arr[i] );\n      }\n      return this;\n    },\n\n    linebreak: function () {\n      if ( arr.length ) {\n        this.add( '\\n' );\n      }\n    },\n\n    get: function () {\n      return arr;\n    }\n  };\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/builder.js\n **/","// recurse the tree and swap out any \"href\" attributes\n// this uses the context as the replace dictionary so it can be fed to Array#map\nmodule.exports = function fixLinks ( ml, dict ) {\n  if ( Array.isArray( ml ) ) {\n    if ( ml[0] === 'a' ) { // found a link\n      const attr = ml[1];\n      if ( typeof attr === 'object' && 'href' in attr && attr.href in dict ) {\n        attr.href = dict[attr.href];\n      }\n    }\n    for ( let i = 0, l = ml.length; i < l; i++ ) {\n      if ( Array.isArray( ml[i] ) ) {\n        fixLinks( ml[i], dict );\n      }\n    }\n  }\n  return ml;\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/fixlinks.js\n **/","/* textile inline parser */\n\nconst ribbon = require( '../ribbon' );\nconst builder = require( '../builder' );\nconst re = require( '../re' );\n\nconst { parseAttr } = require( './attr' );\nconst { parseGlyph } = require( './glyph' );\nconst { parseHtmlAttr, singletons, testComment, testOpenTag } = require( '../html' );\n\nconst { ucaps, txattr, txcite } = require( './re_ext' );\nre.pattern.txattr = txattr;\nre.pattern.txcite = txcite;\nre.pattern.ucaps = ucaps;\n\nconst phraseConvert = {\n  '*': 'strong',\n  '**': 'b',\n  '??': 'cite',\n  '_': 'em',\n  '__': 'i',\n  '-': 'del',\n  '%': 'span',\n  '+': 'ins',\n  '~': 'sub',\n  '^': 'sup',\n  '@': 'code'\n};\n\nconst rePhrase = /^([\\[\\{]?)(__?|\\*\\*?|\\?\\?|[\\-\\+\\^~@%])/;\nconst reImage = re.compile( /^!(?!\\s)([:txattr:](?:\\.[^\\n\\S]|\\.(?:[^\\.\\/]))?)([^!\\s]+?) ?(?:\\(((?:[^\\(\\)]|\\([^\\(\\)]+\\))+)\\))?!(?::([^\\s]+?(?=[!-\\.:-@\\[\\\\\\]-`{-~](?:$|\\s)|\\s|$)))?/ );\nconst reImageFenced = re.compile( /^\\[!(?!\\s)([:txattr:](?:\\.[^\\n\\S]|\\.(?:[^\\.\\/]))?)([^!\\s]+?) ?(?:\\(((?:[^\\(\\)]|\\([^\\(\\)]+\\))+)\\))?!(?::([^\\s]+?(?=[!-\\.:-@\\[\\\\\\]-`{-~](?:$|\\s)|\\s|$)))?\\]/ );\n// NB: there is an exception in here to prevent matching \"TM)\"\nconst reCaps = re.compile( /^((?!TM\\)|tm\\))[[:ucaps:]](?:[[:ucaps:]\\d]{1,}(?=\\()|[[:ucaps:]\\d]{2,}))(?:\\((.*?)\\))?(?=\\W|$)/ );\nconst reLink = re.compile( /^\"(?!\\s)((?:[^\\n\"]|\"(?![\\s:])[^\\n\"]+\"(?!:))+)\"[:txcite:]/ );\nconst reLinkFenced = /^\\[\"([^\\n]+?)\":((?:\\[[a-z0-9]*\\]|[^\\]])+)\\]/;\nconst reLinkTitle = /\\s*\\(((?:\\([^\\(\\)]*\\)|[^\\(\\)])+)\\)$/;\nconst reFootnote = /^\\[(\\d+)(!?)\\]/;\n\nfunction parsePhrase ( src, options ) {\n  src = ribbon( src );\n\n  const list = builder();\n  let m;\n  let pba;\n\n  // loop\n  do {\n    src.save();\n\n    // linebreak -- having this first keeps it from messing to much with other phrases\n    if ( src.startsWith( '\\r\\n' ) ) {\n      src.advance( 1 ); // skip cartridge returns\n    }\n    if ( src.startsWith( '\\n' ) ) {\n      src.advance( 1 );\n      if ( options.breaks ) {\n        list.add( [ 'br' ] );\n      }\n      list.add( '\\n' );\n      continue;\n    }\n\n    // inline notextile\n    if ( ( m = /^==(.*?)==/.exec( src ) ) ) {\n      src.advance( m[0] );\n      list.add( m[1] );\n      continue;\n    }\n\n    // lookbehind => /([\\s>.,\"'?!;:])$/\n    const behind = src.lookbehind( 1 );\n    const boundary = !behind || /^[\\s>.,\"'?!;:()]$/.test( behind );\n    // FIXME: need to test right boundary for phrases as well\n    if ( ( m = rePhrase.exec( src ) ) && ( boundary || m[1] ) ) {\n      src.advance( m[0] );\n      const tok = m[2];\n      const fence = m[1];\n      const phraseType = phraseConvert[tok];\n      const code = phraseType === 'code';\n\n      if ( ( pba = !code && parseAttr( src, phraseType, tok ) ) ) {\n        src.advance( pba[0] );\n        pba = pba[1];\n      }\n      // FIXME: if we can't match the fence on the end, we should output fence-prefix as normal text\n      // seek end\n      let mMid;\n      let mEnd;\n      if ( fence === '[' ) {\n        mMid = '^(.*?)';\n        mEnd = '(?:])';\n      }\n      else if ( fence === '{' ) {\n        mMid = '^(.*?)';\n        mEnd = '(?:})';\n      }\n      else {\n        const t1 = re.escape( tok.charAt( 0 ) );\n        mMid = ( code ) ? '^(\\\\S+|\\\\S+.*?\\\\S)'\n                        : `^([^\\\\s${ t1 }]+|[^\\\\s${ t1 }].*?\\\\S(${ t1 }*))`;\n        mEnd = '(?=$|[\\\\s.,\"\\'!?;:()«»„“”‚‘’])';\n      }\n      const rx = re.compile( `${ mMid }(${ re.escape( tok ) })${ mEnd }` );\n      if ( ( m = rx.exec( src ) ) && m[1] ) {\n        src.advance( m[0] );\n        if ( code ) {\n          list.add( [ phraseType, m[1] ] );\n        }\n        else {\n          list.add( [ phraseType, pba ].concat( parsePhrase( m[1], options ) ) );\n        }\n        continue;\n      }\n      // else\n      src.load();\n    }\n\n    // image\n    if ( ( m = reImage.exec( src ) ) || ( m = reImageFenced.exec( src ) ) ) {\n      src.advance( m[0] );\n\n      pba = m[1] && parseAttr( m[1], 'img' );\n      const attr = pba ? pba[1] : { 'src': '' };\n      let img = [ 'img', attr ];\n      attr.src = m[2];\n      attr.alt = m[3] ? ( attr.title = m[3] ) : '';\n\n      if ( m[4] ) { // +cite causes image to be wraped with a link (or link_ref)?\n        // TODO: support link_ref for image cite\n        img = [ 'a', { 'href': m[4] }, img ];\n      }\n      list.add( img );\n      continue;\n    }\n\n    // html comment\n    if ( ( m = testComment( src ) ) ) {\n      src.advance( m[0] );\n      list.add( [ '!', m[1] ] );\n      continue;\n    }\n    // html tag\n    // TODO: this seems to have a lot of overlap with block tags... DRY?\n    if ( ( m = testOpenTag( src ) ) ) {\n      src.advance( m[0] );\n      const tag = m[1];\n      const single = m[3] || m[1] in singletons;\n      let element = [ tag ];\n      const tail = m[4];\n      if ( m[2] ) {\n        element.push( parseHtmlAttr( m[2] ) );\n      }\n      if ( single ) { // single tag\n        list.add( element ).add( tail );\n        continue;\n      }\n      else { // need terminator\n        // gulp up the rest of this block...\n        const reEndTag = re.compile( `^(.*?)(</${ tag }\\\\s*>)`, 's' );\n        if ( ( m = reEndTag.exec( src ) ) ) {\n          src.advance( m[0] );\n          if ( tag === 'code' ) {\n            element.push( tail, m[1] );\n          }\n          else if ( tag === 'notextile' ) {\n            list.merge( parsePhrase( m[1], options ) );\n            continue;\n          }\n          else {\n            element = element.concat( parsePhrase( m[1], options ) );\n          }\n          list.add( element );\n          continue;\n        }\n        // end tag is missing, treat tag as normal text...\n      }\n      src.load();\n    }\n\n    // footnote\n    if ( ( m = reFootnote.exec( src ) ) && /\\S/.test( behind ) ) {\n      src.advance( m[0] );\n      list.add( [ 'sup', { 'class': 'footnote', 'id': 'fnr' + m[1] },\n                  ( m[2] === '!' ? m[1] // \"!\" suppresses the link\n                                 : [ 'a', { href: '#fn' + m[1] }, m[1] ] )\n                ] );\n      continue;\n    }\n\n    // caps / abbr\n    if ( ( m = reCaps.exec( src ) ) ) {\n      src.advance( m[0] );\n      let caps = [ 'span', { 'class': 'caps' }, m[1] ];\n      if ( m[2] ) {\n        // FIXME: use <abbr>, not acronym!\n        caps = [ 'acronym', { 'title': m[2] }, caps ];\n      }\n      list.add( caps );\n      continue;\n    }\n\n    // links\n    if ( ( boundary && ( m = reLink.exec( src ) ) ) ||\n                       ( m = reLinkFenced.exec( src ) ) ) {\n      src.advance( m[0] );\n      let title = m[1].match( reLinkTitle );\n      let inner = ( title ) ? m[1].slice( 0, m[1].length - title[0].length ) : m[1];\n      if ( ( pba = parseAttr( inner, 'a' ) ) ) {\n        inner = inner.slice( pba[0] );\n        pba = pba[1];\n      }\n      else {\n        pba = {};\n      }\n      if ( title && !inner ) {\n        inner = title[0];\n        title = '';\n      }\n      pba.href = m[2];\n      if ( title ) { pba.title = title[1]; }\n      list.add( [ 'a', pba ].concat( parsePhrase( inner.replace( /^(\\.?\\s*)/, '' ), options ) ) );\n      continue;\n    }\n\n    // no match, move by all \"uninteresting\" chars\n    m = /([a-zA-Z0-9,.':]+|[ \\f\\r\\t\\v\\xA0\\u2028\\u2029]+|[^\\0])/.exec( src );\n    if ( m ) {\n      list.add( m[0] );\n    }\n    src.advance( m ? m[0].length || 1 : 1 );\n  }\n  while ( src.valueOf() );\n\n  return list.get().map( parseGlyph );\n}\n\nexports.parsePhrase = parsePhrase;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/textile/phrase.js\n **/","const reClassid = /^\\(([^\\(\\)\\n]+)\\)/;\nconst rePaddingL = /^(\\(+)/;\nconst rePaddingR = /^(\\)+)/;\nconst reAlignBlock = /^(<>|<|>|=)/;\nconst reAlignImg = /^(<|>|=)/;\nconst reVAlign = /^(~|\\^|\\-)/;\nconst reColSpan = /^\\\\(\\d+)/;\nconst reRowSpan = /^\\/(\\d+)/;\nconst reStyles = /^\\{([^\\}]*)\\}/;\nconst reCSS = /^\\s*([^:\\s]+)\\s*:\\s*(.+)\\s*$/;\nconst reLang = /^\\[([^\\[\\]\\n]+)\\]/;\n\nconst pbaAlignLookup = {\n  '<': 'left',\n  '=': 'center',\n  '>': 'right',\n  '<>': 'justify'\n};\n\nconst pbaVAlignLookup = {\n  '~': 'bottom',\n  '^': 'top',\n  '-': 'middle'\n};\n\nfunction copyAttr ( s, blacklist ) {\n  if ( !s ) { return undefined; }\n  const d = {};\n  for ( const k in s ) {\n    if ( k in s && ( !blacklist || !( k in blacklist ) ) ) {\n      d[ k ] = s[ k ];\n    }\n  }\n  return d;\n}\n\nfunction testBlock ( name ) {\n  // \"in\" test would be better but what about fn#.?\n  return /^(?:table|t[dh]|t(?:foot|head|body)|b[qc]|div|notextile|pre|h[1-6]|fn\\\\d+|p|###)$/.test( name );\n}\n\n/*\n  The attr bit causes massive problems for span elements when parentheses are used.\n  Parentheses are a total mess and, unsurprisingly, cause trip-ups:\n\n   RC: `_{display:block}(span) span (span)_` -> `<em style=\"display:block;\" class=\"span\">(span) span (span)</em>`\n   PHP: `_{display:block}(span) span (span)_` -> `<em style=\"display:block;\">(span) span (span)</em>`\n\n  PHP and RC seem to mostly solve this by not parsing a final attr parens on spans if the\n  following character is a non-space. I've duplicated that: Class/ID is not matched on spans\n  if it is followed by `endToken` or <space>.\n\n  Lang is not matched here if it is followed by the end token. Theoretically I could limit the lang\n  attribute to /^\\[[a-z]{2+}(\\-[a-zA-Z0-9]+)*\\]/ because Textile is layered on top of HTML which\n  only accepts valid BCP 47 language tags, but who knows what atrocities are being preformed\n  out there in the real world. So this attempts to emulate the other libraries.\n*/\nfunction parseAttr ( input, element, endToken ) {\n  input = String( input );\n  if ( !input || element === 'notextile' ) {\n    return undefined;\n  }\n\n  let m;\n  const st = {};\n  const o = { 'style': st };\n  let remaining = input;\n\n  const isBlock = testBlock( element );\n  const isImg = element === 'img';\n  const isList = element === 'li';\n  const isPhrase = !isBlock && !isImg && element !== 'a';\n  const reAlign = ( isImg ) ? reAlignImg : reAlignBlock;\n\n  do {\n    if ( ( m = reStyles.exec( remaining ) ) ) {\n      m[1].split( ';' ).forEach( function ( p ) {\n        const d = p.match( reCSS );\n        if ( d ) { st[ d[1] ] = d[2]; }\n      });\n      remaining = remaining.slice( m[0].length );\n      continue;\n    }\n\n    if ( ( m = reLang.exec( remaining ) ) ) {\n      const rm = remaining.slice( m[0].length );\n      if ( ( !rm && isPhrase ) ||\n           ( endToken && endToken === rm.slice( 0, endToken.length ) ) ) {\n        m = null;\n      }\n      else {\n        o['lang'] = m[1];\n        remaining = remaining.slice( m[0].length );\n      }\n      continue;\n    }\n\n    if ( ( m = reClassid.exec( remaining ) ) ) {\n      const rm = remaining.slice( m[0].length );\n      if (\n          ( !rm && isPhrase ) ||\n          ( endToken && ( rm[0] === ' ' || endToken === rm.slice( 0, endToken.length ) ) )\n         ) {\n        m = null;\n      }\n      else {\n        const bits = m[1].split( '#' );\n        if ( bits[0] ) { o.class = bits[0]; }\n        if ( bits[1] ) { o.id = bits[1]; }\n        remaining = rm;\n      }\n      continue;\n    }\n\n    if ( isBlock || isList ) {\n      if ( ( m = rePaddingL.exec( remaining ) ) ) {\n        st[ 'padding-left' ] = `${ m[1].length }em`;\n        remaining = remaining.slice( m[0].length );\n        continue;\n      }\n      if ( ( m = rePaddingR.exec( remaining ) ) ) {\n        st[ 'padding-right' ] = `${ m[1].length }em`;\n        remaining = remaining.slice( m[0].length );\n        continue;\n      }\n    }\n\n    // only for blocks:\n    if ( isImg || isBlock || isList ) {\n      if ( ( m = reAlign.exec( remaining ) ) ) {\n        const align = pbaAlignLookup[ m[1] ];\n        if ( isImg ) {\n          o[ 'align' ] = align;\n        }\n        else {\n          st[ 'text-align' ] = align;\n        }\n        remaining = remaining.slice( m[0].length );\n        continue;\n      }\n    }\n\n    // only for table cells\n    if ( element === 'td' || element === 'tr' ) {\n      if ( ( m = reVAlign.exec( remaining ) ) ) {\n        st[ 'vertical-align' ] = pbaVAlignLookup[ m[1] ];\n        remaining = remaining.slice( m[0].length );\n        continue;\n      }\n    }\n    if ( element === 'td' ) {\n      if ( ( m = reColSpan.exec( remaining ) ) ) {\n        o[ 'colspan' ] = m[1];\n        remaining = remaining.slice( m[0].length );\n        continue;\n      }\n      if ( ( m = reRowSpan.exec( remaining ) ) ) {\n        o[ 'rowspan' ] = m[1];\n        remaining = remaining.slice( m[0].length );\n        continue;\n      }\n    }\n  }\n  while ( m );\n\n  // collapse styles\n  const s = [];\n  for ( const v in st ) {\n    s.push( `${ v }:${ st[v] }` );\n  }\n  if ( s.length ) {\n    o.style = s.join( ';' );\n  }\n  else {\n    delete o.style;\n  }\n\n  return ( remaining === input ) ? undefined : [ input.length - remaining.length, o ];\n}\n\nmodule.exports = {\n  copyAttr: copyAttr,\n  parseAttr: parseAttr\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/textile/attr.js\n **/","/* textile glyph parser */\n\nconst re = require( '../re' );\n\nconst reApostrophe = /(\\w)'(\\w)/g;\nconst reArrow = /([^\\-]|^)->/;\nconst reClosingDQuote = re.compile( /([^\\s\\[\\(])\"(?=$|\\s|[:punct:])/g );\nconst reClosingSQuote = re.compile( /([^\\s\\[\\(])'(?=$|\\s|[:punct:])/g );\nconst reCopyright = /(\\b ?|\\s|^)(?:\\(C\\)|\\[C\\])/gi;\nconst reDimsign = /([\\d\\.,]+['\"]? ?)x( ?)(?=[\\d\\.,]['\"]?)/g;\nconst reDoublePrime = re.compile( /(\\d*[\\.,]?\\d+)\"(?=\\s|$|[:punct:])/g );\nconst reEllipsis = /([^.]?)\\.{3}/g;\nconst reEmdash = /(^|[\\s\\w])--([\\s\\w]|$)/g;\nconst reEndash = / - /g;\nconst reOpenDQuote = /\"/g;\nconst reOpenSQuote = /'/g;\nconst reRegistered = /(\\b ?|\\s|^)(?:\\(R\\)|\\[R\\])/gi;\nconst reSinglePrime = re.compile( /(\\d*[\\.,]?\\d+)'(?=\\s|$|[:punct:])/g );\nconst reTrademark = /(\\b ?|\\s|^)(?:\\((?:TM|tm)\\)|\\[(?:TM|tm)\\])/g;\n\nexports.parseGlyph = function parseGlyph ( src ) {\n  if ( typeof src !== 'string' ) {\n    return src;\n  }\n  // NB: order is important here ...\n  return src\n    .replace( reArrow, '$1&#8594;' )\n    .replace( reDimsign, '$1&#215;$2' )\n    .replace( reEllipsis, '$1&#8230;' )\n    .replace( reEmdash, '$1&#8212;$2' )\n    .replace( reEndash, ' &#8211; ' )\n    .replace( reTrademark, '$1&#8482;' )\n    .replace( reRegistered, '$1&#174;' )\n    .replace( reCopyright, '$1&#169;' )\n    // double quotes\n    .replace( reDoublePrime, '$1&#8243;' )\n    .replace( reClosingDQuote, '$1&#8221;' )\n    .replace( reOpenDQuote, '&#8220;' )\n    // single quotes\n    .replace( reSinglePrime, '$1&#8242;' )\n    .replace( reApostrophe, '$1&#8217;$2' )\n    .replace( reClosingSQuote, '$1&#8217;' )\n    .replace( reOpenSQuote, '&#8216;' )\n    // fractions and degrees\n    .replace( /[\\(\\[]1\\/4[\\]\\)]/, '&#188;' )\n    .replace( /[\\(\\[]1\\/2[\\]\\)]/, '&#189;' )\n    .replace( /[\\(\\[]3\\/4[\\]\\)]/, '&#190;' )\n    .replace( /[\\(\\[]o[\\]\\)]/, '&#176;' )\n    .replace( /[\\(\\[]\\+\\/\\-[\\]\\)]/, '&#177;' );\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/textile/glyph.js\n **/","/* eslint camelcase: 0 */\n\nexports.txblocks = '(?:b[qc]|div|notextile|pre|h[1-6]|fn\\\\d+|p|###)';\n\nexports.ucaps = 'A-Z' +\n    // Latin extended À-Þ\n    '\\u00c0-\\u00d6\\u00d8-\\u00de' +\n    // Latin caps with embelishments and ligatures...\n    '\\u0100\\u0102\\u0104\\u0106\\u0108\\u010a\\u010c\\u010e\\u0110\\u0112\\u0114\\u0116\\u0118\\u011a\\u011c\\u011e\\u0120\\u0122\\u0124\\u0126\\u0128\\u012a\\u012c\\u012e\\u0130\\u0132\\u0134\\u0136\\u0139\\u013b\\u013d\\u013f' +\n    '\\u0141\\u0143\\u0145\\u0147\\u014a\\u014c\\u014e\\u0150\\u0152\\u0154\\u0156\\u0158\\u015a\\u015c\\u015e\\u0160\\u0162\\u0164\\u0166\\u0168\\u016a\\u016c\\u016e\\u0170\\u0172\\u0174\\u0176\\u0178\\u0179\\u017b\\u017d' +\n    '\\u0181\\u0182\\u0184\\u0186\\u0187\\u0189-\\u018b\\u018e-\\u0191\\u0193\\u0194\\u0196-\\u0198\\u019c\\u019d\\u019f\\u01a0\\u01a2\\u01a4\\u01a6\\u01a7\\u01a9\\u01ac\\u01ae\\u01af\\u01b1-\\u01b3\\u01b5\\u01b7\\u01b8\\u01bc' +\n    '\\u01c4\\u01c7\\u01ca\\u01cd\\u01cf\\u01d1\\u01d3\\u01d5\\u01d7\\u01d9\\u01db\\u01de\\u01e0\\u01e2\\u01e4\\u01e6\\u01e8\\u01ea\\u01ec\\u01ee\\u01f1\\u01f4\\u01f6-\\u01f8\\u01fa\\u01fc\\u01fe' +\n    '\\u0200\\u0202\\u0204\\u0206\\u0208\\u020a\\u020c\\u020e\\u0210\\u0212\\u0214\\u0216\\u0218\\u021a\\u021c\\u021e\\u0220\\u0222\\u0224\\u0226\\u0228\\u022a\\u022c\\u022e\\u0230\\u0232\\u023a\\u023b\\u023d\\u023e' +\n    '\\u0241\\u0243-\\u0246\\u0248\\u024a\\u024c\\u024e' +\n    '\\u1e00\\u1e02\\u1e04\\u1e06\\u1e08\\u1e0a\\u1e0c\\u1e0e\\u1e10\\u1e12\\u1e14\\u1e16\\u1e18\\u1e1a\\u1e1c\\u1e1e\\u1e20\\u1e22\\u1e24\\u1e26\\u1e28\\u1e2a\\u1e2c\\u1e2e\\u1e30\\u1e32\\u1e34\\u1e36\\u1e38\\u1e3a\\u1e3c\\u1e3e\\u1e40' +\n    '\\u1e42\\u1e44\\u1e46\\u1e48\\u1e4a\\u1e4c\\u1e4e\\u1e50\\u1e52\\u1e54\\u1e56\\u1e58\\u1e5a\\u1e5c\\u1e5e\\u1e60\\u1e62\\u1e64\\u1e66\\u1e68\\u1e6a\\u1e6c\\u1e6e\\u1e70\\u1e72\\u1e74\\u1e76\\u1e78\\u1e7a\\u1e7c\\u1e7e' +\n    '\\u1e80\\u1e82\\u1e84\\u1e86\\u1e88\\u1e8a\\u1e8c\\u1e8e\\u1e90\\u1e92\\u1e94\\u1e9e\\u1ea0\\u1ea2\\u1ea4\\u1ea6\\u1ea8\\u1eaa\\u1eac\\u1eae\\u1eb0\\u1eb2\\u1eb4\\u1eb6\\u1eb8\\u1eba\\u1ebc\\u1ebe' +\n    '\\u1ec0\\u1ec2\\u1ec4\\u1ec6\\u1ec8\\u1eca\\u1ecc\\u1ece\\u1ed0\\u1ed2\\u1ed4\\u1ed6\\u1ed8\\u1eda\\u1edc\\u1ede\\u1ee0\\u1ee2\\u1ee4\\u1ee6\\u1ee8\\u1eea\\u1eec\\u1eee\\u1ef0\\u1ef2\\u1ef4\\u1ef6\\u1ef8\\u1efa\\u1efc\\u1efe' +\n    '\\u2c60\\u2c62-\\u2c64\\u2c67\\u2c69\\u2c6b\\u2c6d-\\u2c70\\u2c72\\u2c75\\u2c7e\\u2c7f' +\n    '\\ua722\\ua724\\ua726\\ua728\\ua72a\\ua72c\\ua72e\\ua732\\ua734\\ua736\\ua738\\ua73a\\ua73c\\ua73e' +\n    '\\ua740\\ua742\\ua744\\ua746\\ua748\\ua74a\\ua74c\\ua74e\\ua750\\ua752\\ua754\\ua756\\ua758\\ua75a\\ua75c\\ua75e\\ua760\\ua762\\ua764\\ua766\\ua768\\ua76a\\ua76c\\ua76e\\ua779\\ua77b\\ua77d\\ua77e' +\n    '\\ua780\\ua782\\ua784\\ua786\\ua78b\\ua78d\\ua790\\ua792\\ua7a0\\ua7a2\\ua7a4\\ua7a6\\ua7a8\\ua7aa';\n\nexports.txcite = ':((?:[^\\\\s()]|\\\\([^\\\\s()]+\\\\)|[()])+?)(?=[!-\\\\.:-@\\\\[\\\\\\\\\\\\]-`{-~]+(?:$|\\\\s)|$|\\\\s)';\n\nconst attr_class = exports.attr_class = '\\\\([^\\\\)]+\\\\)';\nconst attr_style = exports.attr_style = '\\\\{[^\\\\}]+\\\\}';\nconst attr_lang = exports.attr_lang = '\\\\[[^\\\\[\\\\]]+\\\\]';\nconst attr_align = exports.attr_align = '(?:<>|<|>|=)';\nconst attr_pad = exports.attr_pad = '[\\\\(\\\\)]+';\n\nconst txattr = exports.txattr = `(?:${ attr_class }|${ attr_style }|${ attr_lang }|${ attr_align }|${ attr_pad })*`;\n\nexports.txlisthd = `[\\\\t ]*[\\\\#\\\\*]*(\\\\*|\\\\#(?:_|\\\\d+)?)${ txattr }(?: \\\\S|\\\\.\\\\s*(?=\\\\S|\\\\n))`;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/textile/re_ext.js\n **/","/* textile list parser */\nconst ribbon = require( '../ribbon' );\nconst re = require( '../re' );\nconst merge = require( '../merge' );\n\nconst { parseAttr } = require( './attr' );\nconst { parsePhrase } = require( './phrase' );\n\nconst { txlisthd } = require( './re_ext' );\nre.pattern.txlisthd = txlisthd;\nconst reList = re.compile( /^((?:[:txlisthd:][^\\0]*?(?:\\r?\\n|$))+)(\\s*\\n|$)/, 's' );\nconst reItem = re.compile( /^([#\\*]+)([^\\0]+?)(\\n(?=[:txlisthd:])|$)/, 's' );\n\nfunction listPad ( n ) {\n  let s = '\\n';\n  while ( n-- ) {\n    s += '\\t';\n  }\n  return s;\n}\n\nfunction testList ( src ) {\n  return reList.exec( src );\n}\n\nfunction parseList ( src, options ) {\n  src = ribbon( src.replace( /(^|\\r?\\n)[\\t ]+/, '$1' ) );\n\n  const stack = [];\n  const currIndex = {};\n  const lastIndex = options._lst || {};\n  let itemIndex = 0;\n  let listAttr;\n  let m;\n  let n;\n  let s;\n\n  while ( ( m = reItem.exec( src ) ) ) {\n    const item = [ 'li' ];\n    const destLevel = m[1].length;\n    const type = ( m[1].substr( -1 ) === '#' ) ? 'ol' : 'ul';\n    let newLi = null;\n    let lst;\n    let par;\n    let pba;\n    let r;\n\n    // list starts and continuations\n    if ( ( n = /^(_|\\d+)/.exec( m[2] ) ) ) {\n      itemIndex = isFinite( n[1] )\n            ? parseInt( n[1], 10 )\n            : lastIndex[ destLevel ] || currIndex[ destLevel ] || 1;\n      m[2] = m[2].slice( n[1].length );\n    }\n\n    if ( ( pba = parseAttr( m[2], 'li' ) ) ) {\n      m[2] = m[2].slice( pba[0] );\n      pba = pba[1];\n    }\n\n    // list control\n    if ( /^\\.\\s*$/.test( m[2] ) ) {\n      listAttr = pba || {};\n      src.advance( m[0] );\n      continue;\n    }\n\n    // create nesting until we have correct level\n    while ( stack.length < destLevel ) {\n      // list always has an attribute object, this simplifies first-pba resolution\n      lst = [ type, {}, listPad( stack.length + 1 ), ( newLi = [ 'li' ] ) ];\n      par = stack[ stack.length - 1 ];\n      if ( par ) {\n        par.li.push( listPad( stack.length ) );\n        par.li.push( lst );\n      }\n      stack.push({\n        ul: lst,\n        li: newLi,\n        // count attributes's found per list\n        att: 0\n      });\n      currIndex[ stack.length ] = 1;\n    }\n\n    // remove nesting until we have correct level\n    while ( stack.length > destLevel ) {\n      r = stack.pop();\n      r.ul.push( listPad( stack.length ) );\n      // lists have a predictable structure - move pba from listitem to list\n      if ( r.att === 1 && !r.ul[3][1].substr ) {\n        merge( r.ul[1], r.ul[3].splice( 1, 1 )[ 0 ] );\n      }\n    }\n\n    // parent list\n    par = stack[ stack.length - 1 ];\n\n    if ( itemIndex ) {\n      par.ul[1].start = itemIndex;\n      currIndex[destLevel] = itemIndex;\n      // falsy prevents this from fireing until it is set again\n      itemIndex = 0;\n    }\n    if ( listAttr ) {\n      // \"more than 1\" prevent attribute transfers on list close\n      par.att = 9;\n      merge( par.ul[1], listAttr );\n      listAttr = null;\n    }\n\n    if ( !newLi ) {\n      par.ul.push( listPad( stack.length ), item );\n      par.li = item;\n    }\n    if ( pba ) {\n      par.li.push( pba );\n      par.att++;\n    }\n    Array.prototype.push.apply( par.li, parsePhrase( m[2].trim(), options ) );\n\n    src.advance( m[0] );\n    currIndex[destLevel] = ( currIndex[destLevel] || 0 ) + 1;\n  }\n\n  // remember indexes for continuations next time\n  options._lst = currIndex;\n\n  while ( stack.length ) {\n    s = stack.pop();\n    s.ul.push( listPad( stack.length ) );\n    // lists have a predictable structure - move pba from listitem to list\n    if ( s.att === 1 && !s.ul[3][1].substr ) {\n      merge( s.ul[1], s.ul[3].splice( 1, 1 )[0] );\n    }\n  }\n\n  return s.ul;\n}\n\nmodule.exports = {\n  testList: testList,\n  parseList: parseList\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/textile/list.js\n **/","/* definitions list parser */\n\nconst ribbon = require( '../ribbon' );\n\nconst reDeflist = /^((?:- (?:[^\\n]\\n?)+?)+:=(?: *\\n[^\\0]+?=:(?:\\n|$)|(?:[^\\0]+?(?:$|\\n(?=\\n|- )))))+/;\nconst reItem = /^((?:- (?:[^\\n]\\n?)+?)+):=( *\\n[^\\0]+?=:\\s*(?:\\n|$)|(?:[^\\0]+?(?:$|\\n(?=\\n|- ))))/;\n\nfunction testDefList ( src ) {\n  return reDeflist.exec( src );\n}\n\nfunction parseDefList ( src, options ) {\n  src = ribbon( src.trim() );\n\n  // late loading to get around the lack of non-circular-dependency support in RequireJS\n  const parsePhrase = require( './phrase' ).parsePhrase;\n  const parseFlow = require( './flow' ).parseFlow;\n\n  const deflist = [ 'dl', '\\n' ];\n  let terms;\n  let def;\n  let m;\n\n  while ( ( m = reItem.exec( src ) ) ) {\n    // add terms\n    terms = m[1].split( /(?:^|\\n)\\- / ).slice( 1 );\n    while ( terms.length ) {\n      deflist.push( '\\t'\n                , [ 'dt' ].concat( parsePhrase( terms.shift().trim(), options ) )\n                , '\\n'\n                );\n    }\n    // add definitions\n    def = m[2].trim();\n    deflist.push( '\\t'\n              , [ 'dd' ].concat(\n                  ( /=:$/.test( def ) )\n                    ? parseFlow( def.slice( 0, -2 ).trim(), options )\n                    : parsePhrase( def, options )\n                )\n              , '\\n'\n              );\n    src.advance( m[0] );\n  }\n  return deflist;\n}\n\nexports.testDefList = testDefList;\nexports.parseDefList = parseDefList;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/textile/deflist.js\n **/","/* textile table parser */\n\nconst re = require( '../re' );\nconst merge = require( '../merge' );\nconst ribbon = require( '../ribbon' );\n\nconst { parseAttr } = require( './attr' );\nconst { parsePhrase } = require( './phrase' );\nconst { reIndent } = require( '../jsonml' );\n\nconst { txattr } = require( './re_ext' );\nre.pattern.txattr = txattr;\n\nconst reTable = re.compile( /^((?:table[:txattr:]\\.(?:\\s(.+?))\\s*\\n)?(?:(?:[:txattr:]\\.[^\\n\\S]*)?\\|.*?\\|[^\\n\\S]*(?:\\n|$))+)([^\\n\\S]*\\n)?/, 's' );\nconst reHead = /^table(_?)([^\\n]*?)\\.(?:[ \\t](.+?))?\\s*\\n/;\nconst reRow = re.compile( /^(?:\\|([~\\^\\-][:txattr:])\\.\\s*\\n)?([:txattr:]\\.[^\\n\\S]*)?\\|(.*?)\\|[^\\n\\S]*(\\n|$)/, 's' );\nconst reCaption = /^\\|=([^\\n+]*)\\n/;\nconst reColgroup = /^\\|:([^\\n+]*)\\|[\\r\\t ]*\\n/;\nconst reRowgroup = /^\\|([\\^\\-~])([^\\n+]*)\\.[ \\t\\r]*\\n/;\n\nconst charToTag = {\n  '^': 'thead',\n  '~': 'tfoot',\n  '-': 'tbody'\n};\n\nfunction parseColgroup ( src ) {\n  const colgroup = [ 'colgroup', {} ];\n  src.split( '|' )\n      .forEach( function ( s, isCol ) {\n        const col = ( isCol ) ? {} : colgroup[ 1 ];\n        let d = s.trim();\n        let m;\n        if ( d ) {\n          if ( ( m = /^\\\\(\\d+)/.exec( d ) ) ) {\n            col.span = +m[ 1 ];\n            d = d.slice( m[ 0 ].length );\n          }\n          if ( ( m = parseAttr( d, 'col' ) ) ) {\n            merge( col, m[ 1 ] );\n            d = d.slice( m[ 0 ] );\n          }\n          if ( ( m = /\\b\\d+\\b/.exec( d ) ) ) {\n            col.width = +m[0];\n          }\n        }\n        if ( isCol ) {\n          colgroup.push( '\\n\\t\\t', [ 'col', col ] );\n        }\n      });\n  return colgroup.concat( [ '\\n\\t' ] );\n}\n\nfunction testTable ( src ) {\n  return reTable.exec( src );\n}\n\nfunction parseTable ( src, options ) {\n  src = ribbon( src.trim() );\n\n  const rowgroups = [];\n  let colgroup;\n  let caption;\n  const tAttr = {};\n  let tCurr;\n  let row;\n  let inner;\n  let pba;\n  let more;\n  let m;\n  let extended = 0;\n\n  const setRowGroup = function ( type, pba ) {\n    tCurr = [ type, pba || {} ];\n    rowgroups.push( tCurr );\n  };\n\n  if ( ( m = reHead.exec( src ) ) ) {\n    // parse and apply table attr\n    src.advance( m[0] );\n    pba = parseAttr( m[2], 'table' );\n    if ( pba ) {\n      merge( tAttr, pba[1] );\n    }\n    if ( m[3] ) {\n      tAttr.summary = m[3];\n    }\n  }\n\n  // caption\n  if ( ( m = reCaption.exec( src ) ) ) {\n    caption = [ 'caption' ];\n    if ( ( pba = parseAttr( m[1], 'caption' ) ) ) {\n      caption.push( pba[1] );\n      m[1] = m[1].slice( pba[0] );\n    }\n    if ( /\\./.test( m[1] ) ) { // mandatory \".\"\n      caption.push( m[1].slice( 1 ).replace( /\\|\\s*$/, '' ).trim() );\n      extended++;\n      src.advance( m[0] );\n    }\n    else {\n      caption = null;\n    }\n  }\n\n  do {\n    // colgroup\n    if ( ( m = reColgroup.exec( src ) ) ) {\n      colgroup = parseColgroup( m[1] );\n      extended++;\n    }\n    // \"rowgroup\" (tbody, thead, tfoot)\n    else if ( ( m = reRowgroup.exec( src ) ) ) {\n      // PHP allows any amount of these in any order\n      // and simply translates them straight through\n      // the same is done here.\n      const tag = charToTag[ m[1] ] || 'tbody';\n      pba = parseAttr( `${ m[2] } `, tag );\n      setRowGroup( tag, pba && pba[1] );\n      extended++;\n    }\n    // row\n    else if ( ( m = reRow.exec( src ) ) ) {\n      if ( !tCurr ) { setRowGroup( 'tbody' ); }\n\n      row = [ 'tr' ];\n\n      if ( m[2] && ( pba = parseAttr( m[2], 'tr' ) ) ) {\n        // FIXME: requires \"\\.\\s?\" -- else what ?\n        row.push( pba[1] );\n      }\n\n      tCurr.push( '\\n\\t\\t', row );\n      inner = ribbon( m[3] );\n\n      do {\n        inner.save();\n\n        // cell loop\n        const th = inner.startsWith( '_' );\n        let cell = [ th ? 'th' : 'td' ];\n        if ( th ) {\n          inner.advance( 1 );\n        }\n\n        pba = parseAttr( inner, 'td' );\n        if ( pba ) {\n          inner.advance( pba[0] );\n          cell.push( pba[1] ); // FIXME: don't do this if next text fails\n        }\n\n        if ( pba || th ) {\n          const p = /^\\.\\s*/.exec( inner );\n          if ( p ) {\n            inner.advance( p[0] );\n          }\n          else {\n            cell = [ 'td' ];\n            inner.load();\n          }\n        }\n\n        const mx = /^(==.*?==|[^\\|])*/.exec( inner );\n        cell = cell.concat( parsePhrase( mx[0], options ) );\n        row.push( '\\n\\t\\t\\t', cell );\n        more = inner.valueOf().charAt( mx[0].length ) === '|';\n        inner.advance( mx[0].length + 1 );\n      }\n      while ( more );\n\n      row.push( '\\n\\t\\t' );\n    }\n    //\n    if ( m ) {\n      src.advance( m[0] );\n    }\n  }\n  while ( m );\n\n  // assemble table\n  let table = [ 'table', tAttr ];\n  if ( extended ) {\n    if ( caption ) {\n      table.push( '\\n\\t', caption );\n    }\n    if ( colgroup ) {\n      table.push( '\\n\\t', colgroup );\n    }\n    rowgroups.forEach( function ( tbody ) {\n      table.push( '\\n\\t', tbody.concat( [ '\\n\\t' ] ) );\n    });\n  }\n  else {\n    table = table.concat( reIndent( rowgroups[0].slice( 2 ), -1 ) );\n  }\n\n  table.push( '\\n' );\n  return table;\n}\n\nmodule.exports = {\n  parseColgroup: parseColgroup,\n  parseTable: parseTable,\n  testTable: testTable\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/textile/table.js\n **/"],"sourceRoot":""}