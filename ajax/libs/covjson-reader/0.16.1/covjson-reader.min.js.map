{"version":3,"file":"covjson-reader.min.js","sources":["../../../../../\u0000commonjsHelpers","node_modules/ndarray/node_modules/is-buffer/index.js","node_modules/ndarray/node_modules/iota-array/iota.js","node_modules/ndarray/ndarray.js","node_modules/url-template/lib/url-template.js","src/constants.js","src/util.js","src/http-common.js","src/http.js","../../../../../\u0000babelHelpers","src/Coverage.js","src/CoverageCollection.js","src/reader.js"],"sourcesContent":["\nexport var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {}\n\nexport function createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}","/**\n * Determine if an object is Buffer\n *\n * Author:   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * License:  MIT\n *\n * `npm install is-buffer`\n */\n\nmodule.exports = function (obj) {\n  return !!(obj != null &&\n    (obj._isBuffer || // For Safari 5-7 (missing Object.prototype.constructor)\n      (obj.constructor &&\n      typeof obj.constructor.isBuffer === 'function' &&\n      obj.constructor.isBuffer(obj))\n    ))\n}\n","\"use strict\"\n\nfunction iota(n) {\n  var result = new Array(n)\n  for(var i=0; i<n; ++i) {\n    result[i] = i\n  }\n  return result\n}\n\nmodule.exports = iota","var iota = require(\"iota-array\")\nvar isBuffer = require(\"is-buffer\")\n\nvar hasTypedArrays  = ((typeof Float64Array) !== \"undefined\")\n\nfunction compare1st(a, b) {\n  return a[0] - b[0]\n}\n\nfunction order() {\n  var stride = this.stride\n  var terms = new Array(stride.length)\n  var i\n  for(i=0; i<terms.length; ++i) {\n    terms[i] = [Math.abs(stride[i]), i]\n  }\n  terms.sort(compare1st)\n  var result = new Array(terms.length)\n  for(i=0; i<result.length; ++i) {\n    result[i] = terms[i][1]\n  }\n  return result\n}\n\nfunction compileConstructor(dtype, dimension) {\n  var className = [\"View\", dimension, \"d\", dtype].join(\"\")\n  if(dimension < 0) {\n    className = \"View_Nil\" + dtype\n  }\n  var useGetters = (dtype === \"generic\")\n\n  if(dimension === -1) {\n    //Special case for trivial arrays\n    var code =\n      \"function \"+className+\"(a){this.data=a;};\\\nvar proto=\"+className+\".prototype;\\\nproto.dtype='\"+dtype+\"';\\\nproto.index=function(){return -1};\\\nproto.size=0;\\\nproto.dimension=-1;\\\nproto.shape=proto.stride=proto.order=[];\\\nproto.lo=proto.hi=proto.transpose=proto.step=\\\nfunction(){return new \"+className+\"(this.data);};\\\nproto.get=proto.set=function(){};\\\nproto.pick=function(){return null};\\\nreturn function construct_\"+className+\"(a){return new \"+className+\"(a);}\"\n    var procedure = new Function(code)\n    return procedure()\n  } else if(dimension === 0) {\n    //Special case for 0d arrays\n    var code =\n      \"function \"+className+\"(a,d) {\\\nthis.data = a;\\\nthis.offset = d\\\n};\\\nvar proto=\"+className+\".prototype;\\\nproto.dtype='\"+dtype+\"';\\\nproto.index=function(){return this.offset};\\\nproto.dimension=0;\\\nproto.size=1;\\\nproto.shape=\\\nproto.stride=\\\nproto.order=[];\\\nproto.lo=\\\nproto.hi=\\\nproto.transpose=\\\nproto.step=function \"+className+\"_copy() {\\\nreturn new \"+className+\"(this.data,this.offset)\\\n};\\\nproto.pick=function \"+className+\"_pick(){\\\nreturn TrivialArray(this.data);\\\n};\\\nproto.valueOf=proto.get=function \"+className+\"_get(){\\\nreturn \"+(useGetters ? \"this.data.get(this.offset)\" : \"this.data[this.offset]\")+\n\"};\\\nproto.set=function \"+className+\"_set(v){\\\nreturn \"+(useGetters ? \"this.data.set(this.offset,v)\" : \"this.data[this.offset]=v\")+\"\\\n};\\\nreturn function construct_\"+className+\"(a,b,c,d){return new \"+className+\"(a,d)}\"\n    var procedure = new Function(\"TrivialArray\", code)\n    return procedure(CACHED_CONSTRUCTORS[dtype][0])\n  }\n\n  var code = [\"'use strict'\"]\n\n  //Create constructor for view\n  var indices = iota(dimension)\n  var args = indices.map(function(i) { return \"i\"+i })\n  var index_str = \"this.offset+\" + indices.map(function(i) {\n        return \"this.stride[\" + i + \"]*i\" + i\n      }).join(\"+\")\n  var shapeArg = indices.map(function(i) {\n      return \"b\"+i\n    }).join(\",\")\n  var strideArg = indices.map(function(i) {\n      return \"c\"+i\n    }).join(\",\")\n  code.push(\n    \"function \"+className+\"(a,\" + shapeArg + \",\" + strideArg + \",d){this.data=a\",\n      \"this.shape=[\" + shapeArg + \"]\",\n      \"this.stride=[\" + strideArg + \"]\",\n      \"this.offset=d|0}\",\n    \"var proto=\"+className+\".prototype\",\n    \"proto.dtype='\"+dtype+\"'\",\n    \"proto.dimension=\"+dimension)\n\n  //view.size:\n  code.push(\"Object.defineProperty(proto,'size',{get:function \"+className+\"_size(){\\\nreturn \"+indices.map(function(i) { return \"this.shape[\"+i+\"]\" }).join(\"*\"),\n\"}})\")\n\n  //view.order:\n  if(dimension === 1) {\n    code.push(\"proto.order=[0]\")\n  } else {\n    code.push(\"Object.defineProperty(proto,'order',{get:\")\n    if(dimension < 4) {\n      code.push(\"function \"+className+\"_order(){\")\n      if(dimension === 2) {\n        code.push(\"return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})\")\n      } else if(dimension === 3) {\n        code.push(\n\"var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\\\nif(s0>s1){\\\nif(s1>s2){\\\nreturn [2,1,0];\\\n}else if(s0>s2){\\\nreturn [1,2,0];\\\n}else{\\\nreturn [1,0,2];\\\n}\\\n}else if(s0>s2){\\\nreturn [2,0,1];\\\n}else if(s2>s1){\\\nreturn [0,1,2];\\\n}else{\\\nreturn [0,2,1];\\\n}}})\")\n      }\n    } else {\n      code.push(\"ORDER})\")\n    }\n  }\n\n  //view.set(i0, ..., v):\n  code.push(\n\"proto.set=function \"+className+\"_set(\"+args.join(\",\")+\",v){\")\n  if(useGetters) {\n    code.push(\"return this.data.set(\"+index_str+\",v)}\")\n  } else {\n    code.push(\"return this.data[\"+index_str+\"]=v}\")\n  }\n\n  //view.get(i0, ...):\n  code.push(\"proto.get=function \"+className+\"_get(\"+args.join(\",\")+\"){\")\n  if(useGetters) {\n    code.push(\"return this.data.get(\"+index_str+\")}\")\n  } else {\n    code.push(\"return this.data[\"+index_str+\"]}\")\n  }\n\n  //view.index:\n  code.push(\n    \"proto.index=function \"+className+\"_index(\", args.join(), \"){return \"+index_str+\"}\")\n\n  //view.hi():\n  code.push(\"proto.hi=function \"+className+\"_hi(\"+args.join(\",\")+\"){return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return [\"(typeof i\",i,\"!=='number'||i\",i,\"<0)?this.shape[\", i, \"]:i\", i,\"|0\"].join(\"\")\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"this.stride[\"+i + \"]\"\n    }).join(\",\")+\",this.offset)}\")\n\n  //view.lo():\n  var a_vars = indices.map(function(i) { return \"a\"+i+\"=this.shape[\"+i+\"]\" })\n  var c_vars = indices.map(function(i) { return \"c\"+i+\"=this.stride[\"+i+\"]\" })\n  code.push(\"proto.lo=function \"+className+\"_lo(\"+args.join(\",\")+\"){var b=this.offset,d=0,\"+a_vars.join(\",\")+\",\"+c_vars.join(\",\"))\n  for(var i=0; i<dimension; ++i) {\n    code.push(\n\"if(typeof i\"+i+\"==='number'&&i\"+i+\">=0){\\\nd=i\"+i+\"|0;\\\nb+=c\"+i+\"*d;\\\na\"+i+\"-=d}\")\n  }\n  code.push(\"return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return \"a\"+i\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"c\"+i\n    }).join(\",\")+\",b)}\")\n\n  //view.step():\n  code.push(\"proto.step=function \"+className+\"_step(\"+args.join(\",\")+\"){var \"+\n    indices.map(function(i) {\n      return \"a\"+i+\"=this.shape[\"+i+\"]\"\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"b\"+i+\"=this.stride[\"+i+\"]\"\n    }).join(\",\")+\",c=this.offset,d=0,ceil=Math.ceil\")\n  for(var i=0; i<dimension; ++i) {\n    code.push(\n\"if(typeof i\"+i+\"==='number'){\\\nd=i\"+i+\"|0;\\\nif(d<0){\\\nc+=b\"+i+\"*(a\"+i+\"-1);\\\na\"+i+\"=ceil(-a\"+i+\"/d)\\\n}else{\\\na\"+i+\"=ceil(a\"+i+\"/d)\\\n}\\\nb\"+i+\"*=d\\\n}\")\n  }\n  code.push(\"return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return \"a\" + i\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"b\" + i\n    }).join(\",\")+\",c)}\")\n\n  //view.transpose():\n  var tShape = new Array(dimension)\n  var tStride = new Array(dimension)\n  for(var i=0; i<dimension; ++i) {\n    tShape[i] = \"a[i\"+i+\"]\"\n    tStride[i] = \"b[i\"+i+\"]\"\n  }\n  code.push(\"proto.transpose=function \"+className+\"_transpose(\"+args+\"){\"+\n    args.map(function(n,idx) { return n + \"=(\" + n + \"===undefined?\" + idx + \":\" + n + \"|0)\"}).join(\";\"),\n    \"var a=this.shape,b=this.stride;return new \"+className+\"(this.data,\"+tShape.join(\",\")+\",\"+tStride.join(\",\")+\",this.offset)}\")\n\n  //view.pick():\n  code.push(\"proto.pick=function \"+className+\"_pick(\"+args+\"){var a=[],b=[],c=this.offset\")\n  for(var i=0; i<dimension; ++i) {\n    code.push(\"if(typeof i\"+i+\"==='number'&&i\"+i+\">=0){c=(c+this.stride[\"+i+\"]*i\"+i+\")|0}else{a.push(this.shape[\"+i+\"]);b.push(this.stride[\"+i+\"])}\")\n  }\n  code.push(\"var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}\")\n\n  //Add return statement\n  code.push(\"return function construct_\"+className+\"(data,shape,stride,offset){return new \"+className+\"(data,\"+\n    indices.map(function(i) {\n      return \"shape[\"+i+\"]\"\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"stride[\"+i+\"]\"\n    }).join(\",\")+\",offset)}\")\n\n  //Compile procedure\n  var procedure = new Function(\"CTOR_LIST\", \"ORDER\", code.join(\"\\n\"))\n  return procedure(CACHED_CONSTRUCTORS[dtype], order)\n}\n\nfunction arrayDType(data) {\n  if(isBuffer(data)) {\n    return \"buffer\"\n  }\n  if(hasTypedArrays) {\n    switch(Object.prototype.toString.call(data)) {\n      case \"[object Float64Array]\":\n        return \"float64\"\n      case \"[object Float32Array]\":\n        return \"float32\"\n      case \"[object Int8Array]\":\n        return \"int8\"\n      case \"[object Int16Array]\":\n        return \"int16\"\n      case \"[object Int32Array]\":\n        return \"int32\"\n      case \"[object Uint8Array]\":\n        return \"uint8\"\n      case \"[object Uint16Array]\":\n        return \"uint16\"\n      case \"[object Uint32Array]\":\n        return \"uint32\"\n      case \"[object Uint8ClampedArray]\":\n        return \"uint8_clamped\"\n    }\n  }\n  if(Array.isArray(data)) {\n    return \"array\"\n  }\n  return \"generic\"\n}\n\nvar CACHED_CONSTRUCTORS = {\n  \"float32\":[],\n  \"float64\":[],\n  \"int8\":[],\n  \"int16\":[],\n  \"int32\":[],\n  \"uint8\":[],\n  \"uint16\":[],\n  \"uint32\":[],\n  \"array\":[],\n  \"uint8_clamped\":[],\n  \"buffer\":[],\n  \"generic\":[]\n}\n\n;(function() {\n  for(var id in CACHED_CONSTRUCTORS) {\n    CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1))\n  }\n});\n\nfunction wrappedNDArrayCtor(data, shape, stride, offset) {\n  if(data === undefined) {\n    var ctor = CACHED_CONSTRUCTORS.array[0]\n    return ctor([])\n  } else if(typeof data === \"number\") {\n    data = [data]\n  }\n  if(shape === undefined) {\n    shape = [ data.length ]\n  }\n  var d = shape.length\n  if(stride === undefined) {\n    stride = new Array(d)\n    for(var i=d-1, sz=1; i>=0; --i) {\n      stride[i] = sz\n      sz *= shape[i]\n    }\n  }\n  if(offset === undefined) {\n    offset = 0\n    for(var i=0; i<d; ++i) {\n      if(stride[i] < 0) {\n        offset -= (shape[i]-1)*stride[i]\n      }\n    }\n  }\n  var dtype = arrayDType(data)\n  var ctor_list = CACHED_CONSTRUCTORS[dtype]\n  while(ctor_list.length <= d+1) {\n    ctor_list.push(compileConstructor(dtype, ctor_list.length-1))\n  }\n  var ctor = ctor_list[d+1]\n  return ctor(data, shape, stride, offset)\n}\n\nmodule.exports = wrappedNDArrayCtor\n","(function (root, factory) {\n    if (typeof exports === 'object') {\n        module.exports = factory();\n    } else if (typeof define === 'function' && define.amd) {\n        define([], factory);\n    } else {\n        root.urltemplate = factory();\n    }\n}(this, function () {\n  /**\n   * @constructor\n   */\n  function UrlTemplate() {\n  }\n\n  /**\n   * @private\n   * @param {string} str\n   * @return {string}\n   */\n  UrlTemplate.prototype.encodeReserved = function (str) {\n    return str.split(/(%[0-9A-Fa-f]{2})/g).map(function (part) {\n      if (!/%[0-9A-Fa-f]/.test(part)) {\n        part = encodeURI(part).replace(/%5B/g, '[').replace(/%5D/g, ']');\n      }\n      return part;\n    }).join('');\n  };\n\n  /**\n   * @private\n   * @param {string} str\n   * @return {string}\n   */\n  UrlTemplate.prototype.encodeUnreserved = function (str) {\n    return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {\n      return '%' + c.charCodeAt(0).toString(16).toUpperCase();\n    });\n  }\n\n  /**\n   * @private\n   * @param {string} operator\n   * @param {string} value\n   * @param {string} key\n   * @return {string}\n   */\n  UrlTemplate.prototype.encodeValue = function (operator, value, key) {\n    value = (operator === '+' || operator === '#') ? this.encodeReserved(value) : this.encodeUnreserved(value);\n\n    if (key) {\n      return this.encodeUnreserved(key) + '=' + value;\n    } else {\n      return value;\n    }\n  };\n\n  /**\n   * @private\n   * @param {*} value\n   * @return {boolean}\n   */\n  UrlTemplate.prototype.isDefined = function (value) {\n    return value !== undefined && value !== null;\n  };\n\n  /**\n   * @private\n   * @param {string}\n   * @return {boolean}\n   */\n  UrlTemplate.prototype.isKeyOperator = function (operator) {\n    return operator === ';' || operator === '&' || operator === '?';\n  };\n\n  /**\n   * @private\n   * @param {Object} context\n   * @param {string} operator\n   * @param {string} key\n   * @param {string} modifier\n   */\n  UrlTemplate.prototype.getValues = function (context, operator, key, modifier) {\n    var value = context[key],\n        result = [];\n\n    if (this.isDefined(value) && value !== '') {\n      if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n        value = value.toString();\n\n        if (modifier && modifier !== '*') {\n          value = value.substring(0, parseInt(modifier, 10));\n        }\n\n        result.push(this.encodeValue(operator, value, this.isKeyOperator(operator) ? key : null));\n      } else {\n        if (modifier === '*') {\n          if (Array.isArray(value)) {\n            value.filter(this.isDefined).forEach(function (value) {\n              result.push(this.encodeValue(operator, value, this.isKeyOperator(operator) ? key : null));\n            }, this);\n          } else {\n            Object.keys(value).forEach(function (k) {\n              if (this.isDefined(value[k])) {\n                result.push(this.encodeValue(operator, value[k], k));\n              }\n            }, this);\n          }\n        } else {\n          var tmp = [];\n\n          if (Array.isArray(value)) {\n            value.filter(this.isDefined).forEach(function (value) {\n              tmp.push(this.encodeValue(operator, value));\n            }, this);\n          } else {\n            Object.keys(value).forEach(function (k) {\n              if (this.isDefined(value[k])) {\n                tmp.push(this.encodeUnreserved(k));\n                tmp.push(this.encodeValue(operator, value[k].toString()));\n              }\n            }, this);\n          }\n\n          if (this.isKeyOperator(operator)) {\n            result.push(this.encodeUnreserved(key) + '=' + tmp.join(','));\n          } else if (tmp.length !== 0) {\n            result.push(tmp.join(','));\n          }\n        }\n      }\n    } else {\n      if (operator === ';') {\n        result.push(this.encodeUnreserved(key));\n      } else if (value === '' && (operator === '&' || operator === '?')) {\n        result.push(this.encodeUnreserved(key) + '=');\n      } else if (value === '') {\n        result.push('');\n      }\n    }\n    return result;\n  };\n\n  /**\n   * @param {string} template\n   * @return {function(Object):string}\n   */\n  UrlTemplate.prototype.parse = function (template) {\n    var that = this;\n    var operators = ['+', '#', '.', '/', ';', '?', '&'];\n\n    return {\n      expand: function (context) {\n        return template.replace(/\\{([^\\{\\}]+)\\}|([^\\{\\}]+)/g, function (_, expression, literal) {\n          if (expression) {\n            var operator = null,\n                values = [];\n\n            if (operators.indexOf(expression.charAt(0)) !== -1) {\n              operator = expression.charAt(0);\n              expression = expression.substr(1);\n            }\n\n            expression.split(/,/g).forEach(function (variable) {\n              var tmp = /([^:\\*]*)(?::(\\d+)|(\\*))?/.exec(variable);\n              values.push.apply(values, that.getValues(context, operator, tmp[1], tmp[2] || tmp[3]));\n            });\n\n            if (operator && operator !== '+') {\n              var separator = ',';\n\n              if (operator === '?') {\n                separator = '&';\n              } else if (operator !== '#') {\n                separator = operator;\n              }\n              return (values.length !== 0 ? operator : '') + values.join(separator);\n            } else {\n              return values.join(',');\n            }\n          } else {\n            return that.encodeReserved(literal);\n          }\n        });\n      }\n    };\n  };\n\n  return new UrlTemplate();\n}));\n","export {DOMAIN, COVERAGE, COVERAGECOLLECTION} from 'covutils'\r\nexport const LINKRELPREFIX = 'http://www.iana.org/assignments/relation/'","export {minMax, indicesOfNearest, indexOfNearest} from 'covutils'\r\n\r\nconst PREFIX = 'https://covjson.org/def/'\r\nexport const CORE_PREFIX = PREFIX + 'core#'\r\nexport const DOMAINTYPES_PREFIX = PREFIX + 'domainTypes#'\r\n\r\n/**\r\n * @ignore\r\n */\r\nexport function assert (condition, message) {\r\n  if (!condition) {\r\n    message = message || 'Assertion failed'\r\n    throw new Error(message)\r\n  }\r\n}\r\n\r\n/**\r\n * @ignore\r\n */\r\nexport function shallowcopy (obj) {\r\n  let copy = Object.create(Object.getPrototypeOf(obj))\r\n  for (let prop in obj) {\r\n    copy[prop] = obj[prop]\r\n  }\r\n  return copy\r\n}\r\n\r\n/**\r\n * Extracts all the directly included namespaces from the `@context` field,\r\n * not following remote JSON-LD contexts.\r\n * \r\n * @ignore\r\n * @param doc A JSON-LD document. \r\n * @returns {Map<string,string>} \r\n */\r\nexport function getNamespacePrefixes (doc) {\r\n  let context = doc['@context']\r\n  if (!context) {\r\n    return\r\n  }\r\n  if (!Array.isArray(context)) {\r\n    context = [context]\r\n  }\r\n  let prefixes = new Map()\r\n  for (let item of context) {\r\n    if (typeof item === 'string') {\r\n      continue\r\n    }\r\n    for (let key of Object.keys(item)) {\r\n      if (typeof item[key] === 'string') {\r\n        prefixes.set(key, item[key])\r\n      }\r\n    }\r\n  }\r\n  return prefixes\r\n}","export const MEDIATYPE = {\r\n  COVJSON: 'application/prs.coverage+json',\r\n  JSONLD: 'application/ld+json',\r\n  JSON: 'application/json',\r\n  TEXT: 'text/plain'\r\n}\r\n\r\nexport const EXT = {\r\n  COVJSON: '.covjson'\r\n}\r\n\r\nimport {CORE_PREFIX} from './util.js'\r\nexport const COVJSON_PROFILE_STANDALONE = CORE_PREFIX + 'standalone'\r\n\r\n/**\r\n * Returns an Accept header value for requesting CoverageJSON documents.\r\n * \r\n * @param {bool} standalone Whether to include the standalone profile of CoverageJSON or not.\r\n */\r\nexport function getAcceptHeader (standalone) {\r\n  let covjsonProfile = standalone ? '; profile=\"' + COVJSON_PROFILE_STANDALONE + '\"' : ''\r\n  let accept =\r\n    MEDIATYPE.COVJSON + covjsonProfile + '; q=1.0, ' + \r\n    MEDIATYPE.JSONLD + '; q=0.1, ' + \r\n    MEDIATYPE.JSON + '; q=0.1'\r\n  return accept\r\n}\r\n\r\n/**\r\n * Checks if a media type matches any given media types, ignoring any parameters. \r\n * \r\n * @param {string} mediaType The media type.\r\n * @param {string|Array} matchingMediaTypes The media type(s) to match against.\r\n * @return {bool} True if there is a match.\r\n */\r\nexport function matchesMediaTypes (mediaType, matchingMediaTypes) {\r\n  if (!Array.isArray(matchingMediaTypes)) {\r\n    matchingMediaTypes = [matchingMediaTypes]\r\n  }\r\n  return matchingMediaTypes.some(t => mediaType.indexOf(t) === 0)\r\n}\r\n","import {getAcceptHeader} from './http-common.js'\r\n\r\n/**\r\n * See reader.js#load for docs.\r\n * \r\n * Browser implementation.\r\n */\r\nexport function load (url, options = {}, responseType='arraybuffer') {\r\n  if (['arraybuffer', 'text'].indexOf(responseType) === -1) {\r\n    throw new Error()\r\n  }\r\n  let headers = options.headers || {}\r\n  return new Promise((resolve, reject) => {\r\n    var req = new XMLHttpRequest()\r\n    req.open('GET', url)\r\n    req.responseType = responseType\r\n    let accept = getAcceptHeader(options.eagerload)\r\n    req.setRequestHeader('Accept', accept)\r\n    if (headers) {\r\n      for (let header of Object.keys(headers)) {\r\n        req.setRequestHeader(header, headers[header])\r\n      }\r\n    }\r\n\r\n    req.addEventListener('load', () => {\r\n      try {\r\n        if (!(req.status >= 200 && req.status < 300 || req.status === 304)) { // as in jquery\r\n          reject(new Error('Resource \"' + url + '\" not found, HTTP status code: ' + req.status))\r\n          return\r\n        }\r\n        \r\n        let data\r\n        if (responseType === 'arraybuffer') {\r\n          if (window.TextDecoder) {\r\n            let t0 = new Date()\r\n            data = JSON.parse(new TextDecoder().decode(new DataView(req.response)))\r\n            console.log('JSON decoding: ' + (new Date()-t0) + 'ms')\r\n          } else {\r\n            // load again (from cache) to get correct response type\r\n            // Note we use 'text' and not 'json' as we want to throw parsing errors.\r\n            // With 'json', the response is just 'null'.\r\n            reject({responseType: 'text'})\r\n            return\r\n          }\r\n        } else {\r\n          let t0 = new Date()\r\n          data = JSON.parse(req.response)\r\n          console.log('JSON decoding (slow path): ' + (new Date()-t0) + 'ms')\r\n        }\r\n        let responseHeaders = parseResponseHeaders(req.getAllResponseHeaders())\r\n        resolve({\r\n          data,\r\n          headers: responseHeaders\r\n        })\r\n      } catch (e) {\r\n        reject(e)\r\n      }\r\n    })\r\n    req.addEventListener('error', () => {\r\n      reject(new Error('Network error loading resource at ' + url))\r\n    })\r\n\r\n    req.send()\r\n  }).catch(e => {\r\n    if (e.responseType) {\r\n      return load(url, headers, e.responseType)\r\n    } else {\r\n      throw e\r\n    }\r\n  })\r\n}\r\n\r\n/**\r\n * XmlHttpRequest's getAllResponseHeaders() method returns a string of response\r\n * headers according to the format described here:\r\n * http://www.w3.org/TR/XMLHttpRequest/#the-getallresponseheaders-method\r\n * This method parses that string into a user-friendly key/value pair object.\r\n * Header names are lower-cased.\r\n * \r\n * https://gist.github.com/monsur/706839\r\n */\r\nfunction parseResponseHeaders (headerStr) {\r\n  var headers = {};\r\n  if (!headerStr) {\r\n    return headers;\r\n  }\r\n  var headerPairs = headerStr.split('\\u000d\\u000a');\r\n  for (var i = 0; i < headerPairs.length; i++) {\r\n    var headerPair = headerPairs[i];\r\n    // Can't use split() here because it does the wrong thing\r\n    // if the header value has the string \": \" in it.\r\n    var index = headerPair.indexOf('\\u003a\\u0020');\r\n    if (index > 0) {\r\n      var key = headerPair.substring(0, index).toLowerCase();\r\n      var val = headerPair.substring(index + 2);\r\n      headers[key] = val;\r\n    }\r\n  }\r\n  return headers;\r\n}\r\n","var babelHelpers = {};\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n};\n\nexport var jsx = function () {\n  var REACT_ELEMENT_TYPE = typeof Symbol === \"function\" && Symbol.for && Symbol.for(\"react.element\") || 0xeac7;\n  return function createRawReactElement(type, props, key, children) {\n    var defaultProps = type && type.defaultProps;\n    var childrenLength = arguments.length - 3;\n\n    if (!props && childrenLength !== 0) {\n      props = {};\n    }\n\n    if (props && defaultProps) {\n      for (var propName in defaultProps) {\n        if (props[propName] === void 0) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    } else if (!props) {\n      props = defaultProps || {};\n    }\n\n    if (childrenLength === 1) {\n      props.children = children;\n    } else if (childrenLength > 1) {\n      var childArray = Array(childrenLength);\n\n      for (var i = 0; i < childrenLength; i++) {\n        childArray[i] = arguments[i + 3];\n      }\n\n      props.children = childArray;\n    }\n\n    return {\n      $$typeof: REACT_ELEMENT_TYPE,\n      type: type,\n      key: key === undefined ? null : '' + key,\n      ref: null,\n      props: props,\n      _owner: null\n    };\n  };\n}();\n\nexport var asyncToGenerator = function (fn) {\n  return function () {\n    var gen = fn.apply(this, arguments);\n    return new Promise(function (resolve, reject) {\n      function step(key, arg) {\n        try {\n          var info = gen[key](arg);\n          var value = info.value;\n        } catch (error) {\n          reject(error);\n          return;\n        }\n\n        if (info.done) {\n          resolve(value);\n        } else {\n          return Promise.resolve(value).then(function (value) {\n            return step(\"next\", value);\n          }, function (err) {\n            return step(\"throw\", err);\n          });\n        }\n      }\n\n      return step(\"next\");\n    });\n  };\n};\n\nexport var classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nexport var createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nexport var defineEnumerableProperties = function (obj, descs) {\n  for (var key in descs) {\n    var desc = descs[key];\n    desc.configurable = desc.enumerable = true;\n    if (\"value\" in desc) desc.writable = true;\n    Object.defineProperty(obj, key, desc);\n  }\n\n  return obj;\n};\n\nexport var defaults = function (obj, defaults) {\n  var keys = Object.getOwnPropertyNames(defaults);\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var value = Object.getOwnPropertyDescriptor(defaults, key);\n\n    if (value && value.configurable && obj[key] === undefined) {\n      Object.defineProperty(obj, key, value);\n    }\n  }\n\n  return obj;\n};\n\nexport var defineProperty = function (obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nexport var get = function get(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return get(parent, property, receiver);\n    }\n  } else if (\"value\" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n};\n\nexport var inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar _instanceof = function (left, right) {\n  if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n    return right[Symbol.hasInstance](left);\n  } else {\n    return left instanceof right;\n  }\n};\n\nexport var interopRequireDefault = function (obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n};\n\nexport var interopRequireWildcard = function (obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n};\n\nexport var newArrowCheck = function (innerThis, boundThis) {\n  if (innerThis !== boundThis) {\n    throw new TypeError(\"Cannot instantiate an arrow function\");\n  }\n};\n\nexport var objectDestructuringEmpty = function (obj) {\n  if (obj == null) throw new TypeError(\"Cannot destructure undefined\");\n};\n\nexport var objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nexport var possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nexport var selfGlobal = typeof global === \"undefined\" ? self : global;\n\nexport var set = function set(object, property, value, receiver) {\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent !== null) {\n      set(parent, property, value, receiver);\n    }\n  } else if (\"value\" in desc && desc.writable) {\n    desc.value = value;\n  } else {\n    var setter = desc.set;\n\n    if (setter !== undefined) {\n      setter.call(receiver, value);\n    }\n  }\n\n  return value;\n};\n\nexport var slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nexport var slicedToArrayLoose = function (arr, i) {\n  if (Array.isArray(arr)) {\n    return arr;\n  } else if (Symbol.iterator in Object(arr)) {\n    var _arr = [];\n\n    for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {\n      _arr.push(_step.value);\n\n      if (i && _arr.length === i) break;\n    }\n\n    return _arr;\n  } else {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n  }\n};\n\nexport var taggedTemplateLiteral = function (strings, raw) {\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n};\n\nexport var taggedTemplateLiteralLoose = function (strings, raw) {\n  strings.raw = raw;\n  return strings;\n};\n\nexport var temporalRef = function (val, name, undef) {\n  if (val === undef) {\n    throw new ReferenceError(name + \" is not defined - temporal dead zone\");\n  } else {\n    return val;\n  }\n};\n\nexport var temporalUndefined = {};\n\nexport var toArray = function (arr) {\n  return Array.isArray(arr) ? arr : Array.from(arr);\n};\n\nexport var toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\nbabelHelpers;\n\nexport { _typeof as typeof, _extends as extends, _instanceof as instanceof }","/**\r\n * @external {Parameter} https://github.com/Reading-eScience-Centre/coverage-jsapi/blob/master/Parameter.md\r\n * @external {Domain} https://github.com/Reading-eScience-Centre/coverage-jsapi/blob/master/Domain.md\r\n * @external {Range} https://github.com/Reading-eScience-Centre/coverage-jsapi/blob/master/Range.md\r\n */\r\n\r\nimport ndarray from 'ndarray'\r\nimport template from 'url-template'\r\n\r\nimport {minMax, subsetDomainByIndex, subsetByValue as subsetCoverageByValue, normalizeIndexSubsetConstraints} from 'covutils'\r\n\r\nimport {COVERAGE} from './constants.js'\r\nimport {shallowcopy, getNamespacePrefixes, CORE_PREFIX, DOMAINTYPES_PREFIX} from './util.js'\r\n\r\n  \r\n  \r\n//NO FILE EXTENSION, to work around JSPM bug in handling package.json's \"browser\" field\r\n//see https://github.com/jspm/jspm-cli/issues/1062#issuecomment-170342414\r\nimport {load} from './http'\r\n\r\n/** \r\n * Wraps a CoverageJSON Coverage object as a Coverage API object.\r\n * \r\n * @see https://github.com/Reading-eScience-Centre/coverage-jsapi\r\n */\r\nexport default class Coverage {\r\n  \r\n  /**\r\n   * Create a Coverage instance.\r\n   * \r\n   * @param {Object} covjson A CoverageJSON Coverage object.\r\n   * @param {Object} [options] \r\n   * @param {boolean} [options.cacheRanges]\r\n   *   If true, then any range that was loaded remotely is cached.\r\n   *   (The domain is always cached.)\r\n   * @param {Array} [options.referencing]\r\n   *   Referencing info to use (e.g. from containing collection).                        \r\n   */\r\n  constructor (covjson, options) {\r\n    this._covjson = covjson\r\n    \r\n    /**\r\n     * The constant \"Coverage\".\r\n     * \r\n     * @type {string}\r\n     */\r\n    this.type = COVERAGE\r\n    \r\n    /**\r\n     * JSON-LD document\r\n     * \r\n     * @type {Object}\r\n     */\r\n    this.ld = {}\r\n    \r\n    this._exposeLd(covjson)\r\n    \r\n    this.prefixes = getNamespacePrefixes(this.ld)\r\n    \r\n    /**\r\n     * The options object that was passed in to the constructor. \r\n     * \r\n     * @type {Object} \r\n     */\r\n    this.options = options ? shallowcopy(options) : {}\r\n    \r\n    /** \r\n     * ID of the coverage.\r\n     * \r\n     * @type {string|undefined} \r\n     */\r\n    this.id = covjson.id\r\n    \r\n    /**\r\n     * A Map from key to {@link Parameter} object.\r\n     * The key is a short alias of a {@link Parameter}, typically what is called a \"variable name\" or similar.\r\n     * \r\n     * @type {Map<string,Parameter>}\r\n     */\r\n    this.parameters = new Map()\r\n    for (let key of Object.keys(covjson.parameters)) {\r\n      transformParameter(covjson.parameters, key)\r\n      this.parameters.set(key, covjson.parameters[key])\r\n    }\r\n            \r\n    let domainType\r\n    if (typeof this._covjson.domain === 'string') {\r\n      domainType = this._covjson.domainType\r\n    } else {\r\n      domainType = this._covjson.domain.domainType || this._covjson.domainType\r\n    }\r\n    if (domainType && domainType.indexOf(':') === -1) {\r\n      domainType = DOMAINTYPES_PREFIX + domainType\r\n    }\r\n\r\n    /**\r\n     * If defined, then the coverage has a domain that follows the given domain type,\r\n     * either a full URI or a namespace-prefixed term. (See .prefixes)\r\n     *  \r\n     * @type {string|undefined} \r\n     */\r\n    this.domainType = domainType\r\n    \r\n    this._updateLoadStatus()\r\n  }\r\n    \r\n  _updateLoadStatus () {\r\n    let isLoaded = prop => typeof prop === 'object' \r\n    let domainLoaded = isLoaded(this._covjson.domain)\r\n    let rangesLoaded = Object.keys(this._covjson.ranges).every(key => isLoaded(this._covjson.ranges[key]))\r\n    \r\n    /**\r\n     * A boolean which indicates whether all coverage data is already loaded in memory.\r\n     * If true then this typically means that calls to .loadDomain(), .loadRange(),\r\n     * .loadRanges(), .subsetByIndex(), and .subsetByValue() will not invoke a network request.\r\n     * \r\n     * @type {boolean}\r\n     */\r\n    this.loaded = domainLoaded && rangesLoaded\r\n  }\r\n  \r\n  _exposeLd (covjson) {\r\n    if (!covjson['@context']) {\r\n      // no LD love here...\r\n      return\r\n    }\r\n    // make a deep copy since the object gets modified in-place later\r\n    // but first, remove domain and range which may be embedded\r\n    let copy = shallowcopy(covjson)\r\n    delete copy.domain\r\n    delete copy.ranges\r\n    this.ld = JSON.parse(JSON.stringify(copy))\r\n  }\r\n    \r\n  /**\r\n   * Returns a Promise succeeding with a {@link Domain} object.\r\n   * \r\n   * @return {Promise<Domain>}\r\n   */\r\n  loadDomain () {\r\n    let domainOrUrl = this._covjson.domain\r\n    if (this._domainPromise) return this._domainPromise\r\n    let promise\r\n    if (typeof domainOrUrl === 'object') {\r\n      let domain = domainOrUrl\r\n      transformDomain(domain, this.options.referencing, this.domainType)\r\n      promise = Promise.resolve(domain)\r\n    } else {\r\n      let url = domainOrUrl\r\n      promise = load(url).then(result => {\r\n        let domain = result.data\r\n        transformDomain(domain, this.options.referencing, this.domainType)\r\n        this._covjson.domain = domain\r\n        this._updateLoadStatus()\r\n        return domain\r\n      })\r\n    }\r\n    /* The promise gets cached so that the domain is not loaded twice remotely.\r\n     * This might otherwise happen when loadDomain and loadRange is used\r\n     * with Promise.all(). Remember that loadRange also invokes loadDomain.\r\n     */ \r\n    this._domainPromise = promise\r\n    return promise\r\n  }\r\n  \r\n  /**\r\n   * Returns a Promise succeeding with a {@link Range} object.\r\n   * \r\n   * Note that this method implicitly loads the domain as well. \r\n   * \r\n   * @example\r\n   * cov.loadRange('salinity').then(function (sal) {\r\n   *   // work with Range object\r\n   * }).catch(function (e) {\r\n   *   // there was an error when loading the range\r\n   *   console.log(e.message)\r\n   * }) \r\n   * @param {string} paramKey The key of the Parameter for which to load the range.\r\n   * @return {Promise<Range>} A Promise object which loads the requested range data and succeeds with a Range object.\r\n   */\r\n  loadRange (paramKey) {\r\n    return loadRangeFn(this)(paramKey)\r\n  }\r\n  \r\n  /**\r\n   * Returns the requested range data as a Promise.\r\n   * \r\n   * Note that this method implicitly loads the domain as well. \r\n   * \r\n   * @example\r\n   * cov.loadRanges(['salinity','temp']).then(function (ranges) {\r\n   *   // work with Map object\r\n   *   console.log(ranges.get('salinity').values)\r\n   * }).catch(function (e) {\r\n   *   // there was an error when loading the range data\r\n   *   console.log(e)\r\n   * }) \r\n   * @param {iterable<string>} [paramKeys] An iterable of parameter keys for which to load the range data. If not given, loads all range data.\r\n   * @return {Promise<Map<string,Range>>} A Promise object which loads the requested range data and succeeds with a Map object.\r\n   */\r\n  loadRanges (paramKeys) {\r\n    return loadRangesFn(this)(paramKeys)\r\n  }\r\n  \r\n  /**\r\n   * Returns a Promise object which provides a copy of this Coverage object\r\n   * with the domain subsetted by the given indices specification.\r\n   * \r\n   * Note that the coverage type and/or domain type of the resulting coverage\r\n   * may be different than in the original coverage.\r\n   * \r\n   * Note that the subsetted ranges are a view over the original ranges, meaning\r\n   * that no copying is done but also no memory is released if the original\r\n   * coverage is garbage collected.\r\n   * \r\n   * @example\r\n   * cov.subsetByIndex({t: 4, z: {start: 10, stop: 20} }).then(function(subsetCov) {\r\n   *   // work with subsetted coverage\r\n   * })\r\n   * @param {Object} constraints An object which describes the subsetting constraints.\r\n   *   Every property of it refers to an axis name as defined in Domain.names,\r\n   *   and its value must either be an integer\r\n   *   or an object with start, stop, and optionally step (defaults to 1) properties\r\n   *   whose values are integers.\r\n   *   Properties that have the values undefined or null are ignored. \r\n   *   All integers must be non-negative, step must not be zero.\r\n   *   An integer constrains the axis to the given index,\r\n   *   a start/stop/step object to a range of indices:\r\n   *   If step=1, this includes all indices starting at start and ending at stop (exclusive);\r\n   *   if step>1, all indices start, start + step, ..., start + (q + r - 1) step where \r\n   *   q and r are the quotient and remainder obtained by dividing stop - start by step.\r\n   * @returns {Promise<Coverage>} A Promise object with the subsetted coverage object as result.\r\n   */\r\n  subsetByIndex (constraints) {\r\n    return subsetByIndexFn(this)(constraints)\r\n  }\r\n  \r\n  /**\r\n   * Returns a Promise object which provides a copy of this Coverage object\r\n   * with the domain subsetted by the given value specification.\r\n   * \r\n   * Note that the coverage type and/or domain type of the resulting coverage\r\n   * may be different than in the original coverage.\r\n   * \r\n   * Note that the subsetted ranges are a view over the original ranges, meaning\r\n   * that no copying is done but also no memory is released if the original\r\n   * coverage is garbage collected.\r\n   * \r\n   * @example\r\n   * cov.subsetByValue({\r\n   *   t: '2015-01-01T01:00:00',\r\n   *   z: {start: -10, stop: -5} \r\n   * }).then(function(subsetCov) {\r\n   *   // work with subsetted coverage\r\n   * })\r\n   * @example\r\n   * cov.subsetByValue({z: {target: -10} }).then(function(subsetCov) {\r\n   *   // work with subsetted coverage\r\n   * }\r\n   * @param {Object} constraints An object which describes the subsetting constraints.\r\n   *  Every property of it refers to an axis name as defined in Domain.names,\r\n   *  and its value must either be a number or string, or,\r\n   *  if the axis has an ordering relation, an object with start and stop properties\r\n   *  whose values are numbers or strings, or an object with a target property\r\n   *  whose value is a number or string.\r\n   *  Properties that have the values undefined or null are ignored.\r\n   *  A number or string constrains the axis to exactly the given value,\r\n   *  a start/stop object to the values intersecting the extent,\r\n   *  and a target object to the value closest to the given value.\r\n   * @returns {Promise<Coverage>} A Promise object with the subsetted coverage object as result.\r\n   */\r\n  subsetByValue (constraints) {\r\n    return subsetCoverageByValue(this, constraints)\r\n  }\r\n}\r\n\r\nfunction getRangeAxisOrder (domain, range) {\r\n  if (!domain) {\r\n    return range._axisNames\r\n  }\r\n  // backwards-compatibility, in the future the range always has an explicit axis ordering\r\n  let needsRangeAxisOrder = [...domain.axes.values()].filter(axis => axis.values.length > 1).length > 1\r\n  \r\n  // domain is checked for backwards-compatibility\r\n  let axisOrder = domain._rangeAxisOrder || range._axisNames\r\n  if (needsRangeAxisOrder && !axisOrder) {\r\n    throw new Error('Range axis order missing')\r\n  }\r\n  axisOrder = axisOrder || [...domain.axes.keys()]\r\n  return axisOrder\r\n}\r\n\r\nfunction getRangeShapeArray (domain, range) {\r\n  if (!domain) {\r\n    return range._shape\r\n  }\r\n  // mostly backwards-compatibility, in the future this just returns range._shape\r\n  let axisOrder = getRangeAxisOrder(domain, range)\r\n  let shape = axisOrder.map(k => domain.axes.get(k).values.length)\r\n  if (range._shape) {\r\n    let matchesDomain = range._shape.length === shape.length && range._shape.every((v,i) => v === shape[i])\r\n    if (!matchesDomain) {\r\n      throw new Error('range.shape must match domain axis sizes')\r\n    }\r\n  }\r\n  return shape\r\n}\r\n\r\nfunction loadRangesFn (cov) {\r\n  return paramKeys => {\r\n    if (paramKeys === undefined) paramKeys = cov.parameters.keys()\r\n    paramKeys = Array.from(paramKeys)\r\n    return Promise.all(paramKeys.map(k => cov.loadRange(k))).then(ranges => {\r\n      let map = new Map()\r\n      for (let i=0; i < paramKeys.length; i++) {\r\n        map.set(paramKeys[i], ranges[i])\r\n      }\r\n      return map\r\n    })\r\n  }\r\n}\r\n\r\nfunction loadRangeFn (cov, globalConstraints) {\r\n  return paramKey => {\r\n    // Since the shape of the range array is derived from the domain, it has to be loaded as well.\r\n    return cov.loadDomain().then(() => {\r\n      let rangeOrUrl = cov._covjson.ranges[paramKey]\r\n      if (typeof rangeOrUrl === 'object') {\r\n        let rawRange = rangeOrUrl\r\n        // we need the original domain here, not a potentially subsetted one,\r\n        // therefore we access cov._covjson directly\r\n        // this legacy code will disappear once the old range format is not supported anymore\r\n        return doLoadRange(cov, paramKey, rawRange, cov._covjson.domain, globalConstraints)\r\n      } else {\r\n        let url = rangeOrUrl\r\n        return load(url).then(result => {\r\n          let rawRange = result.data\r\n          return doLoadRange(cov, paramKey, rawRange, cov._covjson.domain, globalConstraints)\r\n        })\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\nfunction doLoadRange (cov, paramKey, range, domain, globalConstraints={}) {\r\n  globalConstraints = normalizeIndexSubsetConstraints(domain, globalConstraints)\r\n  \r\n  if (range.type === 'NdArray' || range.type === 'Range') {\r\n    // if an NdArray, then we modify it in-place (only done the first time)\r\n    transformNdArrayRange(range, domain)\r\n    if (cov.options.cacheRanges) {\r\n      cov._covjson.ranges[paramKey] = range\r\n      cov._updateLoadStatus()\r\n    }\r\n    \r\n    let newrange = subsetNdArrayRangeByIndex(range, domain, globalConstraints)    \r\n    return Promise.resolve(newrange)\r\n    \r\n  } else if (range.type === 'TiledNdArray') {\r\n    return loadTiledNdArraySubset(range, globalConstraints)\r\n    \r\n  } else {\r\n    throw new Error('Unsupported: ' + range.type)\r\n  }\r\n}\r\n\r\n/**\r\n * \r\n * @param {object} range TiledNdArray range object\r\n * @param {object} constraints subsetting constraints\r\n * @returns {Promise<Range>}\r\n */\r\nfunction loadTiledNdArraySubset (range, constraints) {\r\n  let constraintsArr = range.axisNames.map(name => constraints[name])\r\n  \r\n  // step 1: select tileset with least network effort\r\n  let fillNulls = tileShape => tileShape.map((v,i) => v === null ? range.shape[i] : v)    \r\n  let tilesetsStats = range.tileSets.map(ts => getTilesetStats(fillNulls(ts.tileShape), constraintsArr))\r\n  let idxBestTileset = indexOfBestTileset(tilesetsStats)\r\n  let tileset = range.tileSets[idxBestTileset]\r\n  let tileShape = fillNulls(tileset.tileShape)\r\n      \r\n  // step 2: determine the tiles to load\r\n  let subsetTilesetAxes = []\r\n  for (let ax=0; ax < tileShape.length; ax++) {\r\n    let {start,stop,step} = constraintsArr[ax]\r\n    let tileSize = tileShape[ax]\r\n    \r\n    // the indices of the first and last tile containing the subsetting constraints\r\n    let tileStart = Math.floor(start / tileSize) // inclusive\r\n    let tileStop = Math.ceil(stop / tileSize) // exclusive\r\n    \r\n    let tilesetAxis = []\r\n    for (let t=tileStart; t < tileStop; t++) {\r\n      let mid = (t + 0.5) * tileSize\r\n      // regard the subset constraint as a list of [x,y) half-closed intervals and find out where 'mid' falls into\r\n      let iv = Math.floor((mid - start) / step)\r\n      \r\n      // start and end point of the interval in range index space\r\n      let ivStart = start + iv * step\r\n      let ivStop = start + (iv + 1) * step\r\n      \r\n      // tile start and end in range index space\r\n      let tileStartR = t * tileSize\r\n      let tileStopR = (t + 1) * tileSize\r\n      \r\n      // check if the start or end point of the interval lies within the tile\r\n      if (ivStart >= tileStartR || tileStopR <= ivStop) {\r\n        tilesetAxis.push(t)\r\n      }\r\n    }\r\n    subsetTilesetAxes.push(tilesetAxis)\r\n  }\r\n  \r\n  // step 3: create an empty ndarray of the subset shape that will be filled with tile data\r\n  // TODO check if only a single tile will be loaded and avoid copying data around in that case\r\n  let subsetShape = constraintsArr.map(({start,stop,step}) => Math.floor((stop - start) / step) + (stop - start) % step)\r\n  let subsetSize = subsetShape.reduce((l,r) => l*r)\r\n  let subsetNdArr = ndarray(new Array(subsetSize), subsetShape)\r\n  \r\n  // step 4: load tiles and fill subset ndarray\r\n  let urlTemplate = template.parse(tileset.urlTemplate)\r\n  let tiles = cartesianProduct(subsetTilesetAxes)\r\n  let promises = tiles.map(tile => {\r\n    let tileUrlVars = {}\r\n    tile.forEach((v,i) => tileUrlVars[range.axisNames[i]] = v)\r\n    let url = urlTemplate.expand(tileUrlVars)\r\n    return load(url).then(result => {\r\n      let tileRange = result.data\r\n      transformNdArrayRange(tileRange)\r\n      \r\n      // figure out which parts of the tile to copy into which part of the final ndarray\r\n      let tileOffsets = tile.map((v,i) => v * tileShape[i])\r\n      \r\n      // iterate all tile values and for each check if they are part of the subset\r\n      // TODO this code is probably quite slow, consider pre-compiling etc\r\n      let tileAxesSubsetIndices = []\r\n      for (let ax=0; ax < tileShape.length; ax++) {\r\n        let {start,stop,step} = constraintsArr[ax]\r\n        let tileAxisSize = tileShape[ax]\r\n        let tileAxisOffset = tileOffsets[ax]\r\n        let tileAxisSubsetIndices = []\r\n        let startIdx = 0\r\n        if (tileAxisOffset < start) {\r\n          startIdx = start - tileAxisOffset\r\n        }\r\n        let stopIdx = tileAxisSize\r\n        if (tileAxisOffset + stopIdx > stop) {\r\n          stopIdx = stop - tileAxisOffset\r\n        }\r\n        \r\n        for (let i=startIdx; i < stopIdx; i++) {\r\n          let idx = tileAxisOffset + i\r\n          if ((idx - start) % step === 0) {\r\n            tileAxisSubsetIndices.push(i)\r\n          }\r\n        }\r\n        tileAxesSubsetIndices.push(tileAxisSubsetIndices)\r\n      }\r\n      let tileSubsetIndices = cartesianProduct(tileAxesSubsetIndices)\r\n      for (let tileInd of tileSubsetIndices) {\r\n        let val = tileRange._ndarr.get(...tileInd)\r\n        let subsetInd = tileInd.map((i,ax) => {\r\n          let idx = tileOffsets[ax] + i\r\n          return Math.floor((idx - constraintsArr[ax].start) / constraintsArr[ax].step)\r\n        })\r\n        subsetNdArr.set(...subsetInd, val)\r\n      }\r\n    })\r\n  })\r\n  \r\n  // step 5: create and return the new range\r\n  return Promise.all(promises).then(() => {\r\n    let newrange = {\r\n      dataType: range.dataType,\r\n      get: createRangeGetFunction(subsetNdArr, range.axisNames),\r\n      _ndarr: subsetNdArr,\r\n      _axisNames: range.axisNames,\r\n      _shape: subsetShape\r\n    }\r\n    newrange.shape = new Map(range.axisNames.map((v,i) => [v, subsetNdArr.shape[i]]))\r\n    return newrange\r\n  })\r\n}\r\n\r\n/**\r\n * Return the cartesian product of the given arrays.\r\n * \r\n * @see http://stackoverflow.com/a/36234242\r\n */\r\nfunction cartesianProduct (arr) {\r\n  return arr.reduce((a,b) => a.map(x => b.map(y => x.concat(y))).reduce((a,b) => a.concat(b), []), [[]])\r\n}\r\n\r\n/**\r\n * Returns the number of tiles and values that have to be loaded, given a set of subsetting constraints.\r\n * \r\n * @param {Array<number>} tileShape\r\n * @param {Array<object>} constraints - start/stop/step subset constraints for each axis, stop is exclusive\r\n * @returns {number}\r\n */\r\nfunction getTilesetStats (tileShape, constraints) {\r\n  let tileCount = 1\r\n  for (let i=0; i < tileShape.length; i++) {\r\n    let {start, stop, step} = constraints[i]\r\n    let tileSize = tileShape[i]\r\n    \r\n    // the indices of the first and last tile containing the subsetting constraints\r\n    let tileStart = Math.floor(start / tileSize) // inclusive\r\n    let tileStop = Math.ceil(stop / tileSize) // exclusive\r\n    \r\n    // total number of values within the tiles containing the subsetting constraints\r\n    let nvalues = tileSize * (tileStop - tileStart)\r\n\r\n    // number of tiles that intersect with the subsetting constraints\r\n    tileCount *= Math.ceil(nvalues / (Math.max(step, tileSize)))\r\n  }\r\n  // the value count is an upper bound as it doesn't account for edge tiles that may be smaller\r\n  let valueCount = tileCount * tileShape.reduce((l,r) => l*r)\r\n  \r\n  return {tileCount, valueCount}\r\n}\r\n\r\n/**\r\n * Returns the index of the tileset with minimum network effort based on the given tileset statistics.\r\n * Effort here means a combination of number of requested tiles and values.\r\n * \r\n * @param {Array<object>} tilesetsStats\r\n * @returns {number} index of the tileset with minimum network effort\r\n */\r\nfunction indexOfBestTileset (tilesetsStats) {\r\n  // one tile request shall have an equal effort as receiving 1000 values\r\n  let tileValueRatio = 1000\r\n  let efforts = tilesetsStats.map(s => s.tileCount + s.valueCount / tileValueRatio)\r\n  let minEffortIdx = efforts.reduce((imin, x, i, arr) => x < arr[imin] ? i : imin, 0)\r\n  return minEffortIdx\r\n}\r\n\r\nfunction subsetNdArrayRangeByIndex (range, domain, constraints) {\r\n  let ndarr = range._ndarr\r\n        \r\n  // fast ndarray view\r\n  let axisNames = getRangeAxisOrder(domain, range)\r\n  let los = axisNames.map(name => constraints[name].start)\r\n  let his = axisNames.map(name => constraints[name].stop)\r\n  let steps = axisNames.map(name => constraints[name].step)\r\n  let newndarr = ndarr.hi(...his).lo(...los).step(...steps)\r\n  \r\n  let newrange = {\r\n    dataType: range.dataType,\r\n    get: createRangeGetFunction(newndarr, axisNames),\r\n    _ndarr: newndarr,\r\n    _axisNames: axisNames,\r\n    _shape: newndarr.shape\r\n  }\r\n  newrange.shape = new Map(axisNames.map((v,i) => [v, newndarr.shape[i]]))\r\n  return newrange\r\n}\r\n\r\nfunction subsetByIndexFn (cov, globalConstraints) {\r\n  return constraints => {\r\n    return cov.loadDomain().then(domain => {\r\n      constraints = normalizeIndexSubsetConstraints(domain, constraints)\r\n      let newdomain = subsetDomainByIndex(domain, constraints)\r\n      \r\n      let newGlobalConstraints = toGlobalSubsetConstraints(constraints, globalConstraints)\r\n      \r\n      // backwards-compatibility\r\n      if (domain._rangeAxisOrder) {\r\n        newdomain._rangeAxisOrder = domain._rangeAxisOrder\r\n      }\r\n      \r\n      // assemble everything to a new coverage\r\n      let newcov = {\r\n        _covjson: cov._covjson,\r\n        options: cov.options,\r\n        type: COVERAGE,\r\n        // TODO are the profiles still valid?\r\n        domainProfiles: cov.domainProfiles,\r\n        domainType: cov.domainType,\r\n        parameters: cov.parameters,\r\n        loadDomain: () => Promise.resolve(newdomain)\r\n      }\r\n      newcov.loadRange = loadRangeFn(newcov, newGlobalConstraints)\r\n      newcov.loadRanges = loadRangesFn(newcov)\r\n      newcov.subsetByIndex = subsetByIndexFn(newcov, newGlobalConstraints)\r\n      newcov.subsetByValue = subsetCoverageByValue.bind(null, newcov)\r\n      return newcov\r\n    })\r\n  }\r\n}\r\n\r\n/**\r\n * Currently unused, but may need in future.\r\n * This determines the best array type for categorical data which\r\n * doesn't have missing values.\r\n */\r\n/*\r\nfunction arrayType (validMin, validMax) {\r\n  let type\r\n  if (validMin !== undefined) {\r\n    if (validMin >= 0) {\r\n      if (validMax < Math.pow(2,8)) {\r\n        type = Uint8Array\r\n      } else if (validMax < Math.pow(2,16)) {\r\n        type = Uint16Array\r\n      } else if (validMax < Math.pow(2,32)) {\r\n        type = Uint32Array\r\n      } else {\r\n        type = Array\r\n      }\r\n    } else {\r\n      let max = Math.max(Math.abs(validMin), validMax)\r\n      if (max < Math.pow(2,8)) {\r\n        type = Int8Array\r\n      } else if (validMax < Math.pow(2,16)) {\r\n        type = Int16Array\r\n      } else if (validMax < Math.pow(2,32)) {\r\n        type = Int32Array\r\n      } else {\r\n        type = Array\r\n      }\r\n    }\r\n  } else {\r\n    type = Array\r\n  }\r\n  return type\r\n}\r\n*/\r\n\r\n/**\r\n * Transforms a CoverageJSON parameter to the Coverage API format, that is,\r\n * some elements are converted from objects to Maps. Transformation is made in-place.\r\n * \r\n * @param {Object} param The original parameter.\r\n * @access private\r\n */\r\nexport function transformParameter (params, key) {\r\n  if ('__transformDone' in params[key]) return\r\n  let param = params[key]\r\n  param.key = key\r\n  if (param.unit) {\r\n    if (typeof param.unit.symbol === 'string') {\r\n      param.unit.symbol = {\r\n        value: param.unit.symbol\r\n        // no type member, since the scheme is unknown\r\n      }\r\n    }\r\n  }\r\n  if (param.categoryEncoding) {\r\n    let map = new Map()\r\n    for (let category of Object.keys(param.categoryEncoding)) {\r\n      let vals = param.categoryEncoding[category]\r\n      if (!Array.isArray(vals)) {\r\n        vals = [vals]\r\n      }\r\n      map.set(category, vals)\r\n    }\r\n    param.categoryEncoding = map\r\n  }\r\n  param.__transformDone = true  \r\n}\r\n\r\n/**\r\n * Transforms a CoverageJSON NdArray range to the Coverage API format. Transformation is made in-place.\r\n * \r\n * @param {Object} range The original NdArray range.\r\n * @param {Object} [domain] The CoverageJSON domain object. \r\n * @return {Object} The transformed range.\r\n */\r\nfunction transformNdArrayRange (range, domain) {\r\n  if ('__transformDone' in range) return\r\n  \r\n  const values = range.values\r\n    \r\n  if (range.actualMin === undefined) {\r\n    let [min,max] = minMax(values)\r\n    if (min !== null) {\r\n      range.actualMin = min\r\n      range.actualMax = max\r\n    }\r\n  }\r\n  \r\n  // store the array as we will expose a Map on range.shape in the next step\r\n  if (range.shape) {\r\n    range._shape = range.shape\r\n  }\r\n  if (range.axisNames) {\r\n    // not part of public API\r\n    range._axisNames = range.axisNames\r\n    delete range.axisNames\r\n  }\r\n  \r\n  let axisNames = getRangeAxisOrder(domain, range)\r\n  let shapeArr = getRangeShapeArray(domain, range)\r\n  \r\n  let ndarr = ndarray(values, shapeArr)\r\n  range._ndarr = ndarr\r\n  range.get = createRangeGetFunction(ndarr, axisNames)\r\n  range.shape = new Map(axisNames.map((v,i) => [v, shapeArr[i]]))\r\n  \r\n  range.__transformDone = true  \r\n  return range\r\n}\r\n\r\n/**\r\n * \r\n * @param axisOrder An array of axis names.\r\n * @returns Function\r\n */\r\nfunction createRangeGetFunction (ndarr, axisOrder) {\r\n  // see below for slower reference version\r\n  let ndargs = ''\r\n  for (let i=0; i < axisOrder.length; i++) {\r\n    if (ndargs) ndargs += ','\r\n    ndargs += `'${axisOrder[i]}' in obj ? obj['${axisOrder[i]}'] : 0`\r\n  }\r\n  let fn = new Function('ndarr', `return function ndarrget (obj) { return ndarr.get(${ndargs}) }`)(ndarr)\r\n  return fn\r\n}\r\n\r\n/*\r\n * Reference version of createRangeGetFunction().\r\n * Around 50% slower (on Chrome 46) compared to precompiled version.\r\n * \r\nfunction createRangeGetFunction (ndarr, axisOrder) {\r\n  axisOrder = axisOrder.slice() // help the JIT (possibly..)\r\n  const axisCount = axisOrder.length\r\n  return obj => {\r\n    let indices = new Array(axisCount)\r\n    for (let i=0; i < axisCount; i++) {\r\n      indices[i] = axisOrder[i] in obj ? obj[axisOrder[i]] : 0\r\n    }\r\n    return ndarr.get(...indices)\r\n  }\r\n}\r\n*/\r\n\r\n/**\r\n * Transforms a CoverageJSON domain to the Coverage API format.\r\n * Transformation is made in-place.\r\n * \r\n * @param {Object} domain The original domain object.\r\n * @param {Array} [referencing] Referencing info to inject.\r\n * @return {Object} The transformed domain object.\r\n * @access private\r\n */\r\nexport function transformDomain (domain, referencing, domainType) {\r\n  if ('__transformDone' in domain) return\r\n  \r\n  domainType = domain.domainType || domainType\r\n  if (domainType && domainType.indexOf(':') === -1) {\r\n    domainType = DOMAINTYPES_PREFIX + domainType\r\n  }\r\n  domain.domainType = domainType\r\n\r\n  let axes = new Map() // axis name -> axis object\r\n  \r\n  for (let axisName of Object.keys(domain.axes)) {\r\n    axes.set(axisName, domain.axes[axisName])\r\n  }\r\n  domain.axes = axes\r\n  \r\n  // expand start/stop/num regular axes\r\n  // replace 1D numeric axis arrays with typed arrays for efficiency\r\n  for (let [key, axis] of axes) {\r\n    axis.key = key\r\n    \r\n    if (axis.dataType && axis.dataType.indexOf(':') === -1) {\r\n      axis.dataType = CORE_PREFIX + axis.dataType\r\n    }\r\n    \r\n    // TODO remove this if-block later, just here for backwards-compatibility \r\n    if (axis.components) {\r\n      axis.coordinates = axis.components\r\n    }\r\n    \r\n    if (!axis.coordinates) {\r\n      axis.coordinates = [key]\r\n    }\r\n    \r\n    // TODO remove this line later, just here for backwards-compatibility \r\n    axis.components = axis.coordinates\r\n    \r\n    \r\n    if ('start' in axis && 'stop' in axis && 'num' in axis) {\r\n      let arr = new Float64Array(axis.num)\r\n      let step\r\n      if (axis.num === 1) {\r\n        if (axis.start !== axis.stop) {\r\n          throw new Error('regular axis of length 1 must have equal start/stop values')\r\n        }\r\n        step = 0\r\n      } else {\r\n        step = (axis.stop - axis.start) / (axis.num - 1)\r\n      }\r\n      for (let i=0; i < axis.num; i++) {\r\n        arr[i] = axis.start + i * step\r\n      }\r\n      \r\n      axis.values = arr\r\n      delete axis.start\r\n      delete axis.stop\r\n      delete axis.num\r\n    }\r\n    \r\n    if (Array.isArray(axis.values) && typeof axis.values[0] === 'number') {\r\n      let arr = new Float64Array(axis.values.length)\r\n      for (let i=0; i < axis.values.length; i++) {\r\n        arr[i] = axis.values[i]\r\n      }\r\n      axis.values = arr\r\n    }\r\n    \r\n    axis.bounds = wrapBounds(axis)\r\n  }\r\n  \r\n  if (referencing) {\r\n    domain.referencing = referencing\r\n  }\r\n  \r\n  // TODO remove this later, just here for backwards-compatibility \r\n  for (let obj of domain.referencing) {\r\n    if (obj.components) {\r\n      obj.coordinates = obj.components\r\n    }\r\n  }\r\n  \r\n  if (domain.rangeAxisOrder) {\r\n    domain._rangeAxisOrder = domain.rangeAxisOrder\r\n    delete domain.rangeAxisOrder\r\n  }\r\n  \r\n  domain.__transformDone = true\r\n  \r\n  return domain\r\n}\r\n\r\n/**\r\n * Applies the local index subset constraints to the existing global constraints.\r\n * Both constraint objects must be normalized, that is, must contain the same axes\r\n * as start/stop/step objects.\r\n * \r\n * @example\r\n * var local = {x: {start: 0, stop: 50, step: 2}}\r\n * var global = {x: {start: 500, stop: 1000}}\r\n * var newGlobal = toGlobalSubsetConstraints(local, global)\r\n * // newGlobal == {x: {start: 500, stop: 550, step: 2}}\r\n * \r\n * @example\r\n * var local = {x: {start: 5, stop: 10, step: 2}} // 5, 7, 9\r\n * var global = {x: {start: 500, stop: 1000, step: 10}} // 500, 510, 520,...\r\n * var newGlobal = toGlobalSubsetConstraints(local, global) \r\n * // newGlobal == {x: {start: 550, stop: 600, step: 20}} // 550, 570, 590\r\n */\r\nfunction toGlobalSubsetConstraints (localConstraints, globalConstraints={}) {\r\n  let res = {}\r\n  for (let axis of Object.keys(localConstraints)) {\r\n    let local = localConstraints[axis]\r\n    let {start: globalStart=0, step: globalStep=1} = globalConstraints[axis] || {}\r\n    res[axis] = {\r\n      start: globalStart + globalStep*local.start,\r\n      stop: globalStart + globalStep*local.stop,\r\n      step: globalStep * local.step\r\n    }\r\n  }\r\n  return res\r\n}\r\n\r\nfunction wrapBounds (axis) {\r\n  if (axis.bounds) {\r\n    let bounds = axis.bounds\r\n    return {\r\n      get: i => [bounds[2*i], bounds[2*i + 1]]\r\n    }\r\n  }\r\n}\r\n","/**\r\n * @external {CollectionQuery} https://github.com/Reading-eScience-Centre/coverage-jsapi/blob/master/CoverageCollectionQuery.md\r\n */\r\n\r\nimport {COVERAGECOLLECTION} from './constants.js'\r\nimport {default as Coverage, transformDomain, transformParameter} from './Coverage.js'\r\nimport {shallowcopy, getNamespacePrefixes, DOMAINTYPES_PREFIX} from './util.js'\r\nimport {CollectionQuery} from 'covutils'\r\n\r\n/** \r\n * Wraps a CoverageJSON Collection object as a CoverageCollection API object.\r\n * \r\n * @see https://github.com/Reading-eScience-Centre/coverage-jsapi\r\n * \r\n */\r\nexport default class CoverageCollection {\r\n  /**\r\n   * @param {Object} covjson The CoverageJSON Collection document.\r\n   */\r\n  constructor(covjson) {\r\n    /**\r\n     * The constant \"CoverageCollection\".\r\n     * \r\n     * @type {string}\r\n     */\r\n    this.type = COVERAGECOLLECTION\r\n    \r\n    /**\r\n     * JSON-LD document\r\n     * \r\n     * @type {Object}\r\n     */\r\n    this.ld = {}\r\n    \r\n    this._exposeLd(covjson)\r\n    \r\n    this.prefixes = getNamespacePrefixes(this.ld)\r\n    \r\n    /** \r\n     * ID of the coverage collection.\r\n     * \r\n     * @type {string|undefined} \r\n     */\r\n    this.id = covjson.id\r\n    \r\n    \r\n    let domainType = covjson.domainType\r\n    if (domainType && domainType.indexOf(':') === -1) {\r\n      domainType = DOMAINTYPES_PREFIX + domainType\r\n    }\r\n\r\n    /**\r\n     * If defined, every coverage in the collection has the given domain type, typically a URI.\r\n     * \r\n     * @type {string|undefined}\r\n     */\r\n    this.domainType = domainType\r\n    \r\n    \r\n    let covs = []\r\n    let rootParams = covjson.parameters ? covjson.parameters : {}\r\n    // generate local parameter IDs if not existing\r\n    // this is to keep track of same parameters when copied into the coverages\r\n    // (e.g. to synchronize legends etc.)\r\n    for (let key of Object.keys(rootParams)) {\r\n      let param = rootParams[key]\r\n      if (!param.id) {\r\n        param.id = Math.round(new Date().getTime() * Math.random()).toString()\r\n      }\r\n    }\r\n    \r\n    let covOptions = {}\r\n    if (covjson.referencing) {\r\n      covOptions.referencing = covjson.referencing\r\n    }\r\n    for (let coverage of covjson.coverages) {\r\n      if (!coverage.domainType) {\r\n        coverage.domainType = domainType\r\n      }\r\n      if (!coverage.parameters) {\r\n        coverage.parameters = {}\r\n      }\r\n      for (let key of Object.keys(rootParams)) {\r\n        if (key in coverage.ranges) {\r\n          coverage.parameters[key] = rootParams[key]\r\n        }\r\n      }\r\n      if (covjson['@context']) {\r\n        coverage['@context'] = covjson['@context']\r\n      }\r\n      covs.push(new Coverage(coverage, covOptions))\r\n    }\r\n    \r\n    /** \r\n     * The Coverages of this collection.\r\n     * \r\n     * @type {Array<Coverage>} \r\n     */\r\n    this.coverages = covs\r\n    if (covjson.parameters) {\r\n      /**\r\n       * A Map from key to {@link Parameter} object.\r\n       * The key is a short alias of a {@link Parameter}, typically what is called a \"variable name\" or similar.\r\n       * \r\n       * @type {Map<string,Parameter>}\r\n       */\r\n      this.parameters = new Map()\r\n      for (let key of Object.keys(covjson.parameters)) {\r\n        transformParameter(covjson.parameters, key)\r\n        this.parameters.set(key, covjson.parameters[key])\r\n      }\r\n    }\r\n    if (covjson.domainTemplate) {\r\n      transformDomain(covjson.domainTemplate)\r\n      /**\r\n       * @ignore\r\n       */\r\n      this.domainTemplate = covjson.domainTemplate\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * \r\n   * @return {CollectionQuery}\r\n   */\r\n  query () {\r\n    return new CollectionQuery(this)\r\n  }\r\n  \r\n  _exposeLd (covjson) {\r\n    if (!covjson['@context']) {\r\n      // no LD love here...\r\n      return\r\n    }\r\n    // make a deep copy since the object gets modified in-place later\r\n    // but first, remove the coverages (those have their own .ld property)\r\n    let copy = shallowcopy(covjson)\r\n    delete copy.coverages\r\n    this.ld = JSON.parse(JSON.stringify(copy))\r\n  }\r\n}\r\n","import Coverage from './Coverage.js'\r\nimport {transformDomain} from './Coverage.js'\r\nimport CoverageCollection from './CoverageCollection.js'\r\nimport {assert} from './util.js'\r\nimport {COVERAGE, COVERAGECOLLECTION, DOMAIN, LINKRELPREFIX} from './constants.js'\r\n\r\n// NO FILE EXTENSION, to work around JSPM bug in handling package.json's \"browser\" field\r\n// see https://github.com/jspm/jspm-cli/issues/1062#issuecomment-170342414\r\nimport * as http from './http'\r\n\r\n/**\r\n * Loads a CoverageJSON document from a given URL and returns a {@link Promise} object\r\n * that succeeds with the unmodified CoverageJSON object.\r\n * \r\n * @param {string} url The URL to load the CoverageJSON document from.\r\n * @param {Object} [options] An options object. \r\n * @param {Object} [options.headers] Additional HTTP headers to send if input is a URL.\r\n * @param {Object} [options.eagerload]\r\n *   Request a stand-alone CoverageJSON document (with domain and ranges embedded) if input is a URL.\r\n *   Note that the server may ignore that preference.\r\n * @return {Promise}\r\n *   A Promise succeeding with an object <code>{data, headers}</code> where data is the CoverageJSON object\r\n *   and headers are the HTTP response headers with lower-cased header names as object keys.\r\n *   The promise fails if the resource at the given URL is not a valid JSON or CBOR document. \r\n */\r\nexport function load (url, options) {\r\n  return http.load(url, options)\r\n}\r\n\r\n/**\r\n * Reads a CoverageJSON document and returns a {@link Promise} that succeeds with\r\n * a Domain, {@link Coverage}, or {@link CoverageCollection} object.\r\n * \r\n * Note that if the document references external domain or range documents,\r\n * then these are not loaded immediately. \r\n * \r\n * \r\n * @example\r\n * CovJSON.read('http://example.com/coverage.covjson').then(function (cov) {\r\n *   // work with Coverage data object\r\n * }).catch(function (e) {\r\n *   // there was an error when loading the coverage data\r\n *   console.log(e)\r\n * })\r\n * @param {Object|string} input \r\n *    A CoverageJSON Domain, Coverage, or Coverage Collection document, as URL or object.\r\n * @param {Object} [options]\r\n *   An options object. \r\n * @param {Object} [options.headers]\r\n *   Additional HTTP headers to send if input is a URL.\r\n * @param {Object} [options.eagerload]\r\n *   Request a stand-alone CoverageJSON document (with domain and ranges embedded) if input is a URL.\r\n *   Note that the server may ignore that preference. \r\n * @return {Promise} \r\n *    A promise object succeeding with a Domain, {@link Coverage}, or {@link CoverageCollection} object,\r\n *    and failing with an {@link Error} object.\r\n */\r\nexport function read (input, options = {}) {\r\n  if (typeof input === 'object') {\r\n    return Promise.resolve().then(() => transformCovJSON(input))\r\n  } else {\r\n    return load(input, options).then(({data,headers}) => transformCovJSON(data, headers))\r\n  }\r\n}\r\n\r\n/**\r\n * Transforms a CoverageJSON object into one or more Coverage objects.\r\n *  \r\n * @param {object} obj A CoverageJSON object of type Coverage or CoverageCollection.\r\n * @param {array} headers An optional array of HTTP headers. Keys are lower-cased header names.\r\n * @return {Coverage|Array of Coverage}\r\n */\r\nfunction transformCovJSON (obj, headers) {\r\n  checkValidCovJSON(obj)\r\n  if ([COVERAGE, COVERAGECOLLECTION, DOMAIN].indexOf(obj.type) === -1) {\r\n    throw new Error('CoverageJSON document must be of Coverage, CoverageCollection, or Domain type')\r\n  }\r\n  \r\n  let result\r\n  if (obj.type === DOMAIN) {\r\n    transformDomain(obj)\r\n    result = obj\r\n  } else  if (obj.type === COVERAGE) {\r\n    result = new Coverage(obj)\r\n  } else {\r\n    result = new CoverageCollection(obj)\r\n  }\r\n  \r\n  if (obj.type === COVERAGE || obj.type === COVERAGECOLLECTION) {\r\n    addLinkRelations(result, headers)\r\n  }\r\n    \r\n  return result\r\n}\r\n\r\n/**\r\n * Scans the supplied HTTP headers for Link relations and adds them\r\n * to the .ld property of the Coverage/CoverageCollection.\r\n */    \r\nfunction addLinkRelations (cov, headers) {  \r\n  if (!headers || !headers['link']) {\r\n    return\r\n  }\r\n  \r\n  let ld = cov.ld\r\n  \r\n  for (let link of headers['link'].split(',')) {\r\n    link = link.trim()\r\n    // FIXME this will fail if the URL contains a \";\" which is valid (see RFC5988)\r\n    let parts = link.split(';')\r\n    let url = parts[0].substr(1, parts[0].length-2)\r\n    for (let param of parts.slice(1)) {\r\n      let relStart = param.indexOf('rel=')\r\n      if (relStart === -1) {\r\n        continue\r\n      }\r\n      let rel = param.substring(relStart+5, param.length-1)\r\n      if (!rel.startsWith('http://') && !rel.startsWith('https://')) {\r\n        rel = LINKRELPREFIX + rel\r\n      }\r\n      if (ld[rel]) {\r\n        if (Array.isArray(ld[rel])) {\r\n          ld[rel].push(url)\r\n        } else {\r\n          ld[rel] = [ld[rel], url]\r\n        }\r\n      } else {\r\n        ld[rel] = url\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Performs basic structural checks to validate whether a given object is a CoverageJSON object.\r\n * \r\n * Note that this method is not comprehensive and should not be used for checking\r\n * whether an object fully conforms to the CoverageJSON specification.\r\n * \r\n * @param obj\r\n * @throws {Error} when obj is not a valid CoverageJSON document \r\n */\r\nfunction checkValidCovJSON (obj) {\r\n  assert('type' in obj, '\"type\" missing')\r\n  if (obj.type === COVERAGE) {\r\n    assert('parameters' in obj, '\"parameters\" missing')\r\n    assert('domain' in obj, '\"domain\" missing')\r\n    assert('ranges' in obj, '\"ranges\" missing')\r\n  } else if (obj.type === COVERAGECOLLECTION) {\r\n    assert(Array.isArray(obj.coverages), '\"coverages\" must be an array')\r\n  }\r\n}\r\n"],"names":["createCommonjsModule","fn","module","exports","assert","condition","message","Error","shallowcopy","obj","copy","Object","create","getPrototypeOf","prop","getNamespacePrefixes","doc","context","Array","isArray","prefixes","Map","item","keys","key","set","getAcceptHeader","standalone","covjsonProfile","COVJSON_PROFILE_STANDALONE","accept","MEDIATYPE","COVJSON","JSONLD","JSON","load","url","options","responseType","indexOf","headers","Promise","resolve","reject","req","XMLHttpRequest","open","eagerload","setRequestHeader","header","addEventListener","status","data","window","TextDecoder","t0","Date","parse","decode","DataView","response","log","responseHeaders","parseResponseHeaders","getAllResponseHeaders","e","send","headerStr","headerPairs","split","i","length","headerPair","index","substring","toLowerCase","val","getRangeAxisOrder","domain","range","_axisNames","needsRangeAxisOrder","axes","values","filter","axis","axisOrder","_rangeAxisOrder","getRangeShapeArray","_shape","shape","map","get","k","matchesDomain","every","v","loadRangesFn","cov","undefined","paramKeys","parameters","from","all","loadRange","then","ranges","loadRangeFn","globalConstraints","loadDomain","rangeOrUrl","_covjson","paramKey","rawRange","doLoadRange","result","normalizeIndexSubsetConstraints","type","cacheRanges","_updateLoadStatus","newrange","subsetNdArrayRangeByIndex","loadTiledNdArraySubset","constraints","constraintsArr","axisNames","name","fillNulls","tileShape","tilesetsStats","tileSets","getTilesetStats","ts","idxBestTileset","indexOfBestTileset","tileset","subsetTilesetAxes","ax","start","stop","step","tileSize","tileStart","Math","floor","tileStop","ceil","tilesetAxis","t","mid","iv","ivStart","ivStop","tileStartR","tileStopR","push","subsetShape","subsetSize","reduce","l","r","subsetNdArr","ndarray","urlTemplate","template","tiles","cartesianProduct","promises","tileUrlVars","forEach","expand","tileRange","tileOffsets","tile","tileAxesSubsetIndices","tileAxisSize","tileAxisOffset","tileAxisSubsetIndices","startIdx","stopIdx","idx","tileSubsetIndices","tileInd","_ndarr","subsetInd","dataType","createRangeGetFunction","arr","a","b","x","concat","y","tileCount","nvalues","max","valueCount","tileValueRatio","efforts","s","minEffortIdx","imin","ndarr","los","his","steps","newndarr","hi","lo","subsetByIndexFn","newdomain","subsetDomainByIndex","newGlobalConstraints","toGlobalSubsetConstraints","newcov","COVERAGE","domainProfiles","domainType","loadRanges","subsetByIndex","subsetByValue","subsetCoverageByValue","bind","transformParameter","params","param","unit","symbol","categoryEncoding","category","vals","__transformDone","transformNdArrayRange","actualMin","minMax","min","actualMax","shapeArr","ndargs","Function","transformDomain","referencing","DOMAINTYPES_PREFIX","axisName","CORE_PREFIX","components","coordinates","Float64Array","num","bounds","wrapBounds","rangeAxisOrder","localConstraints","res","local","globalStart","globalStep","http.load","read","input","transformCovJSON","COVERAGECOLLECTION","DOMAIN","Coverage","CoverageCollection","addLinkRelations","ld","link","trim","parts","substr","slice","relStart","rel","startsWith","LINKRELPREFIX","checkValidCovJSON","coverages","commonjsGlobal","global","self","_isBuffer","constructor","isBuffer","iota","n","compare1st","order","stride","this","terms","abs","sort","compileConstructor","dtype","dimension","className","join","useGetters","code","procedure","CACHED_CONSTRUCTORS","indices","args","index_str","shapeArg","strideArg","a_vars","c_vars","tShape","tStride","arrayDType","hasTypedArrays","prototype","toString","call","wrappedNDArrayCtor","offset","ctor","array","d","sz","ctor_list","require$$1","require$$0","float32","float64","int8","int16","int32","uint8","uint16","uint32","uint8_clamped","buffer","generic","root","factory","define","amd","urltemplate","UrlTemplate","encodeReserved","str","part","test","encodeURI","replace","encodeUnreserved","encodeURIComponent","c","charCodeAt","toUpperCase","encodeValue","operator","value","isDefined","isKeyOperator","getValues","modifier","parseInt","tmp","that","operators","_","expression","literal","charAt","variable","exec","apply","separator","PREFIX","_typeof","Symbol","iterator","classCallCheck","instance","Constructor","TypeError","createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","protoProps","staticProps","slicedToArray","sliceIterator","_arr","_n","_d","_e","_s","_i","next","done","err","toConsumableArray","arr2","covjson","_exposeLd","id","isLoaded","domainLoaded","rangesLoaded","_this","loaded","stringify","domainOrUrl","_domainPromise","promise","_this2","covs","rootParams","round","getTime","random","covOptions","coverage","domainTemplate","CollectionQuery"],"mappings":"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"}