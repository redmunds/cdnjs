{"version":3,"file":"oojs.min.js","sources":["oojs.js"],"names":["global","simpleArrayCombine","a","b","includeB","i","ilen","isInB","bObj","result","length","push","oo","hasOwn","hasOwnProperty","toString","initClass","fn","inheritClass","targetFn","originFn","prototype","Error","targetConstructor","constructor","parent","Object","create","value","enumerable","writable","configurable","mixinClass","key","call","getProp","obj","retval","arguments","undefined","setProp","prop","cloneObject","origin","r","getObjectValues","values","TypeError","compare","asymmetrical","aValue","bValue","aType","bType","k","nodeType","isEqualNode","copy","source","leafCallback","nodeCallback","destination","Array","isArray","clone","cloneNode","isPlainObject","getHash","val","JSON","stringify","keySortReplacer","normalized","keys","len","getHashObject","sort","unique","arr","reduce","current","indexOf","simpleArrayUnion","j","jlen","simpleArrayIntersection","simpleArrayDifference","window","e","validateMethod","method","context","EventEmitter","this","bindings","on","event","args","once","listener","eventEmitter","wrapper","off","apply","splice","emit","binding","slice","concat","connect","methods","disconnect","Registry","registry","register","name","data","unregister","lookup","Factory","module","exports","OO"],"mappings":"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","sourcesContent":["/*!\n * OOjs v1.1.8\n * https://www.mediawiki.org/wiki/OOjs\n *\n * Copyright 2011-2015 OOjs Team and other contributors.\n * Released under the MIT license\n * http://oojs.mit-license.org\n *\n * Date: 2015-07-23T19:16:00Z\n */\n( function ( global ) {\n\n'use strict';\n\n/*exported toString */\nvar\n\t/**\n\t * Namespace for all classes, static methods and static properties.\n\t * @class OO\n\t * @singleton\n\t */\n\too = {},\n\t// Optimisation: Local reference to Object.prototype.hasOwnProperty\n\thasOwn = oo.hasOwnProperty,\n\ttoString = oo.toString;\n\n/* Class Methods */\n\n/**\n * Utility to initialize a class for OO inheritance.\n *\n * Currently this just initializes an empty static object.\n *\n * @param {Function} fn\n */\noo.initClass = function ( fn ) {\n\tfn.static = fn.static || {};\n};\n\n/**\n * Inherit from prototype to another using Object#create.\n *\n * Beware: This redefines the prototype, call before setting your prototypes.\n *\n * Beware: This redefines the prototype, can only be called once on a function.\n * If called multiple times on the same function, the previous prototype is lost.\n * This is how prototypal inheritance works, it can only be one straight chain\n * (just like classical inheritance in PHP for example). If you need to work with\n * multiple constructors consider storing an instance of the other constructor in a\n * property instead, or perhaps use a mixin (see OO.mixinClass).\n *\n *     function Thing() {}\n *     Thing.prototype.exists = function () {};\n *\n *     function Person() {\n *         Person.super.apply( this, arguments );\n *     }\n *     OO.inheritClass( Person, Thing );\n *     Person.static.defaultEyeCount = 2;\n *     Person.prototype.walk = function () {};\n *\n *     function Jumper() {\n *         Jumper.super.apply( this, arguments );\n *     }\n *     OO.inheritClass( Jumper, Person );\n *     Jumper.prototype.jump = function () {};\n *\n *     Jumper.static.defaultEyeCount === 2;\n *     var x = new Jumper();\n *     x.jump();\n *     x.walk();\n *     x instanceof Thing && x instanceof Person && x instanceof Jumper;\n *\n * @param {Function} targetFn\n * @param {Function} originFn\n * @throws {Error} If target already inherits from origin\n */\noo.inheritClass = function ( targetFn, originFn ) {\n\tif ( targetFn.prototype instanceof originFn ) {\n\t\tthrow new Error( 'Target already inherits from origin' );\n\t}\n\n\tvar targetConstructor = targetFn.prototype.constructor;\n\n\t// Using ['super'] instead of .super because 'super' is not supported\n\t// by IE 8 and below (bug 63303).\n\t// Provide .parent as alias for code supporting older browsers which\n\t// allows people to comply with their style guide.\n\ttargetFn['super'] = targetFn.parent = originFn;\n\n\ttargetFn.prototype = Object.create( originFn.prototype, {\n\t\t// Restore constructor property of targetFn\n\t\tconstructor: {\n\t\t\tvalue: targetConstructor,\n\t\t\tenumerable: false,\n\t\t\twritable: true,\n\t\t\tconfigurable: true\n\t\t}\n\t} );\n\n\t// Extend static properties - always initialize both sides\n\too.initClass( originFn );\n\ttargetFn.static = Object.create( originFn.static );\n};\n\n/**\n * Copy over *own* prototype properties of a mixin.\n *\n * The 'constructor' (whether implicit or explicit) is not copied over.\n *\n * This does not create inheritance to the origin. If you need inheritance,\n * use OO.inheritClass instead.\n *\n * Beware: This can redefine a prototype property, call before setting your prototypes.\n *\n * Beware: Don't call before OO.inheritClass.\n *\n *     function Foo() {}\n *     function Context() {}\n *\n *     // Avoid repeating this code\n *     function ContextLazyLoad() {}\n *     ContextLazyLoad.prototype.getContext = function () {\n *         if ( !this.context ) {\n *             this.context = new Context();\n *         }\n *         return this.context;\n *     };\n *\n *     function FooBar() {}\n *     OO.inheritClass( FooBar, Foo );\n *     OO.mixinClass( FooBar, ContextLazyLoad );\n *\n * @param {Function} targetFn\n * @param {Function} originFn\n */\noo.mixinClass = function ( targetFn, originFn ) {\n\tvar key;\n\n\t// Copy prototype properties\n\tfor ( key in originFn.prototype ) {\n\t\tif ( key !== 'constructor' && hasOwn.call( originFn.prototype, key ) ) {\n\t\t\ttargetFn.prototype[key] = originFn.prototype[key];\n\t\t}\n\t}\n\n\t// Copy static properties - always initialize both sides\n\too.initClass( targetFn );\n\tif ( originFn.static ) {\n\t\tfor ( key in originFn.static ) {\n\t\t\tif ( hasOwn.call( originFn.static, key ) ) {\n\t\t\t\ttargetFn.static[key] = originFn.static[key];\n\t\t\t}\n\t\t}\n\t} else {\n\t\too.initClass( originFn );\n\t}\n};\n\n/* Object Methods */\n\n/**\n * Get a deeply nested property of an object using variadic arguments, protecting against\n * undefined property errors.\n *\n * `quux = oo.getProp( obj, 'foo', 'bar', 'baz' );` is equivalent to `quux = obj.foo.bar.baz;`\n * except that the former protects against JS errors if one of the intermediate properties\n * is undefined. Instead of throwing an error, this function will return undefined in\n * that case.\n *\n * @param {Object} obj\n * @param {Mixed...} [keys]\n * @return obj[arguments[1]][arguments[2]].... or undefined\n */\noo.getProp = function ( obj ) {\n\tvar i,\n\t\tretval = obj;\n\tfor ( i = 1; i < arguments.length; i++ ) {\n\t\tif ( retval === undefined || retval === null ) {\n\t\t\t// Trying to access a property of undefined or null causes an error\n\t\t\treturn undefined;\n\t\t}\n\t\tretval = retval[arguments[i]];\n\t}\n\treturn retval;\n};\n\n/**\n * Set a deeply nested property of an object using variadic arguments, protecting against\n * undefined property errors.\n *\n * `oo.setProp( obj, 'foo', 'bar', 'baz' );` is equivalent to `obj.foo.bar = baz;` except that\n * the former protects against JS errors if one of the intermediate properties is\n * undefined. Instead of throwing an error, undefined intermediate properties will be\n * initialized to an empty object. If an intermediate property is not an object, or if obj itself\n * is not an object, this function will silently abort.\n *\n * @param {Object} obj\n * @param {Mixed...} [keys]\n * @param {Mixed} [value]\n */\noo.setProp = function ( obj ) {\n\tvar i,\n\t\tprop = obj;\n\tif ( Object( obj ) !== obj ) {\n\t\treturn;\n\t}\n\tfor ( i = 1; i < arguments.length - 2; i++ ) {\n\t\tif ( prop[arguments[i]] === undefined ) {\n\t\t\tprop[arguments[i]] = {};\n\t\t}\n\t\tif ( Object( prop[arguments[i]] ) !== prop[arguments[i]] ) {\n\t\t\treturn;\n\t\t}\n\t\tprop = prop[arguments[i]];\n\t}\n\tprop[arguments[arguments.length - 2]] = arguments[arguments.length - 1];\n};\n\n/**\n * Create a new object that is an instance of the same\n * constructor as the input, inherits from the same object\n * and contains the same own properties.\n *\n * This makes a shallow non-recursive copy of own properties.\n * To create a recursive copy of plain objects, use #copy.\n *\n *     var foo = new Person( mom, dad );\n *     foo.setAge( 21 );\n *     var foo2 = OO.cloneObject( foo );\n *     foo.setAge( 22 );\n *\n *     // Then\n *     foo2 !== foo; // true\n *     foo2 instanceof Person; // true\n *     foo2.getAge(); // 21\n *     foo.getAge(); // 22\n *\n * @param {Object} origin\n * @return {Object} Clone of origin\n */\noo.cloneObject = function ( origin ) {\n\tvar key, r;\n\n\tr = Object.create( origin.constructor.prototype );\n\n\tfor ( key in origin ) {\n\t\tif ( hasOwn.call( origin, key ) ) {\n\t\t\tr[key] = origin[key];\n\t\t}\n\t}\n\n\treturn r;\n};\n\n/**\n * Get an array of all property values in an object.\n *\n * @param {Object} Object to get values from\n * @return {Array} List of object values\n */\noo.getObjectValues = function ( obj ) {\n\tvar key, values;\n\n\tif ( obj !== Object( obj ) ) {\n\t\tthrow new TypeError( 'Called on non-object' );\n\t}\n\n\tvalues = [];\n\tfor ( key in obj ) {\n\t\tif ( hasOwn.call( obj, key ) ) {\n\t\t\tvalues[values.length] = obj[key];\n\t\t}\n\t}\n\n\treturn values;\n};\n\n/**\n * Recursively compare properties between two objects.\n *\n * A false result may be caused by property inequality or by properties in one object missing from\n * the other. An asymmetrical test may also be performed, which checks only that properties in the\n * first object are present in the second object, but not the inverse.\n *\n * If either a or b is null or undefined it will be treated as an empty object.\n *\n * @param {Object|undefined|null} a First object to compare\n * @param {Object|undefined|null} b Second object to compare\n * @param {boolean} [asymmetrical] Whether to check only that a's values are equal to b's\n *  (i.e. a is a subset of b)\n * @return {boolean} If the objects contain the same values as each other\n */\noo.compare = function ( a, b, asymmetrical ) {\n\tvar aValue, bValue, aType, bType, k;\n\n\tif ( a === b ) {\n\t\treturn true;\n\t}\n\n\ta = a || {};\n\tb = b || {};\n\n\tif ( typeof a.nodeType === 'number' && typeof a.isEqualNode === 'function' ) {\n\t\treturn a.isEqualNode( b );\n\t}\n\n\tfor ( k in a ) {\n\t\tif ( !hasOwn.call( a, k ) || a[k] === undefined || a[k] === b[k] ) {\n\t\t\t// Support es3-shim: Without the hasOwn filter, comparing [] to {} will be false in ES3\n\t\t\t// because the shimmed \"forEach\" is enumerable and shows up in Array but not Object.\n\t\t\t// Also ignore undefined values, because there is no conceptual difference between\n\t\t\t// a key that is absent and a key that is present but whose value is undefined.\n\t\t\tcontinue;\n\t\t}\n\n\t\taValue = a[k];\n\t\tbValue = b[k];\n\t\taType = typeof aValue;\n\t\tbType = typeof bValue;\n\t\tif ( aType !== bType ||\n\t\t\t(\n\t\t\t\t( aType === 'string' || aType === 'number' || aType === 'boolean' ) &&\n\t\t\t\taValue !== bValue\n\t\t\t) ||\n\t\t\t( aValue === Object( aValue ) && !oo.compare( aValue, bValue, true ) ) ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\t// If the check is not asymmetrical, recursing with the arguments swapped will verify our result\n\treturn asymmetrical ? true : oo.compare( b, a, true );\n};\n\n/**\n * Create a plain deep copy of any kind of object.\n *\n * Copies are deep, and will either be an object or an array depending on `source`.\n *\n * @param {Object} source Object to copy\n * @param {Function} [leafCallback] Applied to leaf values after they are cloned but before they are added to the clone\n * @param {Function} [nodeCallback] Applied to all values before they are cloned.  If the nodeCallback returns a value other than undefined, the returned value is used instead of attempting to clone.\n * @return {Object} Copy of source object\n */\noo.copy = function ( source, leafCallback, nodeCallback ) {\n\tvar key, destination;\n\n\tif ( nodeCallback ) {\n\t\t// Extensibility: check before attempting to clone source.\n\t\tdestination = nodeCallback( source );\n\t\tif ( destination !== undefined ) {\n\t\t\treturn destination;\n\t\t}\n\t}\n\n\tif ( Array.isArray( source ) ) {\n\t\t// Array (fall through)\n\t\tdestination = new Array( source.length );\n\t} else if ( source && typeof source.clone === 'function' ) {\n\t\t// Duck type object with custom clone method\n\t\treturn leafCallback ? leafCallback( source.clone() ) : source.clone();\n\t} else if ( source && typeof source.cloneNode === 'function' ) {\n\t\t// DOM Node\n\t\treturn leafCallback ?\n\t\t\tleafCallback( source.cloneNode( true ) ) :\n\t\t\tsource.cloneNode( true );\n\t} else if ( oo.isPlainObject( source ) ) {\n\t\t// Plain objects (fall through)\n\t\tdestination = {};\n\t} else {\n\t\t// Non-plain objects (incl. functions) and primitive values\n\t\treturn leafCallback ? leafCallback( source ) : source;\n\t}\n\n\t// source is an array or a plain object\n\tfor ( key in source ) {\n\t\tdestination[key] = oo.copy( source[key], leafCallback, nodeCallback );\n\t}\n\n\t// This is an internal node, so we don't apply the leafCallback.\n\treturn destination;\n};\n\n/**\n * Generate a hash of an object based on its name and data.\n *\n * Performance optimization: <http://jsperf.com/ve-gethash-201208#/toJson_fnReplacerIfAoForElse>\n *\n * To avoid two objects with the same values generating different hashes, we utilize the replacer\n * argument of JSON.stringify and sort the object by key as it's being serialized. This may or may\n * not be the fastest way to do this; we should investigate this further.\n *\n * Objects and arrays are hashed recursively. When hashing an object that has a .getHash()\n * function, we call that function and use its return value rather than hashing the object\n * ourselves. This allows classes to define custom hashing.\n *\n * @param {Object} val Object to generate hash for\n * @return {string} Hash of object\n */\noo.getHash = function ( val ) {\n\treturn JSON.stringify( val, oo.getHash.keySortReplacer );\n};\n\n/**\n * Sort objects by key (helper function for OO.getHash).\n *\n * This is a callback passed into JSON.stringify.\n *\n * @method getHash_keySortReplacer\n * @param {string} key Property name of value being replaced\n * @param {Mixed} val Property value to replace\n * @return {Mixed} Replacement value\n */\noo.getHash.keySortReplacer = function ( key, val ) {\n\tvar normalized, keys, i, len;\n\tif ( val && typeof val.getHashObject === 'function' ) {\n\t\t// This object has its own custom hash function, use it\n\t\tval = val.getHashObject();\n\t}\n\tif ( !Array.isArray( val ) && Object( val ) === val ) {\n\t\t// Only normalize objects when the key-order is ambiguous\n\t\t// (e.g. any object not an array).\n\t\tnormalized = {};\n\t\tkeys = Object.keys( val ).sort();\n\t\ti = 0;\n\t\tlen = keys.length;\n\t\tfor ( ; i < len; i += 1 ) {\n\t\t\tnormalized[keys[i]] = val[keys[i]];\n\t\t}\n\t\treturn normalized;\n\n\t// Primitive values and arrays get stable hashes\n\t// by default. Lets those be stringified as-is.\n\t} else {\n\t\treturn val;\n\t}\n};\n\n/**\n * Get the unique values of an array, removing duplicates\n *\n * @param {Array} arr Array\n * @return {Array} Unique values in array\n */\noo.unique = function ( arr ) {\n\treturn arr.reduce( function ( result, current ) {\n\t\tif ( result.indexOf( current ) === -1 ) {\n\t\t\tresult.push( current );\n\t\t}\n\t\treturn result;\n\t}, [] );\n};\n\n/**\n * Compute the union (duplicate-free merge) of a set of arrays.\n *\n * Arrays values must be convertable to object keys (strings).\n *\n * By building an object (with the values for keys) in parallel with\n * the array, a new item's existence in the union can be computed faster.\n *\n * @param {Array...} arrays Arrays to union\n * @return {Array} Union of the arrays\n */\noo.simpleArrayUnion = function () {\n\tvar i, ilen, arr, j, jlen,\n\t\tobj = {},\n\t\tresult = [];\n\n\tfor ( i = 0, ilen = arguments.length; i < ilen; i++ ) {\n\t\tarr = arguments[i];\n\t\tfor ( j = 0, jlen = arr.length; j < jlen; j++ ) {\n\t\t\tif ( !obj[ arr[j] ] ) {\n\t\t\t\tobj[ arr[j] ] = true;\n\t\t\t\tresult.push( arr[j] );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Combine arrays (intersection or difference).\n *\n * An intersection checks the item exists in 'b' while difference checks it doesn't.\n *\n * Arrays values must be convertable to object keys (strings).\n *\n * By building an object (with the values for keys) of 'b' we can\n * compute the result faster.\n *\n * @private\n * @param {Array} a First array\n * @param {Array} b Second array\n * @param {boolean} includeB Whether to items in 'b'\n * @return {Array} Combination (intersection or difference) of arrays\n */\nfunction simpleArrayCombine( a, b, includeB ) {\n\tvar i, ilen, isInB,\n\t\tbObj = {},\n\t\tresult = [];\n\n\tfor ( i = 0, ilen = b.length; i < ilen; i++ ) {\n\t\tbObj[ b[i] ] = true;\n\t}\n\n\tfor ( i = 0, ilen = a.length; i < ilen; i++ ) {\n\t\tisInB = !!bObj[ a[i] ];\n\t\tif ( isInB === includeB ) {\n\t\t\tresult.push( a[i] );\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Compute the intersection of two arrays (items in both arrays).\n *\n * Arrays values must be convertable to object keys (strings).\n *\n * @param {Array} a First array\n * @param {Array} b Second array\n * @return {Array} Intersection of arrays\n */\noo.simpleArrayIntersection = function ( a, b ) {\n\treturn simpleArrayCombine( a, b, true );\n};\n\n/**\n * Compute the difference of two arrays (items in 'a' but not 'b').\n *\n * Arrays values must be convertable to object keys (strings).\n *\n * @param {Array} a First array\n * @param {Array} b Second array\n * @return {Array} Intersection of arrays\n */\noo.simpleArrayDifference = function ( a, b ) {\n\treturn simpleArrayCombine( a, b, false );\n};\n\n/*global hasOwn, toString */\n\n/**\n * Assert whether a value is a plain object or not.\n *\n * @member OO\n * @param {Mixed} obj\n * @return {boolean}\n */\noo.isPlainObject = function ( obj ) {\n\t/*jshint eqnull:true, eqeqeq:false */\n\n\t// Any object or value whose internal [[Class]] property is not \"[object Object]\"\n\t// Support IE8: Explicitly filter out DOM nodes\n\t// Support IE8: Explicitly filter out Window object (needs loose comparison)\n\tif ( !obj || toString.call( obj ) !== '[object Object]' || obj.nodeType || ( obj != null && obj == obj.window ) ) {\n\t\treturn false;\n\t}\n\n\t// The try/catch suppresses exceptions thrown when attempting to access\n\t// the \"constructor\" property of certain host objects such as Location\n\t// in Firefox < 20 (https://bugzilla.mozilla.org/814622)\n\ttry {\n\t\tif ( obj.constructor &&\n\t\t\t\t!hasOwn.call( obj.constructor.prototype, 'isPrototypeOf' ) ) {\n\t\t\treturn false;\n\t\t}\n\t} catch ( e ) {\n\t\treturn false;\n\t}\n\n\treturn true;\n};\n\n/*global hasOwn */\n\n( function () {\n\n\t/**\n\t * @class OO.EventEmitter\n\t *\n\t * @constructor\n\t */\n\too.EventEmitter = function OoEventEmitter() {\n\t\t// Properties\n\n\t\t/**\n\t\t * Storage of bound event handlers by event name.\n\t\t *\n\t\t * @property\n\t\t */\n\t\tthis.bindings = {};\n\t};\n\n\too.initClass( oo.EventEmitter );\n\n\t/* Private helper functions */\n\n\t/**\n\t * Validate a function or method call in a context\n\t *\n\t * For a method name, check that it names a function in the context object\n\t *\n\t * @private\n\t * @param {Function|string} method Function or method name\n\t * @param {Mixed} context The context of the call\n\t * @throws {Error} A method name is given but there is no context\n\t * @throws {Error} In the context object, no property exists with the given name\n\t * @throws {Error} In the context object, the named property is not a function\n\t */\n\tfunction validateMethod( method, context ) {\n\t\t// Validate method and context\n\t\tif ( typeof method === 'string' ) {\n\t\t\t// Validate method\n\t\t\tif ( context === undefined || context === null ) {\n\t\t\t\tthrow new Error( 'Method name \"' + method + '\" has no context.' );\n\t\t\t}\n\t\t\tif ( typeof context[method] !== 'function' ) {\n\t\t\t\t// Technically the property could be replaced by a function before\n\t\t\t\t// call time. But this probably signals a typo.\n\t\t\t\tthrow new Error( 'Property \"' + method + '\" is not a function' );\n\t\t\t}\n\t\t} else if ( typeof method !== 'function' ) {\n\t\t\tthrow new Error( 'Invalid callback. Function or method name expected.' );\n\t\t}\n\t}\n\n\t/* Methods */\n\n\t/**\n\t * Add a listener to events of a specific event.\n\t *\n\t * The listener can be a function or the string name of a method; if the latter, then the\n\t * name lookup happens at the time the listener is called.\n\t *\n\t * @param {string} event Type of event to listen to\n\t * @param {Function|string} method Function or method name to call when event occurs\n\t * @param {Array} [args] Arguments to pass to listener, will be prepended to emitted arguments\n\t * @param {Object} [context=null] Context object for function or method call\n\t * @throws {Error} Listener argument is not a function or a valid method name\n\t * @chainable\n\t */\n\too.EventEmitter.prototype.on = function ( event, method, args, context ) {\n\t\tvar bindings;\n\n\t\tvalidateMethod( method, context );\n\n\t\tif ( hasOwn.call( this.bindings, event ) ) {\n\t\t\tbindings = this.bindings[event];\n\t\t} else {\n\t\t\t// Auto-initialize bindings list\n\t\t\tbindings = this.bindings[event] = [];\n\t\t}\n\t\t// Add binding\n\t\tbindings.push( {\n\t\t\tmethod: method,\n\t\t\targs: args,\n\t\t\tcontext: ( arguments.length < 4 ) ? null : context\n\t\t} );\n\t\treturn this;\n\t};\n\n\t/**\n\t * Add a one-time listener to a specific event.\n\t *\n\t * @param {string} event Type of event to listen to\n\t * @param {Function} listener Listener to call when event occurs\n\t * @chainable\n\t */\n\too.EventEmitter.prototype.once = function ( event, listener ) {\n\t\tvar eventEmitter = this,\n\t\t\twrapper = function () {\n\t\t\t\teventEmitter.off( event, wrapper );\n\t\t\t\treturn listener.apply( this, arguments );\n\t\t\t};\n\t\treturn this.on( event, wrapper );\n\t};\n\n\t/**\n\t * Remove a specific listener from a specific event.\n\t *\n\t * @param {string} event Type of event to remove listener from\n\t * @param {Function|string} [method] Listener to remove. Must be in the same form as was passed\n\t * to \"on\". Omit to remove all listeners.\n\t * @param {Object} [context=null] Context object function or method call\n\t * @chainable\n\t * @throws {Error} Listener argument is not a function or a valid method name\n\t */\n\too.EventEmitter.prototype.off = function ( event, method, context ) {\n\t\tvar i, bindings;\n\n\t\tif ( arguments.length === 1 ) {\n\t\t\t// Remove all bindings for event\n\t\t\tdelete this.bindings[event];\n\t\t\treturn this;\n\t\t}\n\n\t\tvalidateMethod( method, context );\n\n\t\tif ( !hasOwn.call( this.bindings, event ) || !this.bindings[event].length ) {\n\t\t\t// No matching bindings\n\t\t\treturn this;\n\t\t}\n\n\t\t// Default to null context\n\t\tif ( arguments.length < 3 ) {\n\t\t\tcontext = null;\n\t\t}\n\n\t\t// Remove matching handlers\n\t\tbindings = this.bindings[event];\n\t\ti = bindings.length;\n\t\twhile ( i-- ) {\n\t\t\tif ( bindings[i].method === method && bindings[i].context === context ) {\n\t\t\t\tbindings.splice( i, 1 );\n\t\t\t}\n\t\t}\n\n\t\t// Cleanup if now empty\n\t\tif ( bindings.length === 0 ) {\n\t\t\tdelete this.bindings[event];\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * Emit an event.\n\t *\n\t * @param {string} event Type of event\n\t * @param {Mixed} args First in a list of variadic arguments passed to event handler (optional)\n\t * @return {boolean} Whether the event was handled by at least one listener\n\t */\n\too.EventEmitter.prototype.emit = function ( event ) {\n\t\tvar args = [],\n\t\t\ti, len, binding, bindings, method;\n\n\t\tif ( hasOwn.call( this.bindings, event ) ) {\n\t\t\t// Slicing ensures that we don't get tripped up by event handlers that add/remove bindings\n\t\t\tbindings = this.bindings[event].slice();\n\t\t\tfor ( i = 1, len = arguments.length; i < len; i++ ) {\n\t\t\t\targs.push( arguments[i] );\n\t\t\t}\n\t\t\tfor ( i = 0, len = bindings.length; i < len; i++ ) {\n\t\t\t\tbinding = bindings[i];\n\t\t\t\tif ( typeof binding.method === 'string' ) {\n\t\t\t\t\t// Lookup method by name (late binding)\n\t\t\t\t\tmethod = binding.context[ binding.method ];\n\t\t\t\t} else {\n\t\t\t\t\tmethod = binding.method;\n\t\t\t\t}\n\t\t\t\tmethod.apply(\n\t\t\t\t\tbinding.context,\n\t\t\t\t\tbinding.args ? binding.args.concat( args ) : args\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\n\t/**\n\t * Connect event handlers to an object.\n\t *\n\t * @param {Object} context Object to call methods on when events occur\n\t * @param {Object.<string,string>|Object.<string,Function>|Object.<string,Array>} methods List of\n\t *  event bindings keyed by event name containing either method names, functions or arrays containing\n\t *  method name or function followed by a list of arguments to be passed to callback before emitted\n\t *  arguments\n\t * @chainable\n\t */\n\too.EventEmitter.prototype.connect = function ( context, methods ) {\n\t\tvar method, args, event;\n\n\t\tfor ( event in methods ) {\n\t\t\tmethod = methods[event];\n\t\t\t// Allow providing additional args\n\t\t\tif ( Array.isArray( method ) ) {\n\t\t\t\targs = method.slice( 1 );\n\t\t\t\tmethod = method[0];\n\t\t\t} else {\n\t\t\t\targs = [];\n\t\t\t}\n\t\t\t// Add binding\n\t\t\tthis.on( event, method, args, context );\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * Disconnect event handlers from an object.\n\t *\n\t * @param {Object} context Object to disconnect methods from\n\t * @param {Object.<string,string>|Object.<string,Function>|Object.<string,Array>} [methods] List of\n\t * event bindings keyed by event name. Values can be either method names or functions, but must be\n\t * consistent with those used in the corresponding call to \"connect\".\n\t * @chainable\n\t */\n\too.EventEmitter.prototype.disconnect = function ( context, methods ) {\n\t\tvar i, event, bindings;\n\n\t\tif ( methods ) {\n\t\t\t// Remove specific connections to the context\n\t\t\tfor ( event in methods ) {\n\t\t\t\tthis.off( event, methods[event], context );\n\t\t\t}\n\t\t} else {\n\t\t\t// Remove all connections to the context\n\t\t\tfor ( event in this.bindings ) {\n\t\t\t\tbindings = this.bindings[event];\n\t\t\t\ti = bindings.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t// bindings[i] may have been removed by the previous step's\n\t\t\t\t\t// this.off so check it still exists\n\t\t\t\t\tif ( bindings[i] && bindings[i].context === context ) {\n\t\t\t\t\t\tthis.off( event, bindings[i].method, context );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t};\n\n}() );\n\n/*global hasOwn */\n\n/**\n * @class OO.Registry\n * @mixins OO.EventEmitter\n *\n * @constructor\n */\noo.Registry = function OoRegistry() {\n\t// Mixin constructors\n\too.EventEmitter.call( this );\n\n\t// Properties\n\tthis.registry = {};\n};\n\n/* Inheritance */\n\noo.mixinClass( oo.Registry, oo.EventEmitter );\n\n/* Events */\n\n/**\n * @event register\n * @param {string} name\n * @param {Mixed} data\n */\n\n/**\n * @event unregister\n * @param {string} name\n * @param {Mixed} data Data removed from registry\n */\n\n/* Methods */\n\n/**\n * Associate one or more symbolic names with some data.\n *\n * Any existing entry with the same name will be overridden.\n *\n * @param {string|string[]} name Symbolic name or list of symbolic names\n * @param {Mixed} data Data to associate with symbolic name\n * @fires register\n * @throws {Error} Name argument must be a string or array\n */\noo.Registry.prototype.register = function ( name, data ) {\n\tvar i, len;\n\tif ( typeof name === 'string' ) {\n\t\tthis.registry[name] = data;\n\t\tthis.emit( 'register', name, data );\n\t} else if ( Array.isArray( name ) ) {\n\t\tfor ( i = 0, len = name.length; i < len; i++ ) {\n\t\t\tthis.register( name[i], data );\n\t\t}\n\t} else {\n\t\tthrow new Error( 'Name must be a string or array, cannot be a ' + typeof name );\n\t}\n};\n\n/**\n * Remove one or more symbolic names from the registry\n *\n * @param {string|string[]} name Symbolic name or list of symbolic names\n * @fires unregister\n * @throws {Error} Name argument must be a string or array\n */\noo.Registry.prototype.unregister = function ( name ) {\n\tvar i, len, data;\n\tif ( typeof name === 'string' ) {\n\t\tdata = this.lookup( name );\n\t\tif ( data !== undefined ) {\n\t\t\tdelete this.registry[name];\n\t\t\tthis.emit( 'unregister', name, data );\n\t\t}\n\t} else if ( Array.isArray( name ) ) {\n\t\tfor ( i = 0, len = name.length; i < len; i++ ) {\n\t\t\tthis.unregister( name[i] );\n\t\t}\n\t} else {\n\t\tthrow new Error( 'Name must be a string or array, cannot be a ' + typeof name );\n\t}\n};\n\n/**\n * Get data for a given symbolic name.\n *\n * @param {string} name Symbolic name\n * @return {Mixed|undefined} Data associated with symbolic name\n */\noo.Registry.prototype.lookup = function ( name ) {\n\tif ( hasOwn.call( this.registry, name ) ) {\n\t\treturn this.registry[name];\n\t}\n};\n\n/**\n * @class OO.Factory\n * @extends OO.Registry\n *\n * @constructor\n */\noo.Factory = function OoFactory() {\n\t// Parent constructor\n\too.Factory.parent.call( this );\n};\n\n/* Inheritance */\n\noo.inheritClass( oo.Factory, oo.Registry );\n\n/* Methods */\n\n/**\n * Register a constructor with the factory.\n *\n * Classes must have a static `name` property to be registered.\n *\n *     function MyClass() {};\n *     OO.initClass( MyClass );\n *     // Adds a static property to the class defining a symbolic name\n *     MyClass.static.name = 'mine';\n *     // Registers class with factory, available via symbolic name 'mine'\n *     factory.register( MyClass );\n *\n * @param {Function} constructor Constructor to use when creating object\n * @throws {Error} Name must be a string and must not be empty\n * @throws {Error} Constructor must be a function\n */\noo.Factory.prototype.register = function ( constructor ) {\n\tvar name;\n\n\tif ( typeof constructor !== 'function' ) {\n\t\tthrow new Error( 'constructor must be a function, cannot be a ' + typeof constructor );\n\t}\n\tname = constructor.static && constructor.static.name;\n\tif ( typeof name !== 'string' || name === '' ) {\n\t\tthrow new Error( 'Name must be a string and must not be empty' );\n\t}\n\n\t// Parent method\n\too.Factory.parent.prototype.register.call( this, name, constructor );\n};\n\n/**\n * Unregister a constructor from the factory.\n *\n * @param {Function} constructor Constructor to unregister\n * @throws {Error} Name must be a string and must not be empty\n * @throws {Error} Constructor must be a function\n */\noo.Factory.prototype.unregister = function ( constructor ) {\n\tvar name;\n\n\tif ( typeof constructor !== 'function' ) {\n\t\tthrow new Error( 'constructor must be a function, cannot be a ' + typeof constructor );\n\t}\n\tname = constructor.static && constructor.static.name;\n\tif ( typeof name !== 'string' || name === '' ) {\n\t\tthrow new Error( 'Name must be a string and must not be empty' );\n\t}\n\n\t// Parent method\n\too.Factory.parent.prototype.unregister.call( this, name );\n};\n\n/**\n * Create an object based on a name.\n *\n * Name is used to look up the constructor to use, while all additional arguments are passed to the\n * constructor directly, so leaving one out will pass an undefined to the constructor.\n *\n * @param {string} name Object name\n * @param {Mixed...} [args] Arguments to pass to the constructor\n * @return {Object} The new object\n * @throws {Error} Unknown object name\n */\noo.Factory.prototype.create = function ( name ) {\n\tvar obj, i,\n\t\targs = [],\n\t\tconstructor = this.lookup( name );\n\n\tif ( !constructor ) {\n\t\tthrow new Error( 'No class registered by that name: ' + name );\n\t}\n\n\t// Convert arguments to array and shift the first argument (name) off\n\tfor ( i = 1; i < arguments.length; i++ ) {\n\t\targs.push( arguments[i] );\n\t}\n\n\t// We can't use the \"new\" operator with .apply directly because apply needs a\n\t// context. So instead just do what \"new\" does: create an object that inherits from\n\t// the constructor's prototype (which also makes it an \"instanceof\" the constructor),\n\t// then invoke the constructor with the object as context, and return it (ignoring\n\t// the constructor's return value).\n\tobj = Object.create( constructor.prototype );\n\tconstructor.apply( obj, args );\n\treturn obj;\n};\n\n/*jshint node:true */\nif ( typeof module !== 'undefined' && module.exports ) {\n\tmodule.exports = oo;\n} else {\n\tglobal.OO = oo;\n}\n\n}( this ) );\n"]}